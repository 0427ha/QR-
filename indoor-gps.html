<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê³µí•­ ì‹¤ë‚´ GPS - ì™„ì„± ë²„ì „</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 10px; background: #f0f0f0; }
        #map { height: 400px; border: 2px solid #ccc; border-radius: 8px; }
        .controls { margin: 10px 0; padding: 10px; background: white; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        select, button { padding: 8px; margin: 5px; border: 1px solid #ddd; border-radius: 4px; }
        button { background: #007bff; color: white; cursor: pointer; }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        #status { padding: 10px; border-radius: 4px; margin: 10px 0; font-weight: bold; }
        .status-ok { background: #d4edda; color: #155724; }
        .status-err { background: #f8d7da; color: #721c24; }
        #nav-bar { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: #1e3a8a; color: white; padding: 15px; border-radius: 20px; box-shadow: 0 -2px 10px rgba(0,0,0,0.2); display: none; }
        #nav-bar.show { display: block; }
        .nav-info { display: flex; align-items: center; gap: 10px; }
        .fov-icon { font-size: 24px; }
    </style>
</head>
<body>
    <h1>âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS (ì‹¤ì œ ì´ë™ ì•ˆë‚´)</h1>
    
    <div class="controls">
        <label>ì¶œë°œ: <select id="start-area"></select></label>
        <label>ë„ì°©: <select id="end-area"></select></label>
        <button id="search-btn">ê²½ë¡œ ê²€ìƒ‰</button>
        <div id="status" class="status-err">ì¤€ë¹„: ì¶œë°œ/ë„ì°© ì„ íƒ í›„ ê²€ìƒ‰í•˜ì„¸ìš”.</div>
    </div>
    
    <div id="map"></div>
    
    <div id="steps" style="margin-top: 10px; padding: 10px; background: white; border-radius: 8px; display: none;"></div>
    
    <div id="nav-bar" class="nav-info">
        <div class="fov-icon" id="direction-icon">ğŸ§­</div>
        <div>
            <div id="instruction">ëŒ€ê¸° ì¤‘</div>
            <div id="distance">ë‚¨ì€ ê±°ë¦¬: - m</div>
        </div>
        <button id="nav-toggle">ë‚´ë¹„ ì‹œì‘</button>
    </div>

    <script>
        // ê³µí•­ ë°ì´í„° (ë„ˆì˜ A~I êµ¬ì¡°)
        const AREAS = {
            'A': { name: 'A. êµ­ì œì„  ë„ì°© (1ì¸µ)', lat: 37.510000, lon: 127.050000 },
            'B': { name: 'B. ë©´ì„¸í’ˆ ìˆ˜ë ¹ (1ì¸µ)', lat: 37.510000, lon: 127.051800 },
            'C': { name: 'C. í™˜ì „ì†Œ (1ì¸µ)', lat: 37.510000, lon: 127.053600 },
            'D': { name: 'D. êµ­ë‚´ì„  ì²´í¬ì¸ (2ì¸µ)', lat: 37.508500, lon: 127.050000 },
            'E': { name: 'E. ì¶œêµ­ ì‹¬ì‚¬ëŒ€ (2ì¸µ)', lat: 37.508500, lon: 127.051800 },
            'F': { name: 'F. í‘¸ë“œì½”íŠ¸ (2ì¸µ)', lat: 37.508500, lon: 127.053600 },
            'G': { name: 'G. ë¼ìš´ì§€ (3ì¸µ)', lat: 37.507000, lon: 127.050000 },
            'H': { name: 'H. ë©´ì„¸ì  ì¤‘ì•™ (3ì¸µ)', lat: 37.507000, lon: 127.051800 },
            'I': { name: 'I. íƒ‘ìŠ¹ ê²Œì´íŠ¸ (3ì¸µ)', lat: 37.507000, lon: 127.053600 }
        };

        const CONNECTIONS = [
            { from: 'A', to: 'B', dist: 15 }, { from: 'B', to: 'C', dist: 15 },
            { from: 'D', to: 'E', dist: 15 }, { from: 'E', to: 'F', dist: 15 },
            { from: 'G', to: 'H', dist: 15 }, { from: 'H', to: 'I', dist: 15 },
            { from: 'A', to: 'D', dist: 17 }, { from: 'B', to: 'E', dist: 17 }, { from: 'C', to: 'F', dist: 17 },
            { from: 'D', to: 'G', dist: 17 }, { from: 'E', to: 'H', dist: 17 }, { from: 'F', to: 'I', dist: 17 },
            { from: 'A', to: 'E', dist: 21 }, { from: 'B', to: 'D', dist: 21 }, { from: 'B', to: 'F', dist: 21 },
            { from: 'E', to: 'C', dist: 21 }
        ];

        let map, userMarker, fovLayer, routeLayer, currentRoute = null, currentStep = 0, gpsOffset = { lat: 0, lon: 0 };
        let isNavigating = false, watchId = null, heading = 0;

        // ì´ˆê¸°í™”
        window.onload = function() {
            // ì§€ë„ ìƒì„± (ì¤‘ì‹¬: ê³µí•­ ì¢Œí‘œ, ì¤Œ: 18ë¡œ ì‹¤ë‚´ê¸‰)
            map = L.map('map').setView([37.509000, 127.051800], 18);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

            // ì˜ì—­ ë§ˆì»¤ ì¶”ê°€ (íŒŒë€ ì›)
            Object.entries(AREAS).forEach(([id, { name, lat, lon }]) => {
                L.circleMarker([lat, lon], { radius: 8, color: 'blue', fillOpacity: 0.7 })
                    .bindPopup(`<b>${id}</b><br>${name}`)
                    .addTo(map);
            });

            // ì—°ê²°ì„  ì¶”ê°€ (íšŒìƒ‰ ì„ )
            CONNECTIONS.forEach(({ from, to, dist }) => {
                const p1 = [AREAS[from].lat, AREAS[from].lon];
                const p2 = [AREAS[to].lat, AREAS[to].lon];
                L.polyline([p1, p2], { color: 'gray', weight: 2 }).addTo(map);
            });

            // UI ì±„ìš°ê¸°
            const startSel = document.getElementById('start-area');
            const endSel = document.getElementById('end-area');
            Object.entries(AREAS).forEach(([id, { name }]) => {
                const opt = new Option(`${id}: ${name}`, id);
                startSel.add(opt);
                endSel.add(opt.cloneNode(true));
            });
            endSel.value = 'I';

            // ì´ë²¤íŠ¸
            document.getElementById('search-btn').onclick = searchRoute;
            document.getElementById('nav-toggle').onclick = toggleNav;
            lucide.createIcons();

            updateStatus('error', 'ì¶œë°œ/ë„ì°© ì„ íƒ í›„ "ê²½ë¡œ ê²€ìƒ‰" í´ë¦­í•˜ì„¸ìš”.');
        };

        // ê²½ë¡œ ê²€ìƒ‰
        function searchRoute() {
            const start = document.getElementById('start-area').value;
            const end = document.getElementById('end-area').value;
            if (!start || !end || start === end) {
                updateStatus('error', 'ì¶œë°œê³¼ ë„ì°©ì„ ë‹¤ë¥´ê²Œ ì„ íƒí•˜ì„¸ìš”.');
                return;
            }

            // ë‹¤ìµìŠ¤íŠ¸ë¼ë¡œ ê²½ë¡œ ê³„ì‚° (ê°„ë‹¨ ë²„ì „)
            const graph = {};
            CONNECTIONS.forEach(c => {
                if (!graph[c.from]) graph[c.from] = [];
                graph[c.from].push({ to: c.to, dist: c.dist });
                if (!graph[c.to]) graph[c.to] = [];
                graph[c.to].push({ to: c.from, dist: c.dist });
            });

            const distances = { [start]: 0 };
            const previous = {};
            const queue = Object.keys(graph);
            while (queue.length) {
                const u = queue.reduce((a, b) => (distances[a] ?? Infinity) < (distances[b] ?? Infinity) ? a : b);
                queue.splice(queue.indexOf(u), 1);
                if (u === end) break;
                graph[u]?.forEach(n => {
                    const alt = distances[u] + n.dist;
                    if (alt < (distances[n.to] ?? Infinity)) {
                        distances[n.to] = alt;
                        previous[n.to] = u;
                    }
                });
            }

            if (!distances[end]) {
                updateStatus('error', 'ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            // ê²½ë¡œ ì¬êµ¬ì„±
            const path = [];
            let cur = end;
            while (cur) {
                path.unshift(cur);
                cur = previous[cur];
            }
            currentRoute = { path, totalDist: distances[end], steps: [] };
            for (let i = 0; i < path.length - 1; i++) {
                const conn = CONNECTIONS.find(c => (c.from === path[i] && c.to === path[i + 1]) || (c.from === path[i + 1] && c.to === path[i]));
                currentRoute.steps.push({ to: path[i + 1], dist: conn?.dist || 0, turn: 'ì§ì§„' }); // í„´ì€ ê°„ë‹¨íˆ
            }

            // ì§€ë„ì— ê²½ë¡œ í‘œì‹œ (ë¹¨ê°„ ì„ )
            routeLayer = L.layerGroup().clearLayers();
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = [AREAS[path[i]].lat, AREAS[path[i]].lon];
                const p2 = [AREAS[path[i + 1]].lat, AREAS[path[i + 1]].lon];
                L.polyline([p1, p2], { color: 'red', weight: 5 }).addTo(routeLayer);
            }
            routeLayer.addTo(map);

            // ìŠ¤í… ë¦¬ìŠ¤íŠ¸ í‘œì‹œ
            const stepsDiv = document.getElementById('steps');
            let html = '<h3>ì „ì²´ ê²½ë¡œ</h3><ol>';
            currentRoute.steps.forEach((s, i) => {
                html += `<li>${i + 1}. ${AREAS[s.to].name} (${s.dist}m)</li>`;
            });
            html += '</ol>';
            stepsDiv.innerHTML = html;
            stepsDiv.style.display = 'block';

            updateStatus('ok', `ê²½ë¡œ ì¤€ë¹„ ì™„ë£Œ! ì´ ${currentRoute.totalDist}m (${Math.ceil(currentRoute.totalDist / 60)}ë¶„)`);
            document.getElementById('nav-bar').classList.add('show');
            document.getElementById('nav-toggle').disabled = false;
            document.getElementById('nav-toggle').textContent = 'ë‚´ë¹„ ì‹œì‘';
        }

        // ë‚´ë¹„ í† ê¸€
        function toggleNav() {
            const btn = document.getElementById('nav-toggle');
            if (isNavigating) {
                // ì •ì§€
                isNavigating = false;
                btn.textContent = 'ë‚´ë¹„ ì¬ê°œ';
                if (watchId) navigator.geolocation.clearWatch(watchId);
                if (userMarker) map.removeLayer(userMarker);
                if (fovLayer) map.removeLayer(fovLayer);
                updateStatus('error', 'ë‚´ë¹„ ì¤‘ì§€ë¨. ì¬ê°œí•˜ì„¸ìš”.');
            } else {
                // ì‹œì‘
                isNavigating = true;
                btn.textContent = 'ë‚´ë¹„ ì •ì§€';
                currentStep = 0;
                gpsOffset = { lat: 0, lon: 0 }; // ì´ˆê¸° ì˜¤í”„ì…‹
                startGPS();
                updateStatus('ok', 'GPS ì¶”ì  ì‹œì‘. ì´ë™í•˜ì„¸ìš”!');
            }
        }

        // GPS ì‹œì‘
        function startGPS() {
            // ë°©í–¥ ì„¼ì„œ
            if ('DeviceOrientationEvent' in window) {
                window.addEventListener('deviceorientation', e => {
                    heading = e.webkitCompassHeading || e.alpha || 0;
                    if (isNavigating && userMarker) updateFOV();
                });
            }

            // ìœ„ì¹˜ ì¶”ì 
            watchId = navigator.geolocation.watchPosition(updatePosition, () => updateStatus('error', 'GPS ì˜¤ë¥˜'), {
                enableHighAccuracy: true, timeout: 5000, maximumAge: 0
            });

            // ì´ˆê¸° ìœ„ì¹˜ë¡œ ì˜¤í”„ì…‹ ì„¤ì •
            navigator.geolocation.getCurrentPosition(pos => {
                gpsOffset.lat = pos.coords.latitude - AREAS[currentRoute.path[0]].lat;
                gpsOffset.lon = pos.coords.longitude - AREAS[currentRoute.path[0]].lon;
                updatePosition(pos);
            });
        }

        // ìœ„ì¹˜ ì—…ë°ì´íŠ¸
        function updatePosition(pos) {
            const { latitude, longitude } = pos.coords;
            const mapLat = latitude - gpsOffset.lat;
            const mapLon = longitude - gpsOffset.lon;

            // ì‚¬ìš©ì ë§ˆì»¤ (ë…¸ë€ ì›)
            if (userMarker) map.removeLayer(userMarker);
            userMarker = L.circleMarker([mapLat, mapLon], { radius: 8, color: 'yellow', fillOpacity: 1 }).addTo(map);

            // í˜„ì¬ ìŠ¤í… ì²´í¬ & ì—…ë°ì´íŠ¸
            if (currentStep < currentRoute.steps.length) {
                const target = AREAS[currentRoute.steps[currentStep].to];
                const dist = getDistance(mapLat, mapLon, target.lat, target.lon);
                document.getElementById('distance').textContent = `ë‚¨ì€ ê±°ë¦¬: ${Math.round(dist)}m`;
                document.getElementById('instruction').textContent = currentRoute.steps[currentStep].to + 'ìœ¼ë¡œ ' + currentRoute.steps[currentStep].turn;

                if (dist < 5) { // ì„ê³„ê°’
                    currentStep++;
                    if (currentStep >= currentRoute.steps.length) {
                        updateStatus('ok', 'ë„ì°©!');
                        isNavigating = false;
                    }
                }
            }

            // FOV ë¶€ì±„ê¼´ ì—…ë°ì´íŠ¸
            updateFOV();
            map.panTo([mapLat, mapLon]); // ì¤‘ì‹¬ ì´ë™
        }

        // ë¶€ì±„ê¼´ (FOV) ì—…ë°ì´íŠ¸
        function updateFOV() {
            if (fovLayer) map.removeLayer(fovLayer);
            if (!userMarker || !isNavigating) return;

            // ì‚¬ìš©ì ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
            const userPos = userMarker.getLatLng();
            const angle = heading * Math.PI / 180;
            const fovAngle = 60 * Math.PI / 180; // 60ë„ ì‹œì•¼ê°

            // ë¶€ì±„ê¼´ í´ë¦¬ê³¤ (íŒŒë€ìƒ‰ ë°˜íˆ¬ëª…)
            const points = [];
            for (let i = -fovAngle / 2; i <= fovAngle / 2; i += 0.1) {
                const bearing = angle + i;
                const point = turf.destination([userPos.lng, userPos.lat], 0.001, bearing * 180 / Math.PI, { units: 'kilometers' }); // 1m ë°˜ê²½
                points.push([point.geometry.coordinates[1], point.geometry.coordinates[0]]);
            }
            points.push([userPos.lat, userPos.lng]); // ì¤‘ì‹¬

            fovLayer = L.polygon(points, { color: 'blue', fillOpacity: 0.3 }).addTo(map);
        }

        // ê±°ë¦¬ ê³„ì‚° (Haversine)
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // ì§€êµ¬ ë°˜ê²½ (m)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon/2) * Math.sin(dLon/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // ìƒíƒœ ì—…ë°ì´íŠ¸
        function updateStatus(type, msg) {
            const el = document.getElementById('status');
            el.textContent = msg;
            el.className = `status-${type}`;
        }
    </script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script> <!-- Turf.js for geometry -->
</body>
</html>