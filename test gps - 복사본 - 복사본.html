<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Square Grid Indoor Nav (Fixed)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    body { background: #000; color: white; margin:0; overflow: hidden; touch-action: none; font-family: -apple-system, sans-serif; }
    #map-canvas { width:100%; height:60vh; background:#111; border-radius:0 0 30px 30px; }
    
    .overlay { position: absolute; top: 20px; left:0; right:0; text-align: center; z-index: 10; pointer-events: none; }
    .bottom-panel { 
        position: absolute; bottom: 0; left:0; right:0; height: 40vh; 
        background: #000; padding: 20px; display: flex; flex-direction: column; 
        border-top: 1px solid #333;
    }
    .btn { 
        background: #3b82f6; color: white; border:none; padding: 15px; 
        font-size: 1.2rem; font-weight: 800; border-radius: 15px; width: 100%; 
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); margin-top: auto; 
    }
    .step-badge {
        position: absolute; top: 20px; right: 20px;
        background: rgba(30, 41, 59, 0.8); border: 1px solid #334155;
        padding: 6px 12px; border-radius: 99px; font-size: 0.8rem; font-weight: bold; color: #94a3b8;
    }
    /* ë°©í–¥ ë°˜ì „ ë²„íŠ¼ ìŠ¤íƒ€ì¼ */
    .toggle-btn {
        background: #333; color: #fff; padding: 10px; border-radius: 10px;
        font-size: 0.9rem; border: 1px solid #555; margin-bottom: 10px;
        width: 100%; font-weight: bold;
    }
    </style>
</head>
<body>

<div class="step-badge">ğŸ‘£ <span id="step-count">0</span></div>

<div class="overlay">
    <div id="instr" class="text-3xl font-black text-cyan-400 drop-shadow-md">ëŒ€ê¸° ì¤‘</div>
    <div id="dist" class="text-xl text-gray-400 mt-1 font-mono"></div>
</div>

<canvas id="map-canvas"></canvas>

<div class="bottom-panel">
    <button id="invert-btn" class="toggle-btn">ğŸ”„ ì§€ë„ íšŒì „ ë°˜ëŒ€ë¡œ (ë°©í–¥ ì•ˆ ë§ì„ ë•Œ í´ë¦­)</button>

    <div class="flex gap-2 mb-2">
        <select id="start" class="bg-gray-800 text-white p-3 rounded-xl flex-1 font-bold border border-gray-700"></select>
        <select id="end" class="bg-gray-800 text-white p-3 rounded-xl flex-1 font-bold border border-gray-700"></select>
    </div>
    
    <div class="text-center text-gray-500 text-xs mb-2">
        í°ì„ ë“¤ê³  <b>ì œìë¦¬ ê±¸ìŒ</b>ì„ í•˜ì„¸ìš”.
    </div>

    <button id="btn" class="btn">ë‚´ë¹„ ì‹œì‘</button>
</div>

<script>
// --- ì„¤ì • ---
const STEP_LENGTH = 0.000018; 
const GAP = 0.00008; 
const BASE_LAT = 37.0; 
const BASE_LON = 127.0;

const AREAS = {
    A: {name:"A êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON},
    B: {name:"B êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP},
    C: {name:"C êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP*2},
    D: {name:"D êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON},
    E: {name:"E êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP},
    F: {name:"F êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP*2},
    G: {name:"G êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON},
    H: {name:"H êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP},
    I: {name:"I êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP*2}
};

const EDGES = [
    ['A','B'], ['B','C'], ['D','E'], ['E','F'], ['G','H'], ['H','I'],
    ['A','D'], ['D','G'], ['B','E'], ['E','H'], ['C','F'], ['F','I']
];

// --- ë³€ìˆ˜ ---
let userPos = null; 
let heading = 0;    
let currentStepCount = 0;
let isNavigating = false;
let path = []; 
let canvas, ctx;
let lastStepTime = 0;

// [í•µì‹¬] íšŒì „ ë°©í–¥ ì œì–´ ë³€ìˆ˜ (1 ë˜ëŠ” -1)
let rotationDir = -1; 

window.onload = () => {
    canvas = document.getElementById('map-canvas');
    ctx = canvas.getContext('2d');
    
    const s = document.getElementById('start');
    const e = document.getElementById('end');
    Object.keys(AREAS).forEach(k => {
        const opt = `<option value="${k}">[${k}] ${AREAS[k].name}</option>`;
        s.innerHTML += opt; e.innerHTML += opt;
    });
    s.value = "A"; e.value = "I";

    document.getElementById('btn').onclick = startNav;
    
    // [ë²„íŠ¼ ê¸°ëŠ¥] ë°©í–¥ ë°˜ì „ í´ë¦­ ì´ë²¤íŠ¸
    document.getElementById('invert-btn').onclick = () => {
        rotationDir *= -1; // ë¶€í˜¸ ë°˜ì „
        alert("íšŒì „ ë°©í–¥ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.");
    };

    window.addEventListener('resize', resize);
    resize();
    animate();
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.60;
}

function startNav() {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(res => { if (res === 'granted') initSensors(); });
    } else {
        initSensors();
    }
    const startNode = document.getElementById('start').value;
    const endNode = document.getElementById('end').value;
    path = findShortestPath(startNode, endNode);
    if(!path) return alert("ê²½ë¡œ ì—†ìŒ");
    userPos = {...AREAS[startNode]}; 
    isNavigating = true;
    currentStepCount = 0;
    
    const btn = document.getElementById('btn');
    btn.innerText = "ì¢…ë£Œ"; btn.style.background = "#ef4444";
    btn.onclick = () => location.reload();
}

function initSensors() {
    window.addEventListener('deviceorientation', e => {
        if(e.webkitCompassHeading) heading = e.webkitCompassHeading;
        else if(e.alpha) heading = 360 - e.alpha;
    });
    window.addEventListener('devicemotion', e => {
        if(!isNavigating) return;
        const acc = e.accelerationIncludingGravity;
        if(!acc) return;
        const total = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
        if (total > 11.2) { 
            const now = Date.now();
            if (now - lastStepTime > 450) { 
                takeStep(); lastStepTime = now;
            }
        }
    });
}

function takeStep() {
    currentStepCount++;
    document.getElementById('step-count').innerText = currentStepCount;
    // ë‚´ê°€ ë³´ëŠ” ë°©í–¥ìœ¼ë¡œ ì´ë™
    const rad = (heading * Math.PI) / 180;
    userPos.lat += Math.cos(rad) * STEP_LENGTH; 
    userPos.lon += Math.sin(rad) * STEP_LENGTH;
    updateStatus();
}

function updateStatus() {
    if(!path || path.length === 0) return;
    let minDist = Infinity; let nearestIdx = -1;
    path.forEach((node, i) => {
        const d = getDist(userPos, AREAS[node]);
        if(d < minDist) { minDist = d; nearestIdx = i; }
    });
    const endNode = AREAS[path[path.length-1]];
    const distToEnd = getDist(userPos, endNode);
    if (distToEnd < 5) {
        document.getElementById('instr').innerText = "ë„ì°© ì™„ë£Œ!";
        document.getElementById('dist').innerText = "";
        isNavigating = false;
        return;
    }
    let targetIdx = nearestIdx + 1;
    if (targetIdx >= path.length) targetIdx = path.length - 1;
    document.getElementById('instr').innerText = `${AREAS[path[targetIdx]].name} ë°©í–¥`;
    document.getElementById('dist').innerText = `ë‚¨ì€ ê±°ë¦¬ ${distToEnd.toFixed(0)}m`;
}

function findShortestPath(start, end) {
    const adj = {};
    EDGES.forEach(([u, v]) => {
        if(!adj[u]) adj[u] = []; if(!adj[v]) adj[v] = [];
        adj[u].push(v); adj[v].push(u);
    });
    let queue = [[start]]; let visited = new Set([start]);
    while(queue.length > 0) {
        let path = queue.shift();
        if(path[path.length-1] === end) return path;
        let node = path[path.length-1];
        if(adj[node]) {
            for(let neighbor of adj[node]) {
                if(!visited.has(neighbor)) {
                    visited.add(neighbor); queue.push([...path, neighbor]);
                }
            }
        }
    }
    return null;
}

function getDist(p1, p2) {
    const dLat = p1.lat - p2.lat; const dLon = p1.lon - p2.lon;
    return Math.sqrt(dLat*dLat + dLon*dLon) / 0.000009; 
}

function animate() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width, canvas.height);
    if(!userPos) { requestAnimationFrame(animate); return; }

    const SCALE = 1800000; 
    const cx = canvas.width/2; 
    const cy = canvas.height * 0.65; 

    const toScreen = (lat, lon) => {
        let dy = (lat - userPos.lat) * SCALE; 
        let dx = (lon - userPos.lon) * SCALE; 
        
        // [ìˆ˜ì •ë¨] rotationDir ë³€ìˆ˜ë¥¼ ê³±í•´ì„œ íšŒì „ ë°©í–¥ì„ ë’¤ì§‘ìŒ
        const rad = rotationDir * heading * Math.PI / 180;
        
        const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
        return {x: cx + rx, y: cy - ry}; 
    };

    // ê²©ì
    ctx.strokeStyle = "#333"; ctx.lineWidth = 4; ctx.beginPath();
    EDGES.forEach(([u, v]) => {
        const p1 = toScreen(AREAS[u].lat, AREAS[u].lon);
        const p2 = toScreen(AREAS[v].lat, AREAS[v].lon);
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
    });
    ctx.stroke();

    // ê²½ë¡œ
    if (path && path.length > 0) {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.4)"; ctx.lineWidth = 20; ctx.beginPath();
        for(let i=0; i<path.length-1; i++) {
            const p1 = toScreen(AREAS[path[i]].lat, AREAS[path[i]].lon);
            const p2 = toScreen(AREAS[path[i+1]].lat, AREAS[path[i+1]].lon);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    // ë…¸ë“œ
    Object.keys(AREAS).forEach(k => {
        const p = toScreen(AREAS[k].lat, AREAS[k].lon);
        const isDest = (path && path[path.length-1] === k);
        ctx.fillStyle = isDest ? "#ef4444" : "#1e293b";
        ctx.beginPath(); ctx.arc(p.x, p.y, isDest?12:8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = isDest ? "#fca5a5" : "#64748b";
        ctx.font = isDest ? "bold 16px sans-serif" : "12px sans-serif";
        ctx.textAlign="center"; ctx.fillText(AREAS[k].name, p.x, p.y-18);
    });

    // ë‚´ í™”ì‚´í‘œ (ê³ ì •)
    ctx.save(); ctx.translate(cx, cy);
    // FOV
    const grad = ctx.createRadialGradient(0,0, 10, 0,0, 120);
    grad.addColorStop(0, "rgba(255, 220, 0, 0.3)"); grad.addColorStop(1, "rgba(255, 220, 0, 0)");
    ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,0);
    ctx.arc(0, 0, 120, -Math.PI/2 - 0.5, -Math.PI/2 + 0.5); ctx.fill();
    // Arrow
    ctx.fillStyle = "#fff"; ctx.shadowBlur = 10; ctx.shadowColor="white";
    ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(-12,12); ctx.lineTo(0,8); ctx.lineTo(12,12); ctx.fill();
    ctx.restore();

    requestAnimationFrame(animate);
}
</script>
</body>
</html>