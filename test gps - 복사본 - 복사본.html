<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Perfect Indoor Nav</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    body { background: #000; color: white; margin:0; overflow: hidden; touch-action: none; font-family: -apple-system, sans-serif; }
    #map-canvas { width:100%; height:55vh; background:#111; border-radius:0 0 30px 30px; }
    .overlay { position: absolute; top: 20px; left:0; right:0; text-align: center; z-index: 10; pointer-events: none; }
    
    .bottom-panel { 
        position: absolute; bottom: 0; left:0; right:0; height: 45vh; 
        background: #000; padding: 15px; display: flex; flex-direction: column; 
        border-top: 1px solid #333;
    }
    
    .btn-start { 
        background: #3b82f6; color: white; border:none; padding: 15px; 
        font-size: 1.2rem; font-weight: 800; border-radius: 15px; width: 100%; 
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); margin-top: auto; 
    }

    /* ì„¤ì • ë²„íŠ¼ ê·¸ë£¹ */
    .calib-row { display: flex; gap: 10px; margin-bottom: 10px; }
    .calib-btn {
        flex: 1; padding: 12px; border-radius: 10px; border: 1px solid #444;
        background: #222; color: #ccc; font-size: 0.8rem; font-weight: bold;
    }
    .calib-btn.active { background: #059669; color: white; border-color: #059669; }

    .step-badge {
        position: absolute; top: 20px; right: 20px;
        background: rgba(30, 41, 59, 0.8); border: 1px solid #334155;
        padding: 6px 12px; border-radius: 99px; font-size: 0.8rem; font-weight: bold; color: #94a3b8;
    }
    </style>
</head>
<body>

<div class="step-badge">ğŸ‘£ <span id="step-count">0</span></div>

<div class="overlay">
    <div id="instr" class="text-3xl font-black text-cyan-400 drop-shadow-md">ëŒ€ê¸° ì¤‘</div>
    <div id="dist" class="text-xl text-gray-400 mt-1 font-mono"></div>
</div>

<canvas id="map-canvas"></canvas>

<div class="bottom-panel">
    <div class="text-xs text-gray-500 mb-1 ml-1">ì„¤ì • (ì•ˆ ë§ìœ¼ë©´ ëˆŒëŸ¬ë³´ì„¸ìš”)</div>
    <div class="calib-row">
        <button id="btn-rot" class="calib-btn">ğŸ”„ ì§€ë„ íšŒì „ ë°˜ì „</button>
        <button id="btn-move" class="calib-btn">â¬†ï¸ ì´ë™ ë°©í–¥ ë°˜ì „</button>
    </div>

    <div class="flex gap-2 mb-2">
        <select id="start" class="bg-gray-800 text-white p-3 rounded-xl flex-1 font-bold border border-gray-700"></select>
        <select id="end" class="bg-gray-800 text-white p-3 rounded-xl flex-1 font-bold border border-gray-700"></select>
    </div>
    
    <div class="text-center text-gray-500 text-xs mb-2">
        ì† í”ë“¤ê¸° âŒ / <b>ì‹¤ì œë¡œ ê±¸ìœ¼ì„¸ìš”</b> â­•
    </div>

    <button id="btn" class="btn-start">ë‚´ë¹„ ì‹œì‘</button>
</div>

<script>
// --- ì„¤ì • ---
const STEP_LENGTH = 0.000020; 
const GAP = 0.00008; 
const BASE_LAT = 37.0; const BASE_LON = 127.0;

const AREAS = {
    A: {name:"A êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON},
    B: {name:"B êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP},
    C: {name:"C êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP*2},
    D: {name:"D êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON},
    E: {name:"E êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP},
    F: {name:"F êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP*2},
    G: {name:"G êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON},
    H: {name:"H êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP},
    I: {name:"I êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP*2}
};

const EDGES = [
    ['A','B'], ['B','C'], ['D','E'], ['E','F'], ['G','H'], ['H','I'],
    ['A','D'], ['D','G'], ['B','E'], ['E','H'], ['C','F'], ['F','I']
];

// --- ë³€ìˆ˜ ---
let userPos = null; 
let heading = 0;    
let currentStepCount = 0;
let isNavigating = false;
let path = []; 
let canvas, ctx;

// [ë³´ì • ë³€ìˆ˜]
let rotDir = -1;  // ì§€ë„ íšŒì „ ë°©í–¥ (1 or -1)
let moveDir = 1;  // ì´ë™ ì „ì§„/í›„ì§„ (1 or -1)

// í•„í„°ë§
let lastStepTime = 0;

window.onload = () => {
    canvas = document.getElementById('map-canvas');
    ctx = canvas.getContext('2d');
    
    const s = document.getElementById('start');
    const e = document.getElementById('end');
    Object.keys(AREAS).forEach(k => {
        const opt = `<option value="${k}">[${k}] ${AREAS[k].name}</option>`;
        s.innerHTML += opt; e.innerHTML += opt;
    });
    s.value = "A"; e.value = "I";

    document.getElementById('btn').onclick = startNav;
    
    // [ë²„íŠ¼ ì´ë²¤íŠ¸]
    const btnRot = document.getElementById('btn-rot');
    const btnMove = document.getElementById('btn-move');

    btnRot.onclick = () => {
        rotDir *= -1;
        btnRot.classList.toggle('active');
    };
    btnMove.onclick = () => {
        moveDir *= -1;
        btnMove.classList.toggle('active');
    };

    window.addEventListener('resize', resize);
    resize();
    animate();
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.55;
}

function startNav() {
    if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission().then(res => { if (res === 'granted') initSensors(); });
    } else {
        initSensors();
    }
    const startNode = document.getElementById('start').value;
    const endNode = document.getElementById('end').value;
    path = findShortestPath(startNode, endNode);
    if(!path) return alert("ê²½ë¡œ ì—†ìŒ");
    userPos = {...AREAS[startNode]}; 
    isNavigating = true;
    currentStepCount = 0;
    
    const btn = document.getElementById('btn');
    btn.innerText = "ì¢…ë£Œ / ì¬ì„¤ì •"; btn.style.background = "#ef4444";
    btn.onclick = () => location.reload();
}

function initSensors() {
    window.addEventListener('deviceorientation', e => {
        if(e.webkitCompassHeading) heading = e.webkitCompassHeading;
        else if(e.alpha) heading = 360 - e.alpha;
    });

    window.addEventListener('devicemotion', e => {
        if(!isNavigating) return;
        const acc = e.accelerationIncludingGravity;
        if(!acc) return;
        const total = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
        
        // ê±¸ìŒ ê°ì§€ (ê°•ë„ 12.5 ì´ìƒ, ê°„ê²© 0.45ì´ˆ ì´ìƒ)
        if (total > 12.5) { 
            const now = Date.now();
            if (now - lastStepTime > 450) { 
                takeStep(); lastStepTime = now;
            }
        }
    });
}

function takeStep() {
    currentStepCount++;
    document.getElementById('step-count').innerText = currentStepCount;

    // [í•µì‹¬ ìˆ˜ì •] ì´ë™ ê³„ì‚°ì— moveDir ë°˜ì˜
    // íšŒì „ê°’(heading)ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ë˜, moveDirê°€ -1ì´ë©´ ë°˜ëŒ€ ë°©í–¥ìœ¼ë¡œ ì´ë™
    const rad = (heading * Math.PI) / 180;
    
    // moveDir = 1 (ì „ì§„), -1 (í›„ì§„)
    userPos.lat += moveDir * Math.cos(rad) * STEP_LENGTH; 
    userPos.lon += moveDir * Math.sin(rad) * STEP_LENGTH;
    
    updateStatus();
}

function updateStatus() {
    if(!path || path.length === 0) return;
    let minDist = Infinity; let nearestIdx = -1;
    path.forEach((node, i) => {
        const d = getDist(userPos, AREAS[node]);
        if(d < minDist) { minDist = d; nearestIdx = i; }
    });
    const endNode = AREAS[path[path.length-1]];
    const distToEnd = getDist(userPos, endNode);
    if (distToEnd < 5) {
        document.getElementById('instr').innerText = "ë„ì°© ì™„ë£Œ!";
        document.getElementById('dist').innerText = "";
        isNavigating = false;
        return;
    }
    let targetIdx = nearestIdx + 1;
    if (targetIdx >= path.length) targetIdx = path.length - 1;
    document.getElementById('instr').innerText = `${AREAS[path[targetIdx]].name} ë°©í–¥`;
    document.getElementById('dist').innerText = `ë‚¨ì€ ê±°ë¦¬ ${distToEnd.toFixed(0)}m`;
}

function findShortestPath(start, end) {
    const adj = {};
    EDGES.forEach(([u, v]) => {
        if(!adj[u]) adj[u] = []; if(!adj[v]) adj[v] = [];
        adj[u].push(v); adj[v].push(u);
    });
    let queue = [[start]]; let visited = new Set([start]);
    while(queue.length > 0) {
        let path = queue.shift();
        if(path[path.length-1] === end) return path;
        let node = path[path.length-1];
        if(adj[node]) {
            for(let neighbor of adj[node]) {
                if(!visited.has(neighbor)) {
                    visited.add(neighbor); queue.push([...path, neighbor]);
                }
            }
        }
    }
    return null;
}

function getDist(p1, p2) {
    const dLat = p1.lat - p2.lat; const dLon = p1.lon - p2.lon;
    return Math.sqrt(dLat*dLat + dLon*dLon) / 0.000009; 
}

function animate() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width, canvas.height);
    if(!userPos) { requestAnimationFrame(animate); return; }

    const SCALE = 1800000; 
    const cx = canvas.width/2; 
    const cy = canvas.height * 0.65; 

    const toScreen = (lat, lon) => {
        let dy = (lat - userPos.lat) * SCALE; 
        let dx = (lon - userPos.lon) * SCALE; 
        
        // [íšŒì „ ë°˜ì˜] rotDir ì ìš©
        const rad = rotDir * heading * Math.PI / 180;
        
        const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
        return {x: cx + rx, y: cy - ry}; 
    };

    // ê²©ì
    ctx.strokeStyle = "#333"; ctx.lineWidth = 4; ctx.beginPath();
    EDGES.forEach(([u, v]) => {
        const p1 = toScreen(AREAS[u].lat, AREAS[u].lon);
        const p2 = toScreen(AREAS[v].lat, AREAS[v].lon);
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
    });
    ctx.stroke();

    // ê²½ë¡œ
    if (path && path.length > 0) {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.4)"; ctx.lineWidth = 20; ctx.beginPath();
        for(let i=0; i<path.length-1; i++) {
            const p1 = toScreen(AREAS[path[i]].lat, AREAS[path[i]].lon);
            const p2 = toScreen(AREAS[path[i+1]].lat, AREAS[path[i+1]].lon);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    // ë…¸ë“œ
    Object.keys(AREAS).forEach(k => {
        const p = toScreen(AREAS[k].lat, AREAS[k].lon);
        const isDest = (path && path[path.length-1] === k);
        ctx.fillStyle = isDest ? "#ef4444" : "#1e293b";
        ctx.beginPath(); ctx.arc(p.x, p.y, isDest?12:8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = isDest ? "#fca5a5" : "#64748b";
        ctx.font = isDest ? "bold 16px sans-serif" : "12px sans-serif";
        ctx.textAlign="center"; ctx.fillText(AREAS[k].name, p.x, p.y-18);
    });

    // ë‚´ í™”ì‚´í‘œ
    ctx.save(); ctx.translate(cx, cy);
    const grad = ctx.createRadialGradient(0,0, 10, 0,0, 120);
    grad.addColorStop(0, "rgba(255, 220, 0, 0.3)"); grad.addColorStop(1, "rgba(255, 220, 0, 0)");
    ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,0);
    ctx.arc(0, 0, 120, -Math.PI/2 - 0.5, -Math.PI/2 + 0.5); ctx.fill();
    ctx.fillStyle = "#fff"; ctx.shadowBlur = 10; ctx.shadowColor="white";
    ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(-12,12); ctx.lineTo(0,8); ctx.lineTo(12,12); ctx.fill();
    ctx.restore();

    requestAnimationFrame(animate);
}
</script>
</body>
</html>