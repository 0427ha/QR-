<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>ê³µí•­ ì‹¤ë‚´ ë‚´ë¹„ê²Œì´ì…˜ - Tesla FSD Style</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
    body {
        font-family: 'SF Pro Display', -apple-system, sans-serif;
        background: #000;
        color: white;
        margin:0;
        min-height: 100dvh;
        overflow-x: hidden;
    }
    .tesla-bg { background: #000000; }
    #map-canvas {
        width:100%;
        height:520px;
        background:#000000;
        border-radius:20px;
        border: 1px solid #333;
        box-shadow: 0 4px 30px rgba(0,0,0,0.6);
        overflow: hidden;
        padding: 16px;
        box-sizing: border-box;
    }
    .card {
        background: rgba(15,15,15,0.9);
        backdrop-filter: blur(20px);
        border: 1px solid rgba(255,255,255,0.08);
        padding:1.5rem;
        border-radius:20px;
    }

    /* í•˜ë‹¨ ë‚´ë¹„ ë°” */
    #nav-bar {
        position:fixed; bottom:0; left:0; right:0;
        background: rgba(0,0,0,0.95);
        backdrop-filter: blur(30px);
        border-top: 1px solid rgba(255,255,255,0.08);
        padding:1rem 1rem 2rem;
        z-index:1000;
        transform: translateY(100%);
        transition: transform 0.4s ease;
    }
    #nav-bar.active { transform: translateY(0); }

    #instruction {
        font-size: 2.2rem;
        font-weight: 800;
        color: white !important;
        text-shadow: none !important;
        line-height: 1.2;
    }
    #distance {
        font-size: 1.3rem;
        color: #888;
        margin-top: 0.5rem;
    }
    #icon i {
        width: 60px !important;
        height: 60px !important;
    }
    .tesla-car {
        filter: drop-shadow(0 0 20px #ffff00);
    }
    #nav-btn {
        font-size: 1.4rem !important;
        padding: 1rem 2.5rem !important;
        border-radius: 999px;
    }
    </style>
</head>
<body class="tesla-bg text-white">

<div class="max-w-5xl mx-auto p-5 pb-40">
    <div class="text-center mb-10 mt-8">
        <h1 class="text-5xl font-black tracking-tighter tesla-text">AIRPORT NAV</h1>
        <p class="text-gray-500 mt-2 text-sm">Tesla FSD Style Interface</p>
    </div>

    <div class="card mb-6">
        <div id="status" class="p-5 rounded-2xl status-err text-center text-xl font-bold mb-6">
            ì¤€ë¹„ ì¤‘: ì¶œë°œì§€ì™€ ë„ì°©ì§€ë¥¼ ì„ íƒí•˜ì„¸ìš”.
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
            <div>
                <label class="block text-cyan-400 font-bold text-lg mb-2">
                    ì¶œë°œ êµ¬ì—­ <span id="qr-hint" class="block text-xs text-cyan-300 mt-1"></span>
                </label>
                <select id="start" class="w-full p-5 bg-black/70 border border-gray-700 rounded-2xl text-xl font-medium focus:ring-4 focus:ring-cyan-500 focus:border-cyan-500 transition"></select>
            </div>
            <div>
                <label class="block text-cyan-400 font-bold text-lg mb-2">ë„ì°© êµ¬ì—­</label>
                <select id="end" class="w-full p-5 bg-black/70 border border-gray-700 rounded-2xl text-xl font-medium focus:ring-4 focus:ring-cyan-500 focus:border-cyan-500 transition"></select>
            </div>
            <div class="flex items-end">
                <button id="find" class="w-full bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-black text-2xl py-6 rounded-2xl hover:from-cyan-400 hover:to-blue-500 transform hover:scale-105 transition shadow-2xl">
                    ê²½ë¡œ ì°¾ê¸°
                </button>
            </div>
        </div>
    </div>

    <div class="card">
        <h2 class="text-3xl font-black mb-5 tesla-text flex items-center gap-4">
            <i data-lucide="navigation" class="w-10 h-10"></i> ì‹¤ë‚´ ì§€ë„
        </h2>
        <canvas id="map-canvas"></canvas>
        <div id="info" class="mt-6 text-2xl font-bold text-center bg-black/50 rounded-2xl py-5 tesla-text"></div>
    </div>
</div>

<div id="nav-bar">
    <div class="max-w-5xl mx-auto">
        <div class="bg-black/80 backdrop-blur-xl rounded-3xl p-8 border border-white/10 shadow-2xl">
            <div class="flex items-center justify-between">
                <div class="flex items-center gap-8">
                    <div id="icon" class="tesla-car">
                        <i data-lucide="navigation" class="w-14 h-14 text-cyan-400"></i>
                    </div>
                    <div>
                        <div id="instruction" class="text-4xl font-black leading-tight" style="color:#00ffff;">ëŒ€ê¸° ì¤‘</div>
                        <div id="distance" class="text-2xl text-cyan-200 mt-2 font-bold">ë‚¨ì€ ê²½ë¡œ: -</div>
                    </div>
                </div>
                <button id="nav-btn" class="bg-white text-black font-black text-2xl px-16 py-7 rounded-full shadow-2xl hover:scale-110 transition disabled:opacity-40" disabled>
                    ë‚´ë¹„ ì‹œì‘
                </button>
            </div>
        </div>
    </div>
</div>

<script>
// --- [ìˆ˜ì • 1] í…ŒìŠ¤íŠ¸ìš© ì´ˆì†Œí˜• ë§µ ë°ì´í„° (ë°©/ë³µë„ ê·œëª¨) ---
// ìœ„ë„/ê²½ë„ ì°¨ì´ë¥¼ 0.00005 (ì•½ 5ë¯¸í„°) ë‹¨ìœ„ë¡œ ì¶•ì†Œ
const BASE_LAT = 37.500000;
const BASE_LON = 127.050000;
const GAP = 0.00005; // ì•½ 5~6ë¯¸í„° ê°„ê²©

const AREAS = {
    A: {name:"ê±°ì‹¤/ì…êµ¬", lat:BASE_LAT, lon:BASE_LON},
    B: {name:"ì¤‘ê°„ ì§€ì  1", lat:BASE_LAT, lon:BASE_LON + GAP},
    C: {name:"ì°½ê°€", lat:BASE_LAT, lon:BASE_LON + (GAP*2)},
    D: {name:"ë¶€ì—Œ ì…êµ¬", lat:BASE_LAT - GAP, lon:BASE_LON},
    E: {name:"í…Œì´ë¸”", lat:BASE_LAT - GAP, lon:BASE_LON + GAP},
    F: {name:"ì†ŒíŒŒ", lat:BASE_LAT - GAP, lon:BASE_LON + (GAP*2)},
    G: {name:"ì•ˆë°© ì…êµ¬", lat:BASE_LAT - (GAP*2), lon:BASE_LON},
    H: {name:"ë³µë„ ë", lat:BASE_LAT - (GAP*2), lon:BASE_LON + GAP},
    I: {name:"ë„ì°©ì§€(ì±…ìƒ)", lat:BASE_LAT - (GAP*2), lon:BASE_LON + (GAP*2)}
};

// ê±°ë¦¬ë¥¼ 3m, 5më¡œ ì„¤ì •í•˜ì—¬ ì‹¤ë‚´ ë³´í–‰ í…ŒìŠ¤íŠ¸ì— ë§ì¶¤
const EDGES_DATA = [
    {u:"A", v:"B", dist:5, instr:"ì•ìœ¼ë¡œ 5m ì´ë™", turn:"arrow-right"},
    {u:"B", v:"C", dist:5, instr:"ì°½ê°€ ìª½ìœ¼ë¡œ 5m ì´ë™", turn:"corner-down-right"},
    {u:"D", v:"E", dist:5, instr:"í…Œì´ë¸” ë°©í–¥ 5m ì´ë™", turn:"arrow-right"},
    {u:"E", v:"F", dist:5, instr:"ì†ŒíŒŒ ë°©í–¥ 5m ì´ë™", turn:"arrow-right"},
    {u:"G", v:"H", dist:5, instr:"ë³µë„ ìª½ìœ¼ë¡œ 5m ì´ë™", turn:"arrow-right"},
    {u:"H", v:"I", dist:5, instr:"ì±…ìƒìœ¼ë¡œ ì´ë™", turn:"arrow-right"},
    {u:"A", v:"D", dist:4, instr:"ë¶€ì—Œ ìª½ìœ¼ë¡œ 4m ì´ë™", turn:"arrow-down"},
    {u:"B", v:"E", dist:4, instr:"í…Œì´ë¸” ìª½ìœ¼ë¡œ 4m ì´ë™", turn:"arrow-down"},
    {u:"C", v:"F", dist:4, instr:"ì†ŒíŒŒ ìª½ìœ¼ë¡œ 4m ì´ë™", turn:"arrow-down"},
    {u:"D", v:"G", dist:4, instr:"ì•ˆë°© ìª½ìœ¼ë¡œ 4m ì´ë™", turn:"arrow-down"},
    {u:"E", v:"H", dist:4, instr:"ë³µë„ ì¤‘ì•™ìœ¼ë¡œ 4m ì´ë™", turn:"arrow-down"},
    {u:"F", v:"I", dist:4, instr:"ì±…ìƒ ë°©í–¥ 4m ì´ë™", turn:"arrow-down"},
    {u:"A", v:"E", dist:7, instr:"ëŒ€ê°ì„ ìœ¼ë¡œ ê°€ë¡œì§ˆëŸ¬ ì´ë™", turn:"arrow-right"},
    {u:"B", v:"D", dist:7, instr:"ëŒ€ê°ì„ ìœ¼ë¡œ ê°€ë¡œì§ˆëŸ¬ ì´ë™", turn:"arrow-left"},
    {u:"B", v:"F", dist:7, instr:"ëŒ€ê°ì„  ì´ë™", turn:"corner-down-right"},
    {u:"E", v:"C", dist:7, instr:"ëŒ€ê°ì„  ì´ë™", turn:"corner-down-left"}
];

const ALL_EDGES = [];
EDGES_DATA.forEach(edge => {
    ALL_EDGES.push({ from: edge.u, to: edge.v, dist: edge.dist, instruction: edge.instr, icon: edge.turn });
    ALL_EDGES.push({ 
        from: edge.v, 
        to: edge.u, 
        dist: edge.dist, 
        instruction: edge.instr.replace(/ì´ë™/g, 'ë˜ëŒì•„ê°'), 
        icon: {
            'arrow-right': 'arrow-left', 'arrow-left': 'arrow-right',
            'arrow-down': 'arrow-up', 'arrow-up': 'arrow-down',
            'corner-down-right': 'corner-down-left', 'corner-down-left': 'corner-down-right'
        }[edge.turn] || 'arrow-left'
    });
});

// ì „ì—­ ë³€ìˆ˜
let canvas, ctx, route = null, watching = false, watchId = null;
let userPos = null, offset = {lat:0, lon:0};
let scale = 1, tx = 0, ty = 0;

// [ìˆ˜ì • 2] íšŒì „ ìŠ¤ë¬´ë”© ë³€ìˆ˜ ë° ìœ„ì¹˜ ìŠ¤ë¬´ë”© ì¶”ê°€
let currentHeading = 0; 
let targetHeading = 0;  
let isAnimating = false;
let displayedPos = null; // í™”ë©´ì— ê·¸ë ¤ì§€ëŠ” ë¶€ë“œëŸ¬ìš´ ìœ„ì¹˜

function getUrlParam(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
}

window.onload = function() {
    canvas = document.getElementById('map-canvas');
    ctx = canvas.getContext('2d');
    
    const startSel = document.getElementById('start');
    const endSel = document.getElementById('end');
    Object.keys(AREAS).forEach(k => {
        const opt = `<option value="${k}">${k} - ${AREAS[k].name}</option>`;
        startSel.insertAdjacentHTML('beforeend', opt);
        endSel.insertAdjacentHTML('beforeend', opt);
    });
    startSel.value = "A"; 
    endSel.value = "I";
    
    const initialStart = getUrlParam('area');
    if (initialStart && AREAS[initialStart.toUpperCase()]) {
        startSel.value = initialStart.toUpperCase();
        updateStatus("ok", `URL ì„¤ì •: ${AREAS[initialStart.toUpperCase()].name}`);
    }

    document.getElementById('find').onclick = findRoute;
    document.getElementById('nav-btn').onclick = toggleNav;
    setupCanvasEvents();
    resizeCanvas();
    draw();
    lucide.createIcons();
};

function resizeCanvas() {
    const w = canvas.parentElement.clientWidth;
    canvas.width = w > 900 ? 900 : w; 
    canvas.height = canvas.width * 0.8; // ì •ì‚¬ê°í˜•ì— ê°€ê¹ê²Œ ë³€ê²½
    if (canvas.height < 400) canvas.height = 400;
    draw();
}
window.addEventListener('resize', resizeCanvas);

// --- [ìˆ˜ì • 3] ë°±ìŠ¤í… ë°©ì§€ë¥¼ ìœ„í•œ ê°•ë ¥í•œ ìŠ¤ë¬´ë”© ë¡œì§ ---
function animate() {
    if ((!watching && !userPos) || (!userPos)) { 
        isAnimating = false; 
        return; 
    }
    
    let needsRedraw = false;

    // 1. ê°ë„ ìŠ¤ë¬´ë”© (ë°±ìŠ¤í… ë°©ì§€)
    let delta = targetHeading - currentHeading;
    // 360ë„ ê²½ê³„ ì²˜ë¦¬ (ì˜ˆ: 350ë„ -> 10ë„ë¡œ ê°ˆ ë•Œ ë’¤ë¡œ ëŒì§€ ì•Šê²Œ)
    while (delta < -180) delta += 360;
    while (delta > 180) delta -= 360;

    // ë–¨ë¦¼ ë°©ì§€: 1ë„ ë¯¸ë§Œ ë³€í™”ëŠ” ë¬´ì‹œ (Deadzone)
    if (Math.abs(delta) > 1.0) {
        // ë³´ê°„ ê³„ìˆ˜ 0.05: ì•„ì£¼ ë¶€ë“œëŸ½ê³  ë¬µì§í•˜ê²Œ íšŒì „ (ê¸°ì¡´ 0.1ë³´ë‹¤ ëŠë¦¼)
        currentHeading += delta * 0.05; 
        needsRedraw = true;
    }

    // 2. ìœ„ì¹˜ ìŠ¤ë¬´ë”© (ì í”„ ë°©ì§€)
    if (displayedPos) {
        const dLat = userPos.lat - displayedPos.lat;
        const dLon = userPos.lon - displayedPos.lon;
        // ìœ„ì¹˜ê°€ ë„ˆë¬´ ë©€ë©´(ì´ˆê¸°í™” ë“±) ë°”ë¡œ ì´ë™, ì•„ë‹ˆë©´ ë¶€ë“œëŸ½ê²Œ ì´ë™
        if (Math.abs(dLat) > 0.0005 || Math.abs(dLon) > 0.0005) {
            displayedPos = { ...userPos };
            needsRedraw = true;
        } else if (Math.abs(dLat) > 0.000001 || Math.abs(dLon) > 0.000001) {
            displayedPos.lat += dLat * 0.1;
            displayedPos.lon += dLon * 0.1;
            needsRedraw = true;
        }
    } else {
        displayedPos = { ...userPos };
        needsRedraw = true;
    }

    if (needsRedraw) {
        draw(); 
        requestAnimationFrame(animate);
    } else {
        isAnimating = false; 
    }
}

function findRoute() {
    if(watching) stopNav();
    const start = document.getElementById('start').value;
    const end = document.getElementById('end').value;
    
    if (start === end) { updateStatus("err", "ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ê°™ìŠµë‹ˆë‹¤!"); return; }

    route = dijkstra(start, end);
    if (!route) {
        updateStatus("err", "ê²½ë¡œ ì—†ìŒ");
        return;
    }
    
    route.currentStep = 0;
    document.getElementById('info').innerHTML = 
        `<strong>ì´ ê±°ë¦¬: ${route.dist.toFixed(0)}m (ì‹¤ë‚´ í…ŒìŠ¤íŠ¸ìš©)</strong>`;

    document.getElementById('nav-btn').disabled = false;
    document.getElementById('nav-btn').textContent = "ë‚´ë¹„ ì‹œì‘";
    document.getElementById('nav-bar').classList.add('active');
    
    updateNavUI(route.steps[0].instruction, route.dist);
    draw();
}

function toggleNav() {
    if (!route) return;
    if (document.getElementById('nav-btn').textContent === "ì¬ì„¤ì •") { resetApp(); return; }
    if (watching) stopNav(); else startNav();
}

function startNav() {
    if (!navigator.geolocation) { updateStatus("err", "GPS ë¯¸ì§€ì›"); return; }
    
    watching = true;
    document.getElementById('nav-btn').textContent = "ì •ì§€";
    document.getElementById('nav-btn').className = "bg-red-500 text-white font-black text-2xl px-16 py-7 rounded-full shadow-2xl hover:scale-110 transition";
    
    // ë°©í–¥ ì„¼ì„œ
    if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission().then(r => {
            if (r === 'granted') window.addEventListener('deviceorientation', oriHandler);
        });
    } else {
        window.addEventListener('deviceorientation', oriHandler);
    }

    // ì´ˆê¸° ìœ„ì¹˜ ì¡ê¸°
    navigator.geolocation.getCurrentPosition(pos => {
        const startArea = AREAS[route.path[0]];
        offset.lat = pos.coords.latitude - startArea.lat;
        offset.lon = pos.coords.longitude - startArea.lon;
        updateStatus("ok", "ê¸°ì¤€ì  ì„¤ì • ì™„ë£Œ! ì´ë™í•˜ì„¸ìš”.");
    }, onError, { enableHighAccuracy: true });

    watchId = navigator.geolocation.watchPosition(onLocation, onError, {
        enableHighAccuracy: true, maximumAge: 0, timeout: 5000
    });
}

function stopNav() {
    watching = false;
    if (watchId) navigator.geolocation.clearWatch(watchId);
    window.removeEventListener('deviceorientation', oriHandler);
    document.getElementById('nav-btn').textContent = "ì¬ê°œ";
    document.getElementById('nav-btn').className = "bg-yellow-500 text-black font-black text-2xl px-16 py-7 rounded-full shadow-2xl hover:scale-110 transition";
}

function onLocation(pos) {
    if (!watching || !route) return;

    userPos = {
        lat: pos.coords.latitude - offset.lat,
        lon: pos.coords.longitude - offset.lon
    };

    if (!isAnimating) { isAnimating = true; requestAnimationFrame(animate); }

    const step = route.steps[route.currentStep];
    const target = AREAS[step.to];
    // ì‹¤ë‚´ í…ŒìŠ¤íŠ¸ì´ë¯€ë¡œ ë„ì°© íŒì • ê±°ë¦¬ë¥¼ 3më¡œ ì¶•ì†Œ
    const distToNextNode = haversine(userPos.lat, userPos.lon, target.lat, target.lon); 
    
    let totalRemaining = distToNextNode;
    for (let i = route.currentStep + 1; i < route.steps.length; i++) totalRemaining += route.steps[i].dist;

    updateNavUI(step.instruction, totalRemaining);
    updateStatus("ok", `GPS ìˆ˜ì‹ ì¤‘ (ì •í™•ë„: ${pos.coords.accuracy.toFixed(0)}m)`);
    
    // [ìˆ˜ì •] ë„ì°© íŒì • ë²”ìœ„ 3m ì´ë‚´
    if (distToNextNode < 3) { 
        route.currentStep++;
        if (route.currentStep >= route.steps.length) arrive();
    }
}

function oriHandler(e) {
    // alpha ê°’ì´ íŠ€ëŠ” í˜„ìƒ ë°©ì§€
    if (e.alpha !== null) {
        // ì–´ë–¤ ê¸°ê¸°ëŠ” alphaê°€ 0~360, ì–´ë–¤ ê¸°ê¸°ëŠ” -180~180ì¼ ìˆ˜ ìˆìŒ. ì •ê·œí™”.
        let h = e.alpha;
        if (h < 0) h += 360;
        targetHeading = h; 
        
        if (!isAnimating) {
            isAnimating = true;
            requestAnimationFrame(animate);
        }
    }
}

function onError(e) { if (watching) updateStatus("err", "GPS ì˜¤ë¥˜: " + e.message); }

function arrive() {
    stopNav();
    document.getElementById('instruction').textContent = "ë„ì°©í–ˆìŠµë‹ˆë‹¤! ğŸ‰";
    document.getElementById('distance').textContent = "ì•ˆë‚´ ì¢…ë£Œ";
    document.getElementById('icon').innerHTML = `<i data-lucide="map-pin" class="w-10 h-10 text-green-400"></i>`;
    lucide.createIcons();
    document.getElementById('nav-btn').textContent = "ì¬ì„¤ì •";
    document.getElementById('nav-btn').className = "bg-blue-600 text-white font-black text-2xl px-16 py-7 rounded-full";
}

function resetApp() {
    stopNav();
    route = null; userPos = null; displayedPos = null; currentHeading = 0;
    document.getElementById('nav-bar').classList.remove('active');
    document.getElementById('nav-btn').disabled = true;
    document.getElementById('nav-btn').textContent = "ë‚´ë¹„ ì‹œì‘";
    draw();
}

function updateNavUI(instruction, totalRemainingDist) {
    document.getElementById('instruction').textContent = instruction;
    document.getElementById('distance').textContent = `ë‚¨ì€ ê±°ë¦¬: ${totalRemainingDist.toFixed(1)}m`;
    if (route && route.currentStep < route.steps.length) {
        const step = route.steps[route.currentStep];
        document.getElementById('icon').innerHTML = `<i data-lucide="${step.icon}" class="w-10 h-10"></i>`;
        lucide.createIcons();
    }
}

function dijkstra(start, end) {
    const graph = {};
    ALL_EDGES.forEach(e => {
        graph[e.from] = graph[e.from] || [];
        graph[e.from].push(e);
    });
    const dist = {}, prev = {}, q = new Set(Object.keys(AREAS));
    Object.keys(AREAS).forEach(k => dist[k] = Infinity);
    dist[start] = 0;
    while (q.size) {
        let min = null;
        q.forEach(n => { if (dist[n] < dist[min] || min === null) min = n; });
        if (min === end || dist[min] === Infinity) break;
        q.delete(min);
        graph[min] && graph[min].forEach(edge => {
            const alt = dist[min] + edge.dist;
            if (alt < dist[edge.to]) { dist[edge.to] = alt; prev[edge.to] = { node: min, edge: edge }; }
        });
    }
    if (dist[end] === Infinity) return null;
    const pathNodes = []; const steps = [];
    let u = end;
    while (u) { pathNodes.unshift(u); u = prev[u] ? prev[u].node : null; }
    for (let i = 0; i < pathNodes.length - 1; i++) {
        const from = pathNodes[i], to = pathNodes[i+1];
        if (prev[to] && prev[to].node === from) steps.push(prev[to].edge);
    }
    if (steps.length > 0) steps[steps.length - 1].instruction = `${AREAS[end].name} ë„ì°©`;
    return {path: pathNodes, steps, dist: dist[end], currentStep: 0};
}

function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = x => x * Math.PI / 180;
    const dlat = toRad(lat2-lat1), dlon = toRad(lon2-lon1);
    const a = Math.sin(dlat/2)**2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dlon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function updateStatus(type, msg) {
    const el = document.getElementById('status');
    el.textContent = msg;
    el.className = "p-3 rounded-lg text-sm font-medium mb-4 " + (type==="ok"?"text-green-400 bg-green-900/30":"text-red-400 bg-red-900/30");
}

function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "#000000";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    let minLat = Infinity, maxLat = -Infinity, minLon = Infinity, maxLon = -Infinity;
    Object.values(AREAS).forEach(a => {
        minLat = Math.min(minLat, a.lat); maxLat = Math.max(maxLat, a.lat);
        minLon = Math.min(minLon, a.lon); maxLon = Math.max(maxLon, a.lon);
    });
    // ì—¬ë°±ì„ ë„‰ë„‰í•˜ê²Œ (2ë°°)
    const latRange = (maxLat - minLat) * 2 || 0.0001; 
    const lonRange = (maxLon - minLon) * 2 || 0.0001;
    const ratio = Math.min(canvas.width / lonRange, canvas.height / latRange) * 0.6;

    const latLonToCanvas = (lat, lon) => {
        const cx = (minLon + maxLon) / 2, cy = (minLat + maxLat) / 2;
        let x = (lon - cx) * ratio + canvas.width / 2;
        let y = (lat - cy) * ratio * -1 + canvas.height / 2;
        return {
            x: canvas.width / 2 + (x - canvas.width / 2) * scale + tx,
            y: canvas.height / 2 + (y - canvas.height / 2) * scale + ty
        };
    };

    // ë§µ ê²½ë¡œ
    ctx.strokeStyle = "#333333";
    ctx.lineWidth = 4 * scale;
    EDGES_DATA.forEach(e => {
        const p1 = latLonToCanvas(AREAS[e.u].lat, AREAS[e.u].lon);
        const p2 = latLonToCanvas(AREAS[e.v].lat, AREAS[e.v].lon);
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
    });

    if (route) {
        ctx.strokeStyle = "#3b82f6"; // Blue-500
        ctx.lineWidth = 8 * scale;
        ctx.lineCap = 'round';
        ctx.beginPath();
        route.path.forEach((id, i) => {
            const p = latLonToCanvas(AREAS[id].lat, AREAS[id].lon);
            i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y);
        });
        ctx.stroke();
    }

    Object.entries(AREAS).forEach(([id, a]) => {
        const {x, y} = latLonToCanvas(a.lat, a.lon);
        const isCurrent = route && route.path.includes(id);
        ctx.fillStyle = isCurrent ? "#10b981" : "#1e3a8a";
        ctx.beginPath(); ctx.arc(x, y, 12 * scale, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "white"; ctx.font = `bold ${14 * scale}px sans-serif`;
        ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.fillText(id, x, y);
    });

    // --- ì‚¬ìš©ì í™”ì‚´í‘œ (displayedPos ì‚¬ìš©) ---
    if (displayedPos) {
        const {x, y} = latLonToCanvas(displayedPos.lat, displayedPos.lon);
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(currentHeading * Math.PI / 180);

        // ì‹œì•¼ê°
        const fovRadius = 100 * scale; 
        const gradient = ctx.createRadialGradient(0, 0, 5 * scale, 0, 0, fovRadius);
        gradient.addColorStop(0, "rgba(255, 255, 0, 0.3)"); 
        gradient.addColorStop(1, "rgba(255, 255, 0, 0)");
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.arc(0, 0, fovRadius, -Math.PI/2 - 0.6, -Math.PI/2 + 0.6);
        ctx.fill();

        // í™”ì‚´í‘œ
        ctx.fillStyle = "#facc15"; 
        ctx.beginPath();
        ctx.moveTo(0, -20 * scale);
        ctx.lineTo(-11 * scale, 11 * scale);
        ctx.lineTo(0, 7 * scale); 
        ctx.lineTo(11 * scale, 11 * scale);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
}

function setupCanvasEvents() {
    let dragging = false, lastX, lastY, initialScale = 1;
    let st = [], touchDist = 0;

    canvas.addEventListener('wheel', e => {
        e.preventDefault();
        scale = Math.max(0.5, Math.min(5, scale * (e.deltaY < 0 ? 1.1 : 0.9)));
        draw();
    }, { passive: false });

    canvas.addEventListener('mousedown', e => { dragging = true; lastX = e.clientX; lastY = e.clientY; });
    canvas.addEventListener('mousemove', e => {
        if (dragging) { tx += e.clientX - lastX; ty += e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; draw(); }
    });
    canvas.addEventListener('mouseup', () => dragging = false);
    canvas.addEventListener('touchstart', e => { 
        e.preventDefault(); 
        st = Array.from(e.touches);
        if (st.length === 1) { dragging = true; lastX = st[0].clientX; lastY = st[0].clientY; }
        else if (st.length === 2) { initialScale = scale; touchDist = Math.hypot(st[0].clientX - st[1].clientX, st[0].clientY - st[1].clientY); dragging = false; }
    }, { passive: false });
    canvas.addEventListener('touchmove', e => {
        e.preventDefault(); 
        const t = Array.from(e.touches);
        if (t.length === 1 && dragging) { tx += t[0].clientX - lastX; ty += t[0].clientY - lastY; lastX = t[0].clientX; lastY = t[0].clientY; }
        else if (t.length === 2 && st.length === 2) {
            const newDist = Math.hypot(t[0].clientX - t[1].clientX, t[0].clientY - t[1].clientY);
            if (touchDist > 0) scale = Math.max(0.5, Math.min(5, initialScale * (newDist / touchDist)));
        }
        draw();
    }, { passive: false });
    canvas.addEventListener('touchend', () => { dragging = false; st = []; });
}
</script>
</body>
</html>