<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>Map Preview Nav</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
    body { background: #000; color: white; margin:0; overflow: hidden; touch-action: none; font-family: -apple-system, sans-serif; }
    
    #map-canvas { width:100%; height:70vh; background:#111; border-radius:0 0 30px 30px; }
    
    .overlay { position: absolute; top: 20px; left:0; right:0; text-align: center; z-index: 10; pointer-events: none; }
    
    .bottom-panel { 
        position: absolute; bottom: 0; left:0; right:0; height: 30vh; 
        background: #000; padding: 15px; display: flex; flex-direction: column; 
        border-top: 1px solid #333; z-index: 20;
    }
    
    .btn-start { 
        background: #3b82f6; color: white; border:none; padding: 12px; 
        font-size: 1.1rem; font-weight: 800; border-radius: 12px; width: 100%; 
        box-shadow: 0 4px 15px rgba(59, 130, 246, 0.4); margin-top: auto; 
        transition: all 0.2s;
    }
    .btn-start.active { background: #ef4444; box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4); }

    .calib-row { display: flex; gap: 8px; margin-bottom: 8px; }
    .calib-btn {
        flex: 1; padding: 10px; border-radius: 8px; border: 1px solid #444;
        background: #222; color: #ccc; font-size: 0.75rem; font-weight: bold;
    }
    .calib-btn.active { background: #059669; color: white; border-color: #059669; }

    .step-badge {
        position: absolute; top: 20px; right: 20px;
        background: rgba(30, 41, 59, 0.8); border: 1px solid #334155;
        padding: 6px 12px; border-radius: 99px; font-size: 0.8rem; font-weight: bold; color: #94a3b8;
    }
    </style>
</head>
<body>

<div class="step-badge">ğŸ‘£ <span id="step-count">0</span></div>

<div class="overlay">
    <div id="instr" class="text-3xl font-black text-cyan-400 drop-shadow-md">ê²½ë¡œ ë¯¸ë¦¬ë³´ê¸°</div>
    <div id="dist" class="text-xl text-gray-400 mt-1 font-mono"></div>
</div>

<canvas id="map-canvas"></canvas>

<div class="bottom-panel">
    <div class="calib-row">
        <button id="btn-rot" class="calib-btn">ğŸ”„ ì§€ë„ íšŒì „ ë°˜ì „</button>
        <button id="btn-move" class="calib-btn">â¬†ï¸ ì´ë™ ë°©í–¥ ë°˜ì „</button>
    </div>

    <div class="flex gap-2 mb-2">
        <select id="start" onchange="updatePreview()" class="bg-gray-800 text-white p-2 rounded-lg flex-1 font-bold border border-gray-700 text-sm"></select>
        <select id="end" onchange="updatePreview()" class="bg-gray-800 text-white p-2 rounded-lg flex-1 font-bold border border-gray-700 text-sm"></select>
    </div>
    
    <div class="text-center text-gray-500 text-[10px] mb-1">
        ë‚´ë¹„ ì‹œì‘ ì „ì—ëŠ” <b>ë¶ìª½ ê³ ì •</b> í”„ë¦¬ë·° ëª¨ë“œì…ë‹ˆë‹¤.
    </div>

    <button id="btn" class="btn-start">ë‚´ë¹„ ì‹œì‘</button>
</div>

<script>
// --- ì„¤ì • ---
const STEP_LENGTH = 0.000020; 
const GAP = 0.00008; 
const BASE_LAT = 37.0; const BASE_LON = 127.0;

const AREAS = {
    A: {name:"A êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON},
    B: {name:"B êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP},
    C: {name:"C êµ¬ì—­", lat:BASE_LAT, lon:BASE_LON + GAP*2},
    D: {name:"D êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON},
    E: {name:"E êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP},
    F: {name:"F êµ¬ì—­", lat:BASE_LAT - GAP, lon:BASE_LON + GAP*2},
    G: {name:"G êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON},
    H: {name:"H êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP},
    I: {name:"I êµ¬ì—­", lat:BASE_LAT - GAP*2, lon:BASE_LON + GAP*2}
};

const EDGES = [
    ['A','B'], ['B','C'], ['D','E'], ['E','F'], ['G','H'], ['H','I'],
    ['A','D'], ['D','G'], ['B','E'], ['E','H'], ['C','F'], ['F','I']
];

// --- ë³€ìˆ˜ ---
let userPos = null; 
let heading = 0;    
let currentStepCount = 0;
let isNavigating = false; // í˜„ì¬ ë‚´ë¹„ ì¤‘ì¸ì§€ ì—¬ë¶€
let path = []; 
let canvas, ctx;
let rotDir = -1;  
let moveDir = 1;  
let lastStepTime = 0;

// í”„ë¦¬ë·°ìš© ì¹´ë©”ë¼ ìœ„ì¹˜
let cameraCenter = { lat: BASE_LAT, lon: BASE_LON };

window.onload = () => {
    canvas = document.getElementById('map-canvas');
    ctx = canvas.getContext('2d');
    
    const s = document.getElementById('start');
    const e = document.getElementById('end');
    Object.keys(AREAS).forEach(k => {
        const opt = `<option value="${k}">[${k}] ${AREAS[k].name}</option>`;
        s.innerHTML += opt; e.innerHTML += opt;
    });
    s.value = "A"; e.value = "I";

    document.getElementById('btn').onclick = toggleNav;
    
    const btnRot = document.getElementById('btn-rot');
    const btnMove = document.getElementById('btn-move');
    btnRot.onclick = () => { rotDir *= -1; btnRot.classList.toggle('active'); };
    btnMove.onclick = () => { moveDir *= -1; btnMove.classList.toggle('active'); };

    window.addEventListener('resize', resize);
    resize();
    
    // [í•µì‹¬] ë¡œë”© ì‹œ ë°”ë¡œ í”„ë¦¬ë·° ì‹¤í–‰
    updatePreview(); 
    animate();
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight * 0.70;
}

// [ê¸°ëŠ¥ ì¶”ê°€] ê²½ë¡œ ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸ í•¨ìˆ˜
function updatePreview() {
    const startNode = document.getElementById('start').value;
    const endNode = document.getElementById('end').value;
    
    // ê²½ë¡œ ê³„ì‚°
    path = findShortestPath(startNode, endNode);
    
    // ìœ ì € ìœ„ì¹˜ë¥¼ ì¶œë°œì§€ë¡œ ì„¤ì • (ì„¼ì„œ ì‘ë™ì€ ì•ˆí•¨)
    userPos = {...AREAS[startNode]}; 
    
    if (path) {
        // í”„ë¦¬ë·° ì¹´ë©”ë¼ ìœ„ì¹˜: ì¶œë°œì§€ì™€ ë„ì°©ì§€ì˜ ì¤‘ê°„ ì§€ì 
        const sP = AREAS[startNode];
        const eP = AREAS[endNode];
        cameraCenter = {
            lat: (sP.lat + eP.lat) / 2,
            lon: (sP.lon + eP.lon) / 2
        };
        
        if(!isNavigating) {
            document.getElementById('instr').innerText = "ê²½ë¡œ ë¯¸ë¦¬ë³´ê¸°";
            const dist = getDist(sP, eP); // ì§ì„ ê±°ë¦¬ ëŒ€ëµ í‘œì‹œ
            document.getElementById('dist').innerText = `ì˜ˆìƒ ê±°ë¦¬ ì•½ ${dist.toFixed(0)}m`;
        }
    }
}

function toggleNav() {
    if (isNavigating) {
        // ë‚´ë¹„ ì¢…ë£Œ -> í”„ë¦¬ë·° ëª¨ë“œë¡œ ë³µê·€
        isNavigating = false;
        document.getElementById('btn').innerText = "ë‚´ë¹„ ì‹œì‘";
        document.getElementById('btn').classList.remove('active');
        document.getElementById('instr').innerText = "ì•ˆë‚´ ì¢…ë£Œ";
        location.reload(); // ê¹”ë”í•˜ê²Œ ë¦¬ì…‹
    } else {
        // ë‚´ë¹„ ì‹œì‘
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission().then(res => { if (res === 'granted') initSensors(); });
        } else {
            initSensors();
        }
        
        isNavigating = true;
        currentStepCount = 0;
        document.getElementById('btn').innerText = "ì•ˆë‚´ ì¢…ë£Œ";
        document.getElementById('btn').classList.add('active');
        updateStatus(); // ì•ˆë‚´ ë¬¸êµ¬ ê°±ì‹ 
    }
}

function initSensors() {
    window.addEventListener('deviceorientation', e => {
        if(e.webkitCompassHeading) heading = e.webkitCompassHeading;
        else if(e.alpha) heading = 360 - e.alpha;
    });

    window.addEventListener('devicemotion', e => {
        if(!isNavigating) return; // ë‚´ë¹„ ì¤‘ì¼ ë•Œë§Œ ê±¸ìŒ ê°ì§€
        const acc = e.accelerationIncludingGravity;
        if(!acc) return;
        const total = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
        if (total > 12.5) { 
            const now = Date.now();
            if (now - lastStepTime > 450) { 
                takeStep(); lastStepTime = now;
            }
        }
    });
}

function takeStep() {
    currentStepCount++;
    document.getElementById('step-count').innerText = currentStepCount;
    const rad = (heading * Math.PI) / 180;
    userPos.lat += moveDir * Math.cos(rad) * STEP_LENGTH; 
    userPos.lon += moveDir * Math.sin(rad) * STEP_LENGTH;
    updateStatus();
}

function updateStatus() {
    if(!path || path.length === 0) return;
    let minDist = Infinity; let nearestIdx = -1;
    path.forEach((node, i) => {
        const d = getDist(userPos, AREAS[node]);
        if(d < minDist) { minDist = d; nearestIdx = i; }
    });
    const endNode = AREAS[path[path.length-1]];
    const distToEnd = getDist(userPos, endNode);
    if (distToEnd < 5) {
        document.getElementById('instr').innerText = "ë„ì°© ì™„ë£Œ!";
        document.getElementById('dist').innerText = "";
        isNavigating = false;
        document.getElementById('btn').innerText = "ë‚´ë¹„ ì‹œì‘";
        document.getElementById('btn').classList.remove('active');
        return;
    }
    let targetIdx = nearestIdx + 1;
    if (targetIdx >= path.length) targetIdx = path.length - 1;
    document.getElementById('instr').innerText = `${AREAS[path[targetIdx]].name} ë°©í–¥`;
    document.getElementById('dist').innerText = `ë‚¨ì€ ê±°ë¦¬ ${distToEnd.toFixed(0)}m`;
}

function findShortestPath(start, end) {
    const adj = {};
    EDGES.forEach(([u, v]) => {
        if(!adj[u]) adj[u] = []; if(!adj[v]) adj[v] = [];
        adj[u].push(v); adj[v].push(u);
    });
    let queue = [[start]]; let visited = new Set([start]);
    while(queue.length > 0) {
        let path = queue.shift();
        if(path[path.length-1] === end) return path;
        let node = path[path.length-1];
        if(adj[node]) {
            for(let neighbor of adj[node]) {
                if(!visited.has(neighbor)) {
                    visited.add(neighbor); queue.push([...path, neighbor]);
                }
            }
        }
    }
    return null;
}

function getDist(p1, p2) {
    const dLat = p1.lat - p2.lat; const dLon = p1.lon - p2.lon;
    return Math.sqrt(dLat*dLat + dLon*dLon) / 0.000009; 
}

function animate() {
    ctx.fillStyle = "#000"; ctx.fillRect(0,0,canvas.width, canvas.height);
    
    // userPosê°€ ì—†ìœ¼ë©´(ë¡œë”© ì „) ë¬´ì‹œ, í•˜ì§€ë§Œ updatePreviewì—ì„œ ë°”ë¡œ ì´ˆê¸°í™”ë¨
    if(!userPos) { requestAnimationFrame(animate); return; }

    const SCALE = 2200000; 
    const cx = canvas.width/2; 
    const cy = canvas.height * 0.55; 

    // [í•µì‹¬] ì¹´ë©”ë¼ ë·° ì„¤ì •
    // ë‚´ë¹„ ì¤‘ì¼ ë•Œ: ë‚´ ìœ„ì¹˜(userPos) ì¤‘ì‹¬ + íšŒì „(heading) ì ìš©
    // í”„ë¦¬ë·° ì¼ ë•Œ: ê²½ë¡œ ì¤‘ê°„(cameraCenter) ì¤‘ì‹¬ + íšŒì „ ì—†ìŒ(0)
    const centerPos = isNavigating ? userPos : cameraCenter;
    const currentRot = isNavigating ? (rotDir * heading) : 0; 

    const toScreen = (lat, lon) => {
        let dy = (lat - centerPos.lat) * SCALE; 
        let dx = (lon - centerPos.lon) * SCALE; 
        
        const rad = currentRot * Math.PI / 180;
        
        const rx = dx * Math.cos(rad) - dy * Math.sin(rad);
        const ry = dx * Math.sin(rad) + dy * Math.cos(rad);
        return {x: cx + rx, y: cy - ry}; 
    };

    // ê²©ì ê·¸ë¦¬ê¸°
    ctx.strokeStyle = "#333"; ctx.lineWidth = 4; ctx.beginPath();
    EDGES.forEach(([u, v]) => {
        const p1 = toScreen(AREAS[u].lat, AREAS[u].lon);
        const p2 = toScreen(AREAS[v].lat, AREAS[v].lon);
        ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
    });
    ctx.stroke();

    // ê²½ë¡œ ê·¸ë¦¬ê¸°
    if (path && path.length > 0) {
        ctx.strokeStyle = "rgba(0, 255, 255, 0.5)"; ctx.lineWidth = 25; ctx.beginPath();
        for(let i=0; i<path.length-1; i++) {
            const p1 = toScreen(AREAS[path[i]].lat, AREAS[path[i]].lon);
            const p2 = toScreen(AREAS[path[i+1]].lat, AREAS[path[i+1]].lon);
            ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    // ë…¸ë“œ ê·¸ë¦¬ê¸°
    Object.keys(AREAS).forEach(k => {
        const p = toScreen(AREAS[k].lat, AREAS[k].lon);
        const isDest = (path && path[path.length-1] === k);
        const isStart = (path && path[0] === k);
        
        ctx.fillStyle = isDest ? "#ef4444" : (isStart ? "#10b981" : "#1e293b");
        ctx.beginPath(); ctx.arc(p.x, p.y, (isDest||isStart)?12:8, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = (isDest||isStart) ? "#fff" : "#64748b";
        ctx.font = (isDest||isStart) ? "bold 16px sans-serif" : "12px sans-serif";
        ctx.textAlign="center"; ctx.fillText(AREAS[k].name, p.x, p.y-20);
    });

    // ë‚´ í™”ì‚´í‘œ (ë‚´ë¹„ ì¤‘ì—ë§Œ í‘œì‹œ, í”„ë¦¬ë·° ë•ŒëŠ” ì¶œë°œì§€ì— ì‘ì€ ì ë§Œ)
    if(isNavigating) {
        ctx.save(); ctx.translate(cx, cy);
        const grad = ctx.createRadialGradient(0,0, 10, 0,0, 120);
        grad.addColorStop(0, "rgba(255, 220, 0, 0.3)"); grad.addColorStop(1, "rgba(255, 220, 0, 0)");
        ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(0,0);
        ctx.arc(0, 0, 120, -Math.PI/2 - 0.5, -Math.PI/2 + 0.5); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowBlur = 10; ctx.shadowColor="white";
        ctx.beginPath(); ctx.moveTo(0,-18); ctx.lineTo(-12,12); ctx.lineTo(0,8); ctx.lineTo(12,12); ctx.fill();
        ctx.restore();
    } else {
        // í”„ë¦¬ë·° ëª¨ë“œì¼ ë•Œ í˜„ì¬ ë‚´ ìœ„ì¹˜(ì¶œë°œì§€) í‘œì‹œ
        const p = toScreen(userPos.lat, userPos.lon);
        ctx.fillStyle = "#00ffff"; 
        ctx.beginPath(); ctx.arc(p.x, p.y, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "cyan"; ctx.font="12px sans-serif"; ctx.fillText("ì¶œë°œ", p.x, p.y+20);
    }

    requestAnimationFrame(animate);
}
</script>
</body>
</html>