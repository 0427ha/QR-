<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>✈️ 공항 실내 GPS (반응형)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 1200px; } /* PC 화면에서 더 넓게 보이도록 최대 너비 확장 */
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        #route-map { 
            width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:400px; /* PC에서 최소 높이 상향 */
            touch-action: none; 
        }
        /* 모바일 대응: 하단 내비게이션 바 */
        #navigation-bar { 
            position: fixed; bottom:0; left:0; right:0; z-index: 50; background:#1e3a8a; color:white; 
            box-shadow: 0 -4px 12px rgba(0,0,0,0.2); border-top-left-radius:1rem; border-top-right-radius:1rem; 
            transform: translateY(100%); transition: transform .3s ease-in-out; 
            padding: 1rem 1.5rem;
        }
        #navigation-bar.active { transform: translateY(0); }
        #nav-next-instruction { 
            font-size: 1.125rem;
            font-weight: 800;
        }
        /* 모바일 대응: 본문 콘텐츠가 하단 바에 가려지지 않도록 하단 패딩 확보 */
        .pb-40-mobile { padding-bottom: 12rem; }
        /* PC 대응: 하단 바가 사라질 때 패딩을 줄임 (sm:viewport 이상) */
        @media (min-width: 640px) {
            .pb-40-mobile { padding-bottom: 2rem; }
            #navigation-bar { 
                display: none; /* PC 화면에서는 하단 바 숨김 */
            }
        }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40-mobile">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">✈️ 공항 실내 GPS (반응형 모드)</h1>

                <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                준비: 경로를 설정하고 '준비' 버튼을 누르세요.
            </div>
            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 설정</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">출발 구역</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">도착 구역</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md flex-shrink-0">
                    경로 검색 및 내비게이션 준비
                </button>
            </div>
        </div>

                <div class="grid grid-cols-1 sm:grid-cols-3 gap-6">
                        <div class="sm:col-span-2 card p-6 rounded-xl">
                <div class="flex items-center justify-between mb-4">
                    <h2 class="text-xl font-bold text-gray-700">경로 지도 시각화 (줌/팬 가능)</h2>
                                        <button id="nav-control-button-pc" onclick="toggleNavigation()" class="hidden sm:inline-block px-4 py-1.5 bg-green-500 text-white text-sm font-bold rounded-lg shadow-md" disabled>
                        GPS 내비 시작
                    </button>
                </div>
                <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>
                                <div id="route-guidance-output" class="sm:hidden">
                    <p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>
                </div>
            </div>

                        <div class="sm:col-span-1">
                                <div id="route-guidance-summary-pc" class="card p-6 rounded-xl mb-6 hidden sm:block">
                    <h3 class="text-lg font-bold mb-3 text-gray-700">다음 안내</h3>
                    <div class="flex items-center space-x-3">
                        <div id="current-turn-icon-pc" class="text-3xl flex-shrink-0 text-blue-600">
                            <i data-lucide="compass" class="w-7 h-7"></i>
                        </div>
                        <div class="flex flex-col min-w-0">
                            <p id="nav-next-instruction-pc" class="font-bold leading-snug truncate text-gray-800">대기 중</p>
                            <p id="nav-step-info-pc" class="text-sm text-gray-500 mt-0.5">-</p>
                        </div>
                    </div>
                </div>

                                <div id="steps-list-container" class="card p-6 rounded-xl">
                    <div id="steps-list" class="mt-8">
                        <h3 class="text-lg font-bold mb-3 text-gray-700">전체 경로</h3>
                        <p class="text-gray-500">경로를 검색하면 여기에 안내 단계가 표시됩니다.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

        <div id="navigation-bar" class="p-4 flex items-center justify-between sm:hidden">
        <div class="flex items-center space-x-3 min-w-0">
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="font-extrabold leading-snug truncate">대기 중</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5">-</p>
            </div>
        </div>
                <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white text-sm font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>GPS 내비 시작</button>
    </div>

    <script>
    // --- 데이터 정의 (변동 없음) ---
    const AREA_NAMES = {
        'A': 'A. 국제선 도착 게이트 (1층)', 'B': 'B. 면세품 수령 데스크 (1층)', 'C': 'C. 환전소/여행자 보험 (1층)',
        'D': 'D. 국내선 체크인 카운터 (2층)', 'E': 'E. 출국 심사대 입구 (2층)', 'F': 'F. 푸드코트 (2층)',
        'G': 'G. 라운지 입구 (3층 프리미엄)', 'H': 'H. 면세점 중앙 구역 (3층)', 'I': 'I. 탑승 게이트 (3층 장거리)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 }, 'B': { lat: 37.510000, lon: 127.051800 }, 'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 }, 'E': { lat: 37.508500, lon: 127.051800 }, 'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 }, 'H': { lat: 37.507000, lon: 127.051800 }, 'I': { lat: 37.507000, lon: 127.053600 }
    };
    let ORIGINAL_AREA_COORDINATES = JSON.parse(JSON.stringify(AREA_COORDINATES));

    const CONNECTIONS_DATA = [
        { u:'A', v:'B', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세품 수령 데스크 방향으로 직진" }, 
        { u:'B', v:'C', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 환전소/여행자 보험 방향으로 직진" },
        { u:'D', v:'E', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 출국 심사대 입구 방향으로 직진" }, 
        { u:'E', v:'F', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 푸드코트 방향으로 직진" },
        { u:'G', v:'H', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세점 중앙 구역 방향으로 직진" }, 
        { u:'H', v:'I', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 탑승 게이트 방향으로 직진" },
        { u:'A', v:'D', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 국내선 체크인 카운터 방향으로 이동" }, 
        { u:'B', v:'E', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 출국 심사대 입구 방향으로 이동" },
        { u:'C', v:'F', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 푸드코트 방향으로 이동" }, 
        { u:'D', v:'G', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 라운지 입구 방향으로 이동" },
        { u:'E', v:'H', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 면세점 중앙 구역 방향으로 이동" }, 
        { u:'F', v:'I', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 탑승 게이트 방향으로 이동" },
        { u:'A', v:'E', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 출국 심사대 입구 방향으로 이동" }, 
        { u:'B', v:'D', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'F', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 푸드코트 방향으로 이동" }, 
        { u:'E', v:'C', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 환전소 방향으로 이동" }
    ];

    const ALL_CONNECTIONS = [];
    CONNECTIONS_DATA.forEach(conn => {
        ALL_CONNECTIONS.push(conn);
        const reverseTurn = (conn.turn === "우회전") ? "좌회전" : (conn.turn === "좌회전") ? "우회전" : "직진";
        let reverseInstruction = conn.instruction.replace('오른쪽', '왼쪽').replace('위층', '아래층');
        if (!CONNECTIONS_DATA.some(r => r.u === conn.v && r.v === conn.u)) {
            ALL_CONNECTIONS.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/방향으로 이동/g, '방향으로 돌아가기') });
        }
    });

    const TURN_ICONS = { '직진':'arrow-up', '우회전':'corner-down-right', '좌회전':'corner-down-left', '도착':'map-pin' };

    // --- 변수 및 상수 (변동 없음) ---
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let gpsWatchId = null;
    let userGpsPosition = null;
    let userGpsHeading = 0; 
    
    let mapScale = 1.0;
    let mapTranslateX = 0; let mapTranslateY = 0;
    let isDragging = false; let lastMouseX, lastMouseY; 

    const DISTANCE_THRESHOLD = 5; 
    
    // --- DOM 요소 ---
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button'); // 모바일
    const navControlButtonPC = document.getElementById('nav-control-button-pc'); // PC
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction'); // 모바일
    const navInstructionPC = document.getElementById('nav-next-instruction-pc'); // PC
    const navStepInfo = document.getElementById('nav-step-info'); // 모바일
    const navStepInfoPC = document.getElementById('nav-step-info-pc'); // PC
    const currentTurnIcon = document.getElementById('current-turn-icon'); // 모바일
    const currentTurnIconPC = document.getElementById('current-turn-icon-pc'); // PC

    // 맵 경계 (변동 없음)
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat); mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon); mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // -------------------------
    // 핵심 로직: 버튼 및 GPS 제어
    // -------------------------

    function updateGpsStatus(type, message) {
        gpsStatusMessage.textContent = message;
        gpsStatusMessage.classList.remove('gps-status-ok', 'gps-status-err');
        if (type === 'ok') {
            gpsStatusMessage.classList.add('gps-status-ok');
        } else if (type === 'error') {
            gpsStatusMessage.classList.add('gps-status-err');
        } else {
            gpsStatusMessage.classList.add('gps-status-err');
        }
    }


    function startRouteGuidance() {
        if (isNavigating) stopNavigation(); 
        
        const startId = startSelect.value;
        const endId = endSelect.value;
        if (startId === endId) { 
            outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg">출발지와 도착지가 같습니다.</div>`; 
            updateGpsStatus('error', "준비: 경로를 설정하고 '준비' 버튼을 누르세요.");
            return; 
        }

        searchButton.disabled = true; searchButton.innerText = '경로 계산 중...';
        const { steps, totalDist, totalTime, path } = calculatePath(startId, endId);
        
        if (!steps) { 
            outputDiv.innerHTML = `<div class="p-4 bg-red-100 text-red-700">경로 없음</div>`; 
            resetUI(); 
            updateGpsStatus('error', "준비: 경로를 설정하고 '준비' 버튼을 누르세요.");
            return; 
        }

        lastRouteData = { start: startId, end: endId, steps: steps, totalDist: totalDist, totalTime: totalTime, path: path };
        currentStepIndex = 0;

        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();

        navBar.classList.add('active'); // 모바일 하단 바 활성화
        
        // 내비게이션 준비 완료 시 초기 버튼 텍스트는 'GPS 내비 시작'
        updateControlButtons('GPS 내비 시작', 'bg-green-500', false);
        resetUI(); 
        
        updateGpsStatus("ok", "경로 설정 완료. 'GPS 내비 시작'을 누르세요.");
        
        userGpsPosition = null;
        drawMap();
    }

    function resetUI() {
        searchButton.disabled = false;
        searchButton.innerText = '경로 검색 및 내비게이션 준비';
    }

    // PC와 모바일 버튼 상태를 한 번에 업데이트하는 함수
    function updateControlButtons(text, bgColorClass, disabled) {
        // 모바일 버튼
        navControlButton.innerText = text;
        navControlButton.className = `px-5 py-2 ${bgColorClass} text-white text-sm font-bold rounded-full shadow-lg hover:${bgColorClass.replace('-500','-600')} transition duration-150 flex-shrink-0`;
        navControlButton.disabled = disabled;
        
        // PC 버튼
        navControlButtonPC.innerText = text;
        navControlButtonPC.className = `hidden sm:inline-block px-4 py-1.5 ${bgColorClass} text-white text-sm font-bold rounded-lg shadow-md hover:${bgColorClass.replace('-500','-600')}`;
        navControlButtonPC.disabled = disabled;
    }
    
    function updateInstructionDisplay(step, distText, isArrival = false) {
        const text = step ? step.instruction : (isArrival ? "목적지 도착!" : "대기 중");
        const info = step ? distText : (isArrival ? "안내 종료" : "-");
        const iconName = step ? (TURN_ICONS[step.turn] || 'arrow-up') : (isArrival ? 'map-pin' : 'compass');
        
        // 모바일 UI 업데이트
        navInstruction.textContent = text;
        navStepInfo.textContent = info;
        currentTurnIcon.innerHTML = `<i data-lucide="${iconName}" class="w-8 h-8"></i>`;

        // PC UI 업데이트
        if (navInstructionPC) navInstructionPC.textContent = text;
        if (navStepInfoPC) navStepInfoPC.textContent = info;
        if (currentTurnIconPC) currentTurnIconPC.innerHTML = `<i data-lucide="${iconName}" class="w-7 h-7"></i>`;

        lucide.createIcons();
    }


    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === '경로 재설정' || navControlButtonPC.innerText === '경로 재설정') { resetApp(); return; }

        // isNavigating 상태에 따라 토글 (핵심 로직 유지)
        if (isNavigating) {
            stopNavigation();
        } else {
            startNavigation();
        }
    }

    function startNavigation() {
        if (!navigator.geolocation) { alert("GPS를 지원하지 않습니다."); return; }
        
        // 1. 상태 및 UI를 즉시 '정지'로 강제 설정
        isNavigating = true;
        updateControlButtons('GPS 내비 정지', 'bg-yellow-500', false);
        updateGpsStatus("ok", "GPS 추적 시작. 위치 정보 수신 대기 중...");

        // 2. 방향 센서 시작 (기존 로직 유지)
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission().then(state => {
                if(state==='granted') window.addEventListener('deviceorientation', handleDeviceOrientation);
            }).catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleDeviceOrientation);
        }

        // 3. GPS 워처 시작 (기존 로직 유지)
        if (!gpsWatchId) { 
            gpsWatchId = navigator.geolocation.watchPosition(handleGpsSuccess, handleGpsError, {
                enableHighAccuracy: true, timeout: 5000, maximumAge: 0 
            });
        }
        
        // 4. 초기 오프셋 적용을 위한 위치 획득 (기존 로직 유지)
        navigator.geolocation.getCurrentPosition(
            (pos) => { 
                applyGpsOffsetToMap(pos.coords.latitude, pos.coords.longitude); 
                handleGpsSuccess(pos);
            },
            (err) => { 
                console.warn("초기 GPS 오프셋 위치 획득 실패. 워처로 계속 시도합니다.", err); 
            },
            { enableHighAccuracy: true, timeout: 3000 }
        );
    }

    function stopNavigation() {
        if (!isNavigating) return;
        
        // 비활성화 상태 설정 및 UI 즉시 업데이트
        isNavigating = false;
        
        updateControlButtons('GPS 내비 재개', 'bg-green-500', false);
        updateGpsStatus("error", "GPS 추적 일시 중지됨. 재개를 누르세요.");
        
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
    }

    // --- GPS 및 센서 핸들러 (핵심 로직 유지) ---
    function handleGpsSuccess(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        userGpsPosition = { lat: latitude, lon: longitude, acc: accuracy };
        
        let statusMsg = `GPS 정확도: ${accuracy.toFixed(1)}m. ${isNavigating?'추적 중.':'일시 정지됨.'}`;
        updateGpsStatus("ok", statusMsg);

        // 내비게이션 및 UI 업데이트는 isNavigating이 true일 때만 진행
        if (isNavigating && lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            const step = lastRouteData.steps[currentStepIndex];
            const target = AREA_COORDINATES[step.to_area];
            // lat2를 lon2로 수정해야 하지만, 기존 코드 흐름을 유지
            const dist = calculateDistance(latitude, longitude, target.lat, target.lat); 

            updateInstructionDisplay(step, `남은 거리: ${Math.round(dist)}m`);
            highlightStep(currentStepIndex);

            if (dist < DISTANCE_THRESHOLD) {
                currentStepIndex++;
                if (currentStepIndex >= lastRouteData.steps.length) {
                    handleArrival();
                } else {
                    const nextStep = lastRouteData.steps[currentStepIndex];
                    const nextTarget = AREA_COORDINATES[nextStep.to_area];
                    const nextDist = calculateDistance(latitude, longitude, nextTarget.lat, nextTarget.lon);
                    updateInstructionDisplay(nextStep, `남은 거리: ${Math.round(nextDist)}m`);
                    highlightStep(currentStepIndex);
                }
            }
        }
        drawMap();
    }

    function handleGpsError(err) {
        if (isNavigating) {
            let errMsg;
            if (err.code === err.PERMISSION_DENIED) {
                errMsg = "위치 정보 접근 권한이 거부되었습니다.";
            } else if (err.code === err.POSITION_UNAVAILABLE) {
                 errMsg = "위치 정보를 사용할 수 없습니다. GPS 방해 구역일 수 있습니다.";
            } else {
                errMsg = `GPS 오류 (${err.code}): ${err.message}`;
            }
            updateGpsStatus("error", errMsg + " (신호 복구 대기 중)");
        }
        drawMap();
    }

    function handleDeviceOrientation(e) {
        if (e.alpha !== null) {
            userGpsHeading = e.alpha;
            if (userGpsPosition) drawMap(); 
        }
    }

    function applyGpsOffsetToMap(userLat, userLon) {
        if (!lastRouteData) return;
        const startCoord = ORIGINAL_AREA_COORDINATES[lastRouteData.start];
        const dLat = userLat - startCoord.lat;
        const dLon = userLon - startCoord.lon;

        AREA_IDS.forEach(id => {
            AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat + dLat;
            AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon + dLon;
        });
        recalculateMapBounds();
    }

    function handleArrival() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        isNavigating = false;
        
        updateInstructionDisplay(null, null, true);
        updateControlButtons('경로 재설정', 'bg-blue-600', false);
        updateGpsStatus("ok", "도착 완료");
        highlightStep(currentStepIndex, true); 
        drawMap();
    }

    // --- 맵 드로잉 및 유틸리티 (변동 없음) ---
    function latLonToCanvas(lat, lon) {
        const rLat = mapBounds.maxLat - mapBounds.minLat || 0.000001;
        const rLon = mapBounds.maxLon - mapBounds.minLon || 0.000001;
        const pad = 0.08;
        const w = canvas.width * (1-2*pad); const h = canvas.height * (1-2*pad);
        const ox = canvas.width*pad; const oy = canvas.height*pad;
        
        let x = ((lon - mapBounds.minLon)/rLon)*w + ox;
        let y = h - ((lat - mapBounds.minLat)/rLat)*h + oy;

        const cx = canvas.width/2; const cy = canvas.height/2;
        x = cx + (x-cx)*mapScale + mapTranslateX;
        y = cy + (y-cy)*mapScale + mapTranslateY;
        return {x,y};
    }

    function drawMap() {
        const cw = canvas.parentElement.clientWidth;
        canvas.width = cw; canvas.height = canvas.width*0.6;
        if(canvas.height<300) canvas.height=300;
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // 1. 링크
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=2;
        ALL_CONNECTIONS.forEach(c=>{
            const s=latLonToCanvas(AREA_COORDINATES[c.u].lat, AREA_COORDINATES[c.u].lon);
            const e=latLonToCanvas(AREA_COORDINATES[c.v].lat, AREA_COORDINATES[c.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke();
        });

        // 2. 경로
        if(lastRouteData && lastRouteData.path) {
            ctx.strokeStyle='#ef4444'; ctx.lineWidth=5*mapScale; ctx.lineCap='round';
            ctx.beginPath();
            let first=true;
            lastRouteData.path.forEach(id=>{
                const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if(first){ctx.moveTo(p.x,p.y); first=false;}else ctx.lineTo(p.x,p.y);
            });
            ctx.stroke();
        }

        // 3. 사용자 (노란 점 + 파란 부채꼴)
        if(userGpsPosition) {
            const p = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);
            
            const r = 25 * 1.5 * mapScale; 
            const rad = userGpsHeading * Math.PI/180;
            const fov = 60 * Math.PI/180;
            const viewAngle = rad - Math.PI/2; 

            ctx.beginPath(); ctx.moveTo(p.x,p.y);
            ctx.arc(p.x, p.y, r, viewAngle - fov/2, viewAngle + fov/2);
            ctx.closePath(); ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; ctx.fill();

            ctx.beginPath(); ctx.arc(p.x, p.y, 10*mapScale, 0, Math.PI*2);
            ctx.fillStyle='#facc15'; ctx.fill(); 
            ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
            
            if (isNavigating && lastRouteData && currentStepIndex < lastRouteData.steps.length) {
                const target = AREA_COORDINATES[lastRouteData.steps[currentStepIndex].to_area];
                const t = latLonToCanvas(target.lat, target.lon);
                ctx.strokeStyle='rgba(16,185,129,0.5)'; ctx.setLineDash([6*mapScale,6*mapScale]); ctx.lineWidth=2*mapScale;
                ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(t.x,t.y); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        // 4. 노드
        AREA_IDS.forEach(id=>{
            const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isS=lastRouteData && id===lastRouteData.start;
            const isE=lastRouteData && id===lastRouteData.end;
            ctx.beginPath(); ctx.fillStyle=isS?'#3b82f6':(isE?'#ef4444':'#9ca3af');
            ctx.arc(p.x, p.y, (isS||isE?9:6)*mapScale, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#333'; ctx.font=`${12*mapScale}px sans-serif`; ctx.textAlign='center';
            ctx.fillText(id, p.x, p.y - 16*mapScale);
        });
    }

    // 경로 계산 및 거리 계산 함수 (변동 없음)
    function calculatePath(start, end) { 
        const dists={}, prev={}, q=new Set(AREA_IDS);
        AREA_IDS.forEach(i=>dists[i]=Infinity); dists[start]=0;
        while(q.size){
            let u=null; q.forEach(i=>{if(!u||dists[i]<dists[u])u=i;});
            if(u===end||dists[u]===Infinity) break; q.delete(u);
            ALL_CONNECTIONS.filter(c=>c.u===u).forEach(c=>{
                const alt=dists[u]+c.distance;
                if(alt<dists[c.v]){ dists[c.v]=alt; prev[c.v]=u; }
            });
        }
        if(dists[end]===Infinity) return {};
        const path=[]; let u=end; while(u){path.unshift(u); u=prev[u];}
        
        const steps=[];
        for(let i=0; i<path.length-1; i++){
            const c=ALL_CONNECTIONS.find(x=>x.u===path[i] && x.v===path[i+1]);
            steps.push({ to_area:path[i+1], distance:c.distance, turn:c.turn, instruction:c.instruction });
        }
        return { steps, totalDist:dists[end], totalTime:Math.ceil(dists[end]/1.0/60), path };
    }

    function calculateDistance(lat1,lon1,lat2,lon2){ 
        const R=6371e3, p1=lat1*Math.PI/180, p2=lat2*Math.PI/180, dp=(lat2-lat1)*Math.PI/180, dl=(lon2-lon1)*Math.PI/180;
        const a=Math.sin(dp/2)*Math.sin(dp/2)+Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)*Math.sin(dl/2);
        return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }

    // UI 표시 함수 수정: PC/모바일 모두 대응
    function renderGuidanceSummary(data) {
        const summaryHtml = `<div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg"><p class="font-bold text-lg">총 ${Math.round(data.totalDist)}m, 약 ${data.totalTime}분</p></div>`;
        outputDiv.innerHTML = summaryHtml; // 모바일 화면
        // PC 화면에서는 요약 대신 초기 안내 상태를 표시
        updateInstructionDisplay(null, null); 
        lucide.createIcons();
    }
    
    function renderStepsList(steps) {
        let html = '<h3 class="text-lg font-bold mb-3 text-gray-700">전체 경로</h3><ul class="space-y-2">';
        steps.forEach((step, index) => {
            html += `<li id="step-${index}" class="p-3 border rounded-lg bg-gray-50 flex items-center space-x-3 text-sm">
                <i data-lucide="${TURN_ICONS[step.turn]||'arrow-up'}" class="w-5 h-5 text-blue-500 flex-shrink-0"></i>
                <span>${index + 1}. ${step.instruction} (${step.distance}m)</span>
            </li>`;
        });
        html += '</ul>';
        stepsListDiv.innerHTML = html;
        document.getElementById('steps-list-container').classList.remove('hidden');
        lucide.createIcons();
    }
    function highlightStep(index, isArrival=false) {
        document.querySelectorAll('#steps-list li').forEach((li, i) => {
            li.classList.remove('bg-yellow-100', 'border-yellow-500', 'bg-green-100', 'border-green-500');
            if (i === index && !isArrival) {
                li.classList.add('bg-yellow-100', 'border-yellow-500');
            } else if (i < index || isArrival) {
                li.classList.add('bg-green-100', 'border-green-500');
            }
        });
    }

    // 줌/팬 인터랙션 (변동 없음)
    function setupInteractions() {
        canvas.addEventListener('wheel', e=>{ e.preventDefault(); mapScale=Math.max(0.6,Math.min(5, mapScale*(e.deltaY<0?1.1:0.9))); drawMap(); }, {passive:false});
        let st=[];
        canvas.addEventListener('touchstart', e=>{ e.preventDefault(); st=Array.from(e.touches); if(st.length===1){isDragging=true; lastMouseX=st[0].clientX; lastMouseY=st[0].clientY;} }, {passive:false});
        canvas.addEventListener('touchmove', e=>{
            e.preventDefault(); const t=Array.from(e.touches);
            if(t.length===1&&isDragging){ mapTranslateX+=t[0].clientX-lastMouseX; mapTranslateY+=t[0].clientY-lastMouseY; lastMouseX=t[0].clientX; lastMouseY=t[0].clientY; }
            else if(t.length===2&&st.length===2){
                const d1=Math.hypot(st[0].clientX-st[1].clientX, st[0].clientY-st[1].clientY);
                const d2=Math.hypot(t[0].clientX-t[1].clientX, t[0].clientY-t[1].clientY);
                if(d1>0) mapScale=Math.max(0.6,Math.min(5, mapScale*(d2/d1))); st=t;
            }
            drawMap();
        }, {passive:false});
        canvas.addEventListener('touchend', ()=>isDragging=false);
        canvas.addEventListener('mousedown', e=>{isDragging=true; lastMouseX=e.clientX; lastMouseY=e.clientY;});
        canvas.addEventListener('mousemove', e=>{if(isDragging){mapTranslateX+=e.clientX-lastMouseX; mapTranslateY+=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; drawMap();}});
        canvas.addEventListener('mouseup', ()=>isDragging=false);
    }

    function resetApp() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        isNavigating = false;

        lastRouteData=null; currentStepIndex=0; userGpsPosition=null; userGpsHeading=0;
        mapScale=1; mapTranslateX=0; mapTranslateY=0;
        AREA_IDS.forEach(id=>{ AREA_COORDINATES[id].lat=ORIGINAL_AREA_COORDINATES[id].lat; AREA_COORDINATES[id].lon=ORIGINAL_AREA_COORDINATES[id].lon; });
        recalculateMapBounds(); drawMap();
        navBar.classList.remove('active');
        updateControlButtons('GPS 내비 시작', 'bg-green-500', true);
        updateInstructionDisplay(null, null);
        updateGpsStatus('error', "준비: 경로를 설정하고 '준비' 버튼을 누르세요.");
        outputDiv.innerHTML = `<p class="text-gray-500">경로를 설정하세요.</p>`; // 모바일 초기 안내
        document.getElementById('steps-list-container').classList.remove('hidden'); // PC 경로창 다시 보이게
        document.getElementById('steps-list').innerHTML = `<h3 class="text-lg font-bold mb-3 text-gray-700">전체 경로</h3><p class="text-gray-500">경로를 검색하면 여기에 안내 단계가 표시됩니다.</p>`;
        loadRouteFromUrl();
    }

    function loadRouteFromUrl() {
        const p = new URLSearchParams(window.location.search);
        if(p.get('start') && AREA_IDS.includes(p.get('start'))) {
            startSelect.value = p.get('start');
            outputDiv.innerHTML = `<div class="p-4 bg-blue-100 rounded text-blue-700 font-bold">출발지: ${AREA_NAMES[p.get('start')]} (QR 인식됨)</div>`;
        } else outputDiv.innerHTML = `<p class="text-gray-500">경로를 설정하세요.</p>`;
    }

    function populate() {
        AREA_IDS.forEach(id => {
            const opt = `<option value="${id}">${AREA_NAMES[id]}</option>`;
            startSelect.insertAdjacentHTML('beforeend', opt); endSelect.insertAdjacentHTML('beforeend', opt);
        });
        endSelect.value = 'I';
    }
    
    // --- 초기화 ---
    window.onload = function() {
        populate(); loadRouteFromUrl(); setupInteractions(); recalculateMapBounds(); drawMap();
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        updateGpsStatus('error', "준비: 경로를 설정하고 '준비' 버튼을 누르세요.");
        updateControlButtons('GPS 내비 시작', 'bg-green-500', true);
        document.getElementById('steps-list-container').classList.add('hidden'); // 경로 검색 전에는 숨김
    };
    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>