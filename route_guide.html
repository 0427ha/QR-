<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS (ì§€ë„ ê³ ì • ë²„ì „)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; }
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        #route-map { 
            width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:300px; 
            touch-action: none; 
        }
        #navigation-bar { 
            position: fixed; bottom:0; left:0; right:0; z-index: 50; 
            background:#1e3a8a; color:white; 
            box-shadow: 0 -4px 12px rgba(0,0,0,0.2); 
            border-top-left-radius:1rem; border-top-right-radius:1rem; 
            transform: translateY(100%); transition: transform .3s ease-in-out; 
            padding: 0.75rem 1rem; 
        }
        #navigation-bar.active { transform: translateY(0); }
        #navigation-bar .flex-col { min-width: 0; }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS (ì§€ë„ ê³ ì • ë²„ì „)</h1>

        <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
            </div>
            <h2 class="text-xl font-bold text-gray-700 mb-4">ê²½ë¡œ ì„¤ì •</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">ì¶œë°œ êµ¬ì—­</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">ë„ì°© êµ¬ì—­</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                    ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„
                </button>
            </div>
        </div>

        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-gray-700 mb-4">ê²½ë¡œ ì§€ë„ ì‹œê°í™” (ì¤Œ/íŒ¬ ê°€ëŠ¥)</h2>
            <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>
            <div id="route-guidance-output">
                <p class="text-gray-500">ì§€ë„ë¥¼ ì‹œê°í™”í•˜ë ¤ë©´ ì¶œë°œì§€/ë„ì°©ì§€ë¥¼ ì„¤ì •í•˜ê³  ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
            </div>
            <div id="steps-list" class="mt-8 hidden"></div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3 min-w-0"> 
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"><i data-lucide="compass" class="w-7 h-7"></i></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="text-xl font-extrabold leading-snug truncate">ëŒ€ê¸° ì¤‘</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5 truncate">-</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>ë‚´ë¹„ ì‹œì‘</button>
    </div>

    <script>
    // --- ë°ì´í„° ì •ì˜ ---
    const AREA_NAMES = {
        'A': 'A. êµ­ì œì„  ë„ì°© ê²Œì´íŠ¸ (1ì¸µ)', 'B': 'B. ë©´ì„¸í’ˆ ìˆ˜ë ¹ ë°ìŠ¤í¬ (1ì¸µ)', 'C': 'C. í™˜ì „ì†Œ/ì—¬í–‰ì ë³´í—˜ (1ì¸µ)',
        'D': 'D. êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° (2ì¸µ)', 'E': 'E. ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ (2ì¸µ)', 'F': 'F. í‘¸ë“œì½”íŠ¸ (2ì¸µ)',
        'G': 'G. ë¼ìš´ì§€ ì…êµ¬ (3ì¸µ í”„ë¦¬ë¯¸ì—„)', 'H': 'H. ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ (3ì¸µ)', 'I': 'I. íƒ‘ìŠ¹ ê²Œì´íŠ¸ (3ì¸µ ì¥ê±°ë¦¬)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    // ğŸš¨ [ê³ ì •ëœ ê°€ìƒ ì¢Œí‘œê³„] ì§€ë„ ë“œë¡œì‰ì˜ ê¸°ì¤€ì´ ë˜ëŠ” ê³ ì •ëœ ì¢Œí‘œì…ë‹ˆë‹¤.
    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 }, 'B': { lat: 37.510000, lon: 127.051800 }, 'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 }, 'E': { lat: 37.508500, lon: 127.051800 }, 'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 }, 'H': { lat: 37.507000, lon: 127.051800 }, 'I': { lat: 37.507000, lon: 127.053600 }
    };
    
    const CONNECTIONS_DATA = [
        { u:'A', v:'B', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ë©´ì„¸í’ˆ ìˆ˜ë ¹ ë°ìŠ¤í¬ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, 
        { u:'B', v:'C', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ í™˜ì „ì†Œ/ì—¬í–‰ì ë³´í—˜ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'D', v:'E', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, 
        { u:'E', v:'F', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'G', v:'H', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, 
        { u:'H', v:'I', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ íƒ‘ìŠ¹ ê²Œì´íŠ¸ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'A', v:'D', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° ë°©í–¥ìœ¼ë¡œ ì´ë™" }, 
        { u:'B', v:'E', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'C', v:'F', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, 
        { u:'D', v:'G', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ë¼ìš´ì§€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'E', v:'H', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, 
        { u:'F', v:'I', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ íƒ‘ìŠ¹ ê²Œì´íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'A', v:'E', distance:21, time:0.4, turn:"ìš°íšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, 
        { u:'B', v:'D', distance:21, time:0.4, turn:"ì¢ŒíšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'B', v:'F', distance:21, time:0.4, turn:"ìš°íšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, 
        { u:'E', v:'C', distance:21, time:0.4, turn:"ì¢ŒíšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ í™˜ì „ì†Œ ë°©í–¥ìœ¼ë¡œ ì´ë™" }
    ];

    // ì–‘ë°©í–¥ ì—°ê²° ì •ë³´ ìƒì„±
    const ALL_CONNECTIONS = [];
    CONNECTIONS_DATA.forEach(conn => {
        ALL_CONNECTIONS.push(conn);
        const reverseTurn = (conn.turn === "ìš°íšŒì „") ? "ì¢ŒíšŒì „" : (conn.turn === "ì¢ŒíšŒì „") ? "ìš°íšŒì „" : "ì§ì§„";
        let reverseInstruction = conn.instruction.replace('ì˜¤ë¥¸ìª½', 'ì™¼ìª½').replace('ìœ„ì¸µ', 'ì•„ë˜ì¸µ');
        if (!CONNECTIONS_DATA.some(r => r.u === conn.v && r.v === conn.u)) {
            ALL_CONNECTIONS.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/ë°©í–¥ìœ¼ë¡œ ì´ë™/g, 'ë°©í–¥ìœ¼ë¡œ ëŒì•„ê°€ê¸°') });
        }
    });

    const TURN_ICONS = { 'ì§ì§„':'arrow-up', 'ìš°íšŒì „':'corner-down-right', 'ì¢ŒíšŒì „':'corner-down-left', 'ë„ì°©':'map-pin' };

    // --- ë³€ìˆ˜ ë° ìƒìˆ˜ ---
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false; 
    let gpsWatchId = null;
    let userGpsPosition = null; // ë§µ ì¢Œí‘œê³„ì—ì„œì˜ ì‚¬ìš©ì ìœ„ì¹˜ (ë“œë¡œì‰ìš©)
    let userGpsHeading = 0; 
    
    // ğŸš¨ [ìˆ˜ì •] GPS ì˜¤í”„ì…‹ ì €ì¥ìš© ë³€ìˆ˜: ì‚¬ìš©ìì˜ ì‹¤ì œ GPSì™€ ê°€ìƒ ì§€ë„ ì‹œì‘ì ì˜ ì°¨ì´ ì €ì¥
    let gpsOffset = { dLat: 0, dLon: 0 }; 

    // ë§µ ë·° ìƒíƒœ
    let mapScale = 1.0;
    let mapTranslateX = 0; let mapTranslateY = 0;
    let isDragging = false; let lastMouseX, lastMouseY; 

    const DISTANCE_THRESHOLD = 5; // 5ë¯¸í„° ì´ë‚´ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ
    
    // --- DOM ---
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction');

    // ë§µ ê²½ê³„
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id]; // ê³ ì •ëœ ê°€ìƒ ì¢Œí‘œ ì‚¬ìš©
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat); mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon); mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // -------------------------
    // í•µì‹¬ ë¡œì§: ë²„íŠ¼ ë° GPS ì œì–´
    // -------------------------

    // ê±°ë¦¬ë¥¼ ë³´ê¸° ì¢‹ì€ í˜•ì‹(m ë˜ëŠ” km)ìœ¼ë¡œ ë³€í™˜
    function formatDistance(distanceMeters) {
        if (typeof distanceMeters !== 'number' || isNaN(distanceMeters) || distanceMeters < 0) {
            return 'ê±°ë¦¬ ì¸¡ì • ë¶ˆê°€';
        }
        if (distanceMeters >= 1000) {
            const distanceKm = distanceMeters / 1000;
            // ì†Œìˆ˜ì  ì²«ì§¸ ìë¦¬ê¹Œì§€ í‘œì‹œ
            return `${distanceKm.toFixed(1)}km`; 
        } else {
            return `${Math.round(distanceMeters)}m`;
        }
    }


    function updateGpsStatus(type, message) {
        gpsStatusMessage.textContent = message;
        gpsStatusMessage.classList.remove('gps-status-ok', 'gps-status-err');
        if (type === 'ok') {
            gpsStatusMessage.classList.add('gps-status-ok');
        } else if (type === 'error') {
            gpsStatusMessage.classList.add('gps-status-err');
        } else {
             gpsStatusMessage.classList.add('gps-status-err');
        }
    }
    
    // ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì œì–´
    function startRouteGuidance() {
        if (isNavigating) stopNavigation(); 
        
        const startId = startSelect.value;
        const endId = endSelect.value;
        if (startId === endId) { 
            outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg">ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ê°™ìŠµë‹ˆë‹¤.</div>`; 
            updateGpsStatus('error', "ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.");
            return; 
        }

        searchButton.disabled = true; searchButton.innerText = 'ê²½ë¡œ ê³„ì‚° ì¤‘...';
        const { steps, totalDist, totalTime, path } = calculatePath(startId, endId);
        
        if (!steps) { 
            outputDiv.innerHTML = `<div class="p-4 bg-red-100 text-red-700">ê²½ë¡œ ì—†ìŒ</div>`; 
            resetUI(); 
            updateGpsStatus('error', "ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.");
            return; 
        }

        lastRouteData = { start: startId, end: endId, steps: steps, totalDist: totalDist, totalTime: totalTime, path: path };
        currentStepIndex = 0;

        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();

        navBar.classList.add('active');
        navControlButton.innerText = 'ë‚´ë¹„ ì‹œì‘'; 
        navControlButton.disabled = false;
        navControlButton.className = "px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600";
        
        resetUI(); 
        
        updateGpsStatus("ok", "ê²½ë¡œ ì„¤ì • ì™„ë£Œ. 'ë‚´ë¹„ ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.");
        
        userGpsPosition = null;
        drawMap();
    }

    function resetUI() {
        searchButton.disabled = false;
        searchButton.innerText = 'ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„';
    }

    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === 'ì¬ì„¤ì •') { resetApp(); return; } 

        if (isNavigating) {
            stopNavigation();
        } else {
            startNavigation();
        }
    }

    function startNavigation() {
        if (!navigator.geolocation) { 
            console.error("GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            updateGpsStatus('error', "ì˜¤ë¥˜: ì´ ë¸Œë¼ìš°ì €ëŠ” GPSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            return; 
        }
        
        isNavigating = true;
        
        // UI ì—…ë°ì´íŠ¸
        navControlButton.innerText = 'ë‚´ë¹„ ì •ì§€'; 
        navControlButton.className = "px-5 py-2 bg-yellow-500 text-white font-bold rounded-full shadow-lg hover:bg-yellow-600";
        updateGpsStatus("ok", "GPS ì¶”ì  ì‹œì‘. ìœ„ì¹˜ ì •ë³´ ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...");

        // Device Orientation ê¶Œí•œ ìš”ì²­ ë° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission().then(state => {
                if(state==='granted') window.addEventListener('deviceorientation', handleDeviceOrientation);
            }).catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleDeviceOrientation);
        }

        // ì´ˆê¸° ìœ„ì¹˜ íšë“ ë° ì§€ë„ ì˜¤í”„ì…‹ ì ìš© ì‹œë„
        navigator.geolocation.getCurrentPosition(
            (pos) => { 
                applyGpsOffsetToMap(pos.coords.latitude, pos.coords.longitude); 
                // ì˜¤í”„ì…‹ ì ìš© í›„ ì²« ìœ„ì¹˜ë¥¼ ì²˜ë¦¬í•˜ì—¬ ë°”ë¡œ ì§€ë„ì— í‘œì‹œ
                handleGpsSuccess(pos); 
            },
            (err) => { 
                console.warn("ì´ˆê¸° GPS ì˜¤í”„ì…‹ ìœ„ì¹˜ íšë“ ì‹¤íŒ¨. ì›Œì²˜ë¡œ ê³„ì† ì‹œë„í•©ë‹ˆë‹¤.", err); 
            },
            { enableHighAccuracy: true, timeout: 3000 }
        );
        
        // GPS Watcher ì‹œì‘ (ì•„ì§ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆë¼ë©´)
        if (!gpsWatchId) { 
            gpsWatchId = navigator.geolocation.watchPosition(handleGpsSuccess, handleGpsError, {
                enableHighAccuracy: true, timeout: 5000, maximumAge: 0 
            });
        }
    }

    function stopNavigation() {
        if (!isNavigating) return;
        
        isNavigating = false;
        
        // UI ì—…ë°ì´íŠ¸
        navControlButton.innerText = 'ë‚´ë¹„ ì¬ê°œ'; 
        navControlButton.className = "px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600";
        updateGpsStatus("error", "GPS ì¶”ì  ì¼ì‹œ ì¤‘ì§€ë¨. ì¬ê°œë¥¼ ëˆ„ë¥´ì„¸ìš”.");
        
        // Device Orientation ë¦¬ìŠ¤ë„ˆ ì œê±° (GPS WatcherëŠ” ìœ ì§€)
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
    }

    // --- GPS ë° ì„¼ì„œ í•¸ë“¤ëŸ¬ ---
    function handleGpsSuccess(pos) {
        const { latitude, longitude, accuracy } = pos.coords;
        
        // 1. [ë“œë¡œì‰ìš©] ì‹¤ì œ GPS ì¢Œí‘œì—ì„œ ëŒ€ê·œëª¨ ì˜¤í”„ì…‹ì„ ì œê±°í•˜ì—¬ 'ê°€ìƒ ë§µ ì¢Œí‘œê³„'ë¡œ ë³€í™˜
        //    ì´ ìœ„ì¹˜ê°€ ê³ ì •ëœ ì§€ë„ ìœ„ì—ì„œ ì‚¬ìš©ì ìœ„ì¹˜ë¥¼ ì •í™•íˆ í‘œì‹œí•©ë‹ˆë‹¤.
        const mapLat = latitude - gpsOffset.dLat;
        const mapLon = longitude - gpsOffset.dLon;

        // 2. ë§µ ì¢Œí‘œê³„ë¡œ ë³€í™˜ëœ ìœ„ì¹˜ë¥¼ userGpsPositionì— ì €ì¥ (DRAWINGìš©)
        userGpsPosition = { lat: mapLat, lon: mapLon, acc: accuracy };
        
        let statusMsg = `GPS ì •í™•ë„: ${accuracy.toFixed(1)}m. ${isNavigating?'ì¶”ì  ì¤‘.':'ì¼ì‹œ ì •ì§€ë¨.'}`;
        updateGpsStatus("ok", statusMsg);

        // 3. ë‚´ë¹„ê²Œì´ì…˜ í™œì„±í™” ì‹œì—ë§Œ ê²½ë¡œ ì¶”ì  ë¡œì§ ì‹¤í–‰
        if (isNavigating && lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            const step = lastRouteData.steps[currentStepIndex];
            const targetVirtual = AREA_COORDINATES[step.to_area]; // ëª©í‘œ ì§€ì  (ê³ ì •ëœ ê°€ìƒ ì§€ë„ ì¢Œí‘œ)
            
            // 4. ğŸš¨ [ìˆ˜ì •] ê±°ë¦¬ ê³„ì‚°: í˜„ì¬ ì‹¤ì œ GPS ìœ„ì¹˜ì™€ ëª©í‘œ ì§€ì ì˜ ì‹¤ì œ GPS ë“±ê°€ ì¢Œí‘œë¥¼ ë¹„êµ
            const targetRealLat = targetVirtual.lat + gpsOffset.dLat;
            const targetRealLon = targetVirtual.lon + gpsOffset.dLon;
            
            const dist = calculateDistance(latitude, longitude, targetRealLat, targetRealLon); 

            updateNavigationBar(step, dist);
            highlightStep(currentStepIndex);

            if (dist < DISTANCE_THRESHOLD) {
                currentStepIndex++;
                if (currentStepIndex >= lastRouteData.steps.length) {
                    handleArrival();
                } else {
                    // ë‹¤ìŒ ë‹¨ê³„ ëª©í‘œê¹Œì§€ì˜ ë‚¨ì€ ê±°ë¦¬ ê³„ì‚° (ë™ì¼ ë¡œì§ ì ìš©)
                    const nextStepTargetVirtual = AREA_COORDINATES[lastRouteData.steps[currentStepIndex].to_area];
                    const nextTargetRealLat = nextStepTargetVirtual.lat + gpsOffset.dLat;
                    const nextTargetRealLon = nextStepTargetVirtual.lon + gpsOffset.dLon;
                    
                    updateNavigationBar(
                        lastRouteData.steps[currentStepIndex], 
                        calculateDistance(latitude, longitude, nextTargetRealLat, nextTargetRealLon)
                    );
                    highlightStep(currentStepIndex);
                }
            }
        }
        drawMap(); 
    }

    function handleGpsError(err) {
        if (isNavigating) { 
            let errMsg;
            if (err.code === err.PERMISSION_DENIED) {
                errMsg = "ìœ„ì¹˜ ì •ë³´ ì ‘ê·¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.";
            } else if (err.code === err.POSITION_UNAVAILABLE) {
                errMsg = "ìœ„ì¹˜ ì •ë³´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. GPS ë°©í•´ êµ¬ì—­ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
            } else {
                errMsg = `GPS ì˜¤ë¥˜ (${err.code}): ${err.message}`;
            }
            updateGpsStatus("error", errMsg + " (ì‹ í˜¸ ë³µêµ¬ ëŒ€ê¸° ì¤‘)");
        }
        drawMap();
    }

    function handleDeviceOrientation(e) {
        if (e.alpha !== null) {
            userGpsHeading = e.alpha; 
            if (userGpsPosition) drawMap(); 
        }
    }

    // ğŸš¨ [ìˆ˜ì •] ì§€ë„ ì¢Œí‘œê³„ ë³´ì • (ì˜¤ì§ ì˜¤í”„ì…‹ë§Œ ê³„ì‚°í•˜ê³  ì €ì¥)
    function applyGpsOffsetToMap(userLat, userLon) {
        if (!lastRouteData) return;
        const startCoord = AREA_COORDINATES[lastRouteData.start]; // ê³ ì •ëœ ê°€ìƒ ì¢Œí‘œ ì‚¬ìš©

        // ì‚¬ìš©ìì˜ ì‹¤ì œ ìœ„ì¹˜ì™€ ê°€ìƒ ë§µ ì‹œì‘ì  ê°„ì˜ ëŒ€ê·œëª¨ ì°¨ì´ ê³„ì‚° (ì˜¤í”„ì…‹)
        gpsOffset.dLat = userLat - startCoord.lat;
        gpsOffset.dLon = userLon - startCoord.lon;

        // ğŸš¨ ì¤‘ìš”: ì§€ë„ ì¢Œí‘œ(AREA_COORDINATES)ë¥¼ ìˆ˜ì •í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì§€ë„ëŠ” ê³ ì •ë©ë‹ˆë‹¤.
        recalculateMapBounds();
    }

    function handleArrival() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        isNavigating = false;
        
        navInstruction.innerText = "ëª©ì ì§€ ë„ì°©! ğŸ¥³";
        document.getElementById('nav-step-info').innerText = AREA_NAMES[lastRouteData.end];
        
        navControlButton.innerText = 'ì¬ì„¤ì •'; 
        navControlButton.className = "px-5 py-2 bg-blue-600 text-white font-bold rounded-full shadow-lg";
        updateGpsStatus("ok", "ë„ì°© ì™„ë£Œ");
        highlightStep(currentStepIndex, true); 
        drawMap();
    }
    
    // ìœ„ê²½ë„ ì¢Œí‘œë¥¼ ìº”ë²„ìŠ¤ ì¢Œí‘œë¡œ ë³€í™˜
    function latLonToCanvas(lat, lon) {
        const rLat = mapBounds.maxLat - mapBounds.minLat || 0.000001;
        const rLon = mapBounds.maxLon - mapBounds.minLon || 0.000001;
        const pad = 0.08;
        const w = canvas.width * (1-2*pad); const h = canvas.height * (1-2*pad);
        const ox = canvas.width*pad; const oy = canvas.height*pad;
        
        let x = ((lon - mapBounds.minLon)/rLon)*w + ox;
        let y = h - ((lat - mapBounds.minLat)/rLat)*h + oy;

        const cx = canvas.width/2; const cy = canvas.height/2;
        // ì¤Œ ë° íŒ¬ ì ìš©
        x = cx + (x-cx)*mapScale + mapTranslateX;
        y = cy + (y-cy)*mapScale + mapTranslateY;
        return {x,y};
    }
    
    // ë§µ ë“œë¡œì‰ ë¡œì§
    function drawMap() {
        const cw = canvas.parentElement.clientWidth;
        canvas.width = Math.min(cw, 900); canvas.height = canvas.width*0.6;
        if(canvas.height<300) canvas.height=300;
        ctx.clearRect(0,0,canvas.width,canvas.height);

        // 1. ëª¨ë“  ì—°ê²° ë§í¬ ê·¸ë¦¬ê¸° (ê³ ì •ëœ AREA_COORDINATES ì‚¬ìš©)
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=2;
        ALL_CONNECTIONS.forEach(c=>{
            const s=latLonToCanvas(AREA_COORDINATES[c.u].lat, AREA_COORDINATES[c.u].lon);
            const e=latLonToCanvas(AREA_COORDINATES[c.v].lat, AREA_COORDINATES[c.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke();
        });

        // 2. ê²½ë¡œ ê·¸ë¦¬ê¸° (ê³ ì •ëœ AREA_COORDINATES ì‚¬ìš©)
        if(lastRouteData && lastRouteData.path) {
            ctx.strokeStyle='#ef4444'; ctx.lineWidth=5*mapScale; ctx.lineCap='round';
            ctx.beginPath();
            let first=true;
            lastRouteData.path.forEach(id=>{
                const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if(first){ctx.moveTo(p.x,p.y); first=false;}else ctx.lineTo(p.x,p.y);
            });
            ctx.stroke();
        }

        // 3. ì‚¬ìš©ì ìœ„ì¹˜ (userGpsPositionì€ ì´ë¯¸ ë§µ ì¢Œí‘œê³„ë¡œ ë³€í™˜ëœ ê°’)
        if(userGpsPosition) {
            const p = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);
            
            // ë¶€ì±„ê¼´ (ì‹œì•¼ê°/ë°©í–¥)
            const r = 25 * 1.5 * mapScale; 
            const rad = (userGpsHeading) * Math.PI/180; 
            const fov = 60 * Math.PI/180;
            const viewAngle = rad - Math.PI/2; 

            ctx.beginPath(); ctx.moveTo(p.x,p.y);
            ctx.arc(p.x, p.y, r, viewAngle - fov/2, viewAngle + fov/2);
            ctx.closePath(); ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; ctx.fill();

            // ë…¸ë€ ì  (ì‚¬ìš©ì ìœ„ì¹˜)
            ctx.beginPath(); ctx.arc(p.x, p.y, 10*mapScale, 0, Math.PI*2);
            ctx.fillStyle='#facc15'; ctx.fill(); 
            ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
            
            // ì ì„  (ë‹¤ìŒ ëª©í‘œ)
            if (isNavigating && lastRouteData && currentStepIndex < lastRouteData.steps.length) {
                // ëª©í‘œ ì§€ì ì€ ê³ ì •ëœ AREA_COORDINATESì—ì„œ ê°€ì ¸ì˜´
                const target = AREA_COORDINATES[lastRouteData.steps[currentStepIndex].to_area];
                const t = latLonToCanvas(target.lat, target.lon);
                ctx.strokeStyle='rgba(16,185,129,0.5)'; ctx.setLineDash([6*mapScale,6*mapScale]); ctx.lineWidth=2*mapScale;
                ctx.beginPath(); ctx.moveTo(p.x,p.y); ctx.lineTo(t.x,t.y); ctx.stroke(); ctx.setLineDash([]);
            }
        }

        // 4. ë…¸ë“œ ê·¸ë¦¬ê¸° (ê³ ì •ëœ AREA_COORDINATES ì‚¬ìš©)
        AREA_IDS.forEach(id=>{
            const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isS=lastRouteData && id===lastRouteData.start;
            const isE=lastRouteData && id===lastRouteData.end;
            ctx.beginPath(); ctx.fillStyle=isS?'#3b82f6':(isE?'#ef4444':'#9ca3af');
            ctx.arc(p.x, p.y, (isS||isE?9:6)*mapScale, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle='#333'; ctx.font=`${12*mapScale}px sans-serif`; ctx.textAlign='center';
            ctx.fillText(id, p.x, p.y - 16*mapScale);
        });
    }

    // ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ (ë³€ê²½ ì—†ìŒ)
    function calculatePath(start, end) { 
        const dists={}, prev={}, q=new Set(AREA_IDS);
        AREA_IDS.forEach(i=>dists[i]=Infinity); dists[start]=0;
        while(q.size){
            let u=null; q.forEach(i=>{if(!u||dists[i]<dists[u])u=i;})
            if(u===end||dists[u]===Infinity) break; q.delete(u);
            ALL_CONNECTIONS.filter(c=>c.u===u).forEach(c=>{
                const alt=dists[u]+c.distance;
                if(alt<dists[c.v]){ dists[c.v]=alt; prev[c.v]=u; }
            });
        }
        if(dists[end]===Infinity) return {};
        const path=[]; let u=end; while(u){path.unshift(u); u=prev[u];}
        
        const steps=[];
        for(let i=0; i<path.length-1; i++){
            const c=ALL_CONNECTIONS.find(x=>x.u===path[i] && x.v===path[i+1]);
            steps.push({ to_area:path[i+1], distance:c.distance, turn:c.turn, instruction:c.instruction });
        }
        return { steps, totalDist:dists[end], totalTime:Math.ceil(dists[end]/1.0/60), path }; 
    }

    // í•˜ë²„ì‚¬ì¸ ê³µì‹ìœ¼ë¡œ ë‘ ìœ„ê²½ë„ ì‚¬ì´ì˜ ê±°ë¦¬ë¥¼ ë¯¸í„°(m) ë‹¨ìœ„ë¡œ ê³„ì‚° (ë³€ê²½ ì—†ìŒ)
    function calculateDistance(lat1,lon1,lat2,lon2){ 
        const R=6371e3, p1=lat1*Math.PI/180, p2=lat2*Math.PI/180, dp=(lat2-lat1)*Math.PI/180, dl=(lon2-lon1)*Math.PI/180;
        const a=Math.sin(dp/2)*Math.sin(dp/2)+Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)*Math.sin(dl/2);
        return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }

    // ë‚´ë¹„ê²Œì´ì…˜ ë°” ì •ë³´ ì—…ë°ì´íŠ¸
    function updateNavigationBar(step, dist) {
        navInstruction.innerText = step.instruction;
        document.getElementById('nav-step-info').innerText = `ë‚¨ì€ ê±°ë¦¬: ${formatDistance(dist)}`; 
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${TURN_ICONS[step.turn]||'arrow-up'}" class="w-7 h-7"></i>`;
        lucide.createIcons();
    }

    // ê²½ë¡œ ìš”ì•½ ì •ë³´ ë Œë”ë§ (ë³€ê²½ ì—†ìŒ)
    function renderGuidanceSummary(data) {
        outputDiv.innerHTML = `<div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg"><p class="font-bold text-lg">ì´ ${formatDistance(data.totalDist)}, ì˜ˆìƒ ì†Œìš” ì‹œê°„ ì•½ ${data.totalTime}ë¶„</p></div>`;
        document.getElementById('nav-next-instruction').textContent = 'ë‚´ë¹„ ì‹œì‘ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.'; 
        document.getElementById('nav-step-info').textContent = 'ì¶œë°œì§€ ê·¼ì²˜ì— ê°€ì‹œë©´ ì¶”ì ì„ ì‹œì‘í•©ë‹ˆë‹¤.';
        lucide.createIcons();
    }
    
    // ê²½ë¡œ ë‹¨ê³„ ëª©ë¡ ë Œë”ë§ (ë³€ê²½ ì—†ìŒ)
    function renderStepsList(steps) {
        let html = '<h3 class="text-lg font-bold mb-3">ì „ì²´ ê²½ë¡œ</h3><ul class="space-y-2">';
        steps.forEach((step, index) => {
            html += `<li id="step-${index}" class="p-3 border rounded-lg bg-gray-50 flex items-center space-x-3 text-sm">
                <i data-lucide="${TURN_ICONS[step.turn]||'arrow-up'}" class="w-5 h-5 text-blue-500 flex-shrink-0"></i>
                <span>${index + 1}. ${step.instruction} (${formatDistance(step.distance)})</span>
            </li>`;
        });
        html += '</ul>';
        stepsListDiv.innerHTML = html;
        stepsListDiv.classList.remove('hidden');
        lucide.createIcons();
    }
    
    // ê²½ë¡œ ë‹¨ê³„ í•˜ì´ë¼ì´íŠ¸ (ë³€ê²½ ì—†ìŒ)
    function highlightStep(index, isArrival=false) {
        document.querySelectorAll('#steps-list li').forEach((li, i) => {
            li.classList.remove('bg-yellow-100', 'border-yellow-500', 'bg-green-100', 'border-green-500');
            if (i === index && !isArrival) {
                li.classList.add('bg-yellow-100', 'border-yellow-500');
            } 
            else if (i < index || isArrival && i < currentStepIndex) {
                li.classList.add('bg-green-100', 'border-green-500');
            }
        });
    }

    // ì¤Œ/íŒ¬ ì¸í„°ë™ì…˜ ì„¤ì • (ë³€ê²½ ì—†ìŒ)
    function setupInteractions() {
        canvas.addEventListener('wheel', e=>{ e.preventDefault(); mapScale=Math.max(0.6,Math.min(5, mapScale*(e.deltaY<0?1.1:0.9))); drawMap(); }, {passive:false});
        
        let st=[]; 
        
        canvas.addEventListener('touchstart', e=>{ e.preventDefault(); st=Array.from(e.touches); if(st.length===1){isDragging=true; lastMouseX=st[0].clientX; lastMouseY=st[0].clientY;} }, {passive:false});
        
        canvas.addEventListener('touchmove', e=>{
            e.preventDefault(); const t=Array.from(e.touches);
            if(t.length===1&&isDragging){ 
                mapTranslateX+=t[0].clientX-lastMouseX; 
                mapTranslateY+=t[0].clientY-lastMouseY; 
                lastMouseX=t[0].clientX; lastMouseY=t[0].clientY; 
            }
            else if(t.length===2&&st.length===2){
                const d1=Math.hypot(st[0].clientX-st[1].clientX, st[0].clientY-st[1].clientY);
                const d2=Math.hypot(t[0].clientX-t[1].clientX, t[0].clientY-t[1].clientY);
                if(d1>0) mapScale=Math.max(0.6,Math.min(5, mapScale*(d2/d1))); st=t;
            }
            drawMap();
        }, {passive:false});
        
        canvas.addEventListener('touchend', ()=>isDragging=false);
        
        canvas.addEventListener('mousedown', e=>{isDragging=true; lastMouseX=e.clientX; lastMouseY=e.clientY;});
        canvas.addEventListener('mousemove', e=>{if(isDragging){mapTranslateX+=e.clientX-lastMouseX; mapTranslateY+=e.clientY-lastMouseY; lastMouseX=e.clientX; lastMouseY=e.clientY; drawMap();}});
        canvas.addEventListener('mouseup', ()=>isDragging=false);
    }

    // ì•±ì˜ ëª¨ë“  ìƒíƒœ ë° UIë¥¼ ì´ˆê¸°í™”
    function resetApp() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        window.removeEventListener('deviceorientation', handleDeviceOrientation);
        isNavigating = false;

        lastRouteData=null; currentStepIndex=0; userGpsPosition=null; userGpsHeading=0;
        mapScale=1; mapTranslateX=0; mapTranslateY=0;
        // ì˜¤í”„ì…‹ ì´ˆê¸°í™”
        gpsOffset = { dLat: 0, dLon: 0 }; 
        recalculateMapBounds(); drawMap(); // ë§µì€ ê³ ì • ìƒíƒœ ìœ ì§€
        navBar.classList.remove('active');
        
        navControlButton.innerText = 'ë‚´ë¹„ ì‹œì‘'; navControlButton.disabled = true;
        navControlButton.className = "px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg";
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-7 h-7"></i>`;
        document.getElementById('nav-next-instruction').textContent = 'ëŒ€ê¸° ì¤‘';
        document.getElementById('nav-step-info').textContent = '-';
        stepsListDiv.classList.add('hidden');
        
        updateGpsStatus('error', "ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.");
        loadRouteFromUrl(); 
    }

    // URL íŒŒë¼ë¯¸í„°ì—ì„œ ê²½ë¡œ ì •ë³´ ë¡œë“œ (ë³€ê²½ ì—†ìŒ)
    function loadRouteFromUrl() {
        const p = new URLSearchParams(window.location.search);
        if(p.get('start') && AREA_IDS.includes(p.get('start'))) {
            startSelect.value = p.get('start');
            outputDiv.innerHTML = `<div class="p-4 bg-blue-100 rounded text-blue-700 font-bold">ì¶œë°œì§€: ${AREA_NAMES[p.get('start')]} (QR ì¸ì‹ë¨)</div>`;
        } else outputDiv.innerHTML = `<p class="text-gray-500">ê²½ë¡œë¥¼ ì„¤ì •í•˜ì„¸ìš”.</p>`;
    }

    // ì¶œë°œ/ë„ì°© ë“œë¡­ë‹¤ìš´ ëª©ë¡ ì±„ìš°ê¸° (ë³€ê²½ ì—†ìŒ)
    function populate() {
        AREA_IDS.forEach(id => {
            const opt = `<option value="${id}">${AREA_NAMES[id]}</option>`;
            startSelect.insertAdjacentHTML('beforeend', opt); endSelect.insertAdjacentHTML('beforeend', opt);
        });
        startSelect.value = 'A'; 
        endSelect.value = 'I'; 
    }
    
    // --- ì´ˆê¸°í™” ---
    window.onload = function() {
        populate(); loadRouteFromUrl(); setupInteractions(); recalculateMapBounds(); drawMap();
        
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-7 h-7"></i>`;
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        updateGpsStatus('error', "ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.");
    };
    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>