<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>✈️ 공항 GPS 내비게이션 시뮬레이션 (가상 이동1)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; }
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        #route-map { width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:300px; }
        #navigation-bar { position: fixed; bottom:0; left:0; right:0; z-index: 50; background:#1e3a8a; color:white; box-shadow: 0 -4px 12px rgba(0,0,0,0.2); border-top-left-radius:1rem; border-top-right-radius:1rem; transform: translateY(100%); transition: transform .3s ease-in-out; padding:1rem;}
        #navigation-bar.active { transform: translateY(0); }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">✈️ 공항 터미널 GPS 내비게이션 (가상 이동)</h1>

        <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                시뮬레이션 상태: 내비게이션을 시작해야 가상 위치 추적을 시작합니다.
            </div>
            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 설정</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">출발 구역</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">도착 구역</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                    경로 검색 및 내비게이션 준비
                </button>
            </div>
        </div>

        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 지도 시각화</h2>
            <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>
            <div id="route-guidance-output">
                <p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>
            </div>
            <div id="steps-list" class="mt-8 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-3">전체 경로 지침 미리보기:</h3>
            </div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3">
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="text-xl font-extrabold leading-snug truncate">경로를 검색해 주세요.</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5">총 거리: 0m | 총 시간: 0분</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>GPS 내비 시작</button>
    </div>

    <script>
    // -------------------------
    // 데이터 및 초기 설정
    // -------------------------
    const AREA_NAMES = {
        'A': 'A. 국제선 도착 게이트 (1층)', 'B': 'B. 면세품 수령 데스크 (1층)', 'C': 'C. 환전소/여행자 보험 (1층)',
        'D': 'D. 국내선 체크인 카운터 (2층)', 'E': 'E. 출국 심사대 입구 (2층)', 'F': 'F. 푸드코트 (2층)',
        'G': 'G. 라운지 입구 (3층 프리미엄)', 'H': 'H. 면세점 중앙 구역 (3층)', 'I': 'I. 탑승 게이트 (3층 장거리)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 }, 'B': { lat: 37.510000, lon: 127.051800 }, 'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 }, 'E': { lat: 37.508500, lon: 127.051800 }, 'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 }, 'H': { lat: 37.507000, lon: 127.051800 }, 'I': { lat: 37.507000, lon: 127.053600 }
    };
    
    // 경로 연결 정보 (이전 코드와 동일, 생략)
    const ALL_CONNECTIONS = [
        { u:'A', v:'B', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세품 수령 데스크 방향으로 직진" }, { u:'B', v:'C', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 환전소/여행자 보험 방향으로 직진" },
        { u:'D', v:'E', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 출국 심사대 입구 방향으로 직진" }, { u:'E', v:'F', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 푸드코트 방향으로 직진" },
        { u:'G', v:'H', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세점 중앙 구역 방향으로 직진" }, { u:'H', v:'I', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 탑승 게이트 방향으로 직진" },
        { u:'A', v:'D', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 국내선 체크인 카운터 방향으로 이동" }, { u:'B', v:'E', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 출국 심사대 입구 방향으로 이동" },
        { u:'C', v:'F', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 푸드코트 방향으로 이동" }, { u:'D', v:'G', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 라운지 입구 방향으로 이동" },
        { u:'E', v:'H', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 면세점 중앙 구역 방향으로 이동" }, { u:'F', v:'I', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 탑승 게이트 방향으로 이동" },
        { u:'A', v:'E', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 출국 심사대 입구 방향으로 이동" }, { u:'B', v:'D', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'F', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 푸드코트 방향으로 이동" }, { u:'E', v:'C', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 환전소 방향으로 이동" }
    ];

    const reverseConnections = [];
    ALL_CONNECTIONS.forEach(conn => {
        const reverseTurn = (conn.turn === "우회전") ? "좌회전" : (conn.turn === "좌회전") ? "우회전" : "직진";
        let reverseInstruction = conn.instruction.replace('오른쪽', '왼쪽').replace('위층', '아래층');
        if (!ALL_CONNECTIONS.some(r => r.u === conn.v && r.v === conn.u)) {
            reverseConnections.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/방향으로 이동/g, '방향으로 돌아가기') });
        }
    });
    ALL_CONNECTIONS.push(...reverseConnections);
    const TURN_ICONS = { '직진':'arrow-up', '우회전':'corner-down-right', '좌회전':'corner-down-left', '도착':'map-pin' };

    // 전역 상태 변수
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let movementTimer = null; // GPS 대신 사용할 타이머
    let userGpsPosition = null; // GPS 대신 가상 위치를 저장
    let userGpsHeading = 0; 
    let deviceOrientationAlpha = 0;

    const DISTANCE_THRESHOLD = 50; // 근접 기준 (미터)
    const SIMULATION_SPEED_MPS = 1.0; // 시뮬레이션 이동 속도: 1.0 m/s (3.6 km/h)
    const SIMULATION_INTERVAL_MS = 200; // 위치 업데이트 간격 (0.2초)

    // 상수 for 위경도 이동 계산 (Haversine 역산)
    // 1미터당 위도, 경도 변화량 (서울 기준 근사치)
    const METERS_PER_DEGREE_LAT = 110574; // 위도 1도당 미터
    const METERS_PER_DEGREE_LON = 88760; // 경도 1도당 미터 (37도 기준)

    // DOM 요소 캐싱
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction');

    // 맵 경계
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat); mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon); mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // -------------------------
    // 유틸리티 함수
    // -------------------------
    function calculateDistance(lat1, lon1, lat2, lon2) { /* Haversine 공식 */
        const R = 6371e3; const φ1 = lat1 * Math.PI/180; const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180; const Δλ = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(Δφ/2)*Math.sin(Δφ/2) + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c;
    }

    function latLonToCanvas(lat, lon) { /* 위경도 to 픽셀 변환 */
        const latRange = (mapBounds.maxLat - mapBounds.minLat) || 0.0000001; const lonRange = (mapBounds.maxLon - mapBounds.minLon) || 0.0000001;
        const padding = 0.08; const drawWidth = canvas.width * (1 - 2*padding); const drawHeight = canvas.height * (1 - 2*padding);
        const offsetX = canvas.width * padding; const offsetY = canvas.height * padding;
        const x = ((lon - mapBounds.minLon) / lonRange) * drawWidth + offsetX;
        const y = drawHeight - (((lat - mapBounds.minLat) / latRange) * drawHeight) + offsetY;
        return { x, y };
    }

    // -------------------------
    // 장치 방향 및 가상 이동 로직
    // -------------------------
    
    /** 장치 방향(Device Orientation) 변경 시 호출되는 핸들러 */
    function handleDeviceOrientation(event) {
        let alpha = event.alpha;
        if (alpha !== null) {
            deviceOrientationAlpha = alpha;
            if (isNavigating) {
                // 부채꼴을 휴대폰이 향하는 방향(방위각)으로 설정합니다.
                userGpsHeading = deviceOrientationAlpha; 
                drawMap(); 
            }
        }
    }

    // 이벤트 리스너를 추가합니다.
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
    } else {
        console.warn("DeviceOrientationEvent가 지원되지 않습니다.");
    }

    /** 가상 이동 시뮬레이션 시작 */
    function startMovementSimulation() {
        if (movementTimer) clearInterval(movementTimer);
        // 타이머를 설정하여 SIMULATION_INTERVAL_MS마다 가상 위치 업데이트
        movementTimer = setInterval(updateVirtualPosition, SIMULATION_INTERVAL_MS);
        updateGpsStatus("ok", "가상 이동 시뮬레이션 시작됨.");
    }
    
    /** 가상 이동 시뮬레이션 중지 */
    function stopMovementSimulation() {
        if (movementTimer) { clearInterval(movementTimer); movementTimer = null; }
        updateGpsStatus("error", "가상 이동 시뮬레이션 중지됨.");
    }

    /** 가상 위치 업데이트 로직 */
    function updateVirtualPosition() {
        if (!userGpsPosition || !isNavigating) return;

        // 1. 이동 거리 계산 (거리 = 속도 * 시간)
        const distanceMeters = SIMULATION_SPEED_MPS * (SIMULATION_INTERVAL_MS / 1000);
        
        // 2. 현재 방향(Heading)을 라디안으로 변환 (북쪽 0도, 시계 방향)
        // Note: 웹의 DeviceOrientation Alpha는 북쪽 기준 시계방향 0~360도입니다.
        const heading = userGpsHeading;
        const headingRad = heading * Math.PI / 180;
        
        // 3. 위도/경도 변화량 계산
        // 위도 변화 (Cos: 북/남 방향)
        // 웹 DeviceOrientation의 Alpha (0=N, 90=E, 180=S, 270=W)는 수학적 좌표계(0=E, 90=N)와 다릅니다.
        // COS(0) = 1 (북쪽), SIN(0) = 0 (동쪽)
        const dLat = (distanceMeters * Math.cos(headingRad)) / METERS_PER_DEGREE_LAT;
        const dLon = (distanceMeters * Math.sin(headingRad)) / METERS_PER_DEGREE_LON;
        
        // 4. 새 위치 업데이트
        userGpsPosition.lat += dLat;
        userGpsPosition.lon += dLon;

        // 5. 내비게이션 상태 업데이트 및 맵 다시 그리기
        updateNavigationState(userGpsPosition);
        drawMap();
    }

    /** 내비게이션 상태 업데이트 (이전 updateGpsPosition을 대체) */
    function updateNavigationState(currentVirtualPos) {
        if (!lastRouteData || !lastRouteData.steps || currentStepIndex >= lastRouteData.steps.length) return;
        const currentStep = lastRouteData.steps[currentStepIndex];
        const targetAreaId = currentStep.to_area;
        const targetGps = AREA_COORDINATES[targetAreaId];
        if (!targetGps) return;

        const distanceToTarget = calculateDistance(currentVirtualPos.lat, currentVirtualPos.lon, targetGps.lat, targetGps.lon);

        updateNavigationBar(currentStep, distanceToTarget);
        highlightStep(currentStepIndex);

        if (distanceToTarget < DISTANCE_THRESHOLD) {
            currentStepIndex++;
            if (currentStepIndex >= lastRouteData.steps.length) { handleArrival(); return; }
            const nextStep = lastRouteData.steps[currentStepIndex];
            updateNavigationBar(nextStep, calculateDistance(currentVirtualPos.lat, currentVirtualPos.lon, AREA_COORDINATES[nextStep.to_area].lat, AREA_COORDINATES[nextStep.to_area].lon));
        }
    }
    

    /** 내비게이션 시작/중지/재설정 */
    function startNavigation() {
        if (isNavigating) return;
        isNavigating = true;
        navControlButton.innerText = '가상 내비 중지'; 
        navControlButton.classList.remove('bg-green-500'); navControlButton.classList.add('bg-yellow-500');
        
        // **가상 이동 시뮬레이션 시작**
        startMovementSimulation();

        if (lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            updateNavigationBar(lastRouteData.steps[currentStepIndex], 0); highlightStep(currentStepIndex);
        }
    }
    function stopNavigation() {
        isNavigating = false;
        navControlButton.innerText = '가상 내비 재개';
        navControlButton.classList.remove('bg-yellow-500'); navControlButton.classList.add('bg-green-500');
        stopMovementSimulation();
    }
    
    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === '경로 재설정') { resetApp(); return; }
        if (isNavigating) stopNavigation(); else startNavigation();
    }
    
    // -------------------------
    // 경로 검색 및 UI 렌더링
    // -------------------------

    /** Dijkstra 알고리즘으로 최적 경로 검색 (시간 기준) */
    function findOptimalRoute(startNode, endNode) {
        const distances = {}; const previousNodes = {}; const pq = new Set();
        AREA_IDS.forEach(id => { distances[id] = Infinity; previousNodes[id] = null; });
        distances[startNode] = 0; pq.add(startNode);

        const getMin = () => { let min=Infinity, node=null; pq.forEach(n=>{ if(distances[n]<min){min=distances[n]; node=n;} }); return node; };

        while (pq.size>0) {
            const node = getMin();
            if (!node) break;
            pq.delete(node);
            if (node === endNode) break;
            const neighbors = ALL_CONNECTIONS.filter(c=>c.u===node);
            for (const nb of neighbors) {
                const next = nb.v; const newT = distances[node] + nb.time;
                if (newT < distances[next]) { distances[next] = newT; previousNodes[next] = node; pq.add(next); }
            }
        }
        
        let path = []; let cur = endNode;
        while (cur) {
            path.unshift(cur);
            cur = previousNodes[cur];
            if (cur === startNode) { path.unshift(startNode); break; }
            if (!cur) break;
        }

        if (path.length===0 || path[0]!==startNode || path[path.length-1]!==endNode) return { total_time_min: Infinity, optimal_path_areas: [] };
        return { total_time_min: distances[endNode], optimal_path_areas: path };
    }
    
    /** 경로 상세 지침 생성 */
    function createRouteGuidance(optimalPath, totalTime) {
        if (!optimalPath || optimalPath.length < 2) return { steps: [], total_distance_m: 0, total_time_min: 0 };
        const steps = []; let totalDistance = 0;
        for (let i=0;i<optimalPath.length-1;i++) {
            const from = optimalPath[i], to = optimalPath[i+1];
            const conn = ALL_CONNECTIONS.find(c=>c.u===from && c.v===to);
            if (!conn) continue;
            totalDistance += conn.distance;
            const isLast = (i===optimalPath.length-2);
            const turnType = isLast ? "도착" : conn.turn;
            const timeDisplay = (conn.time).toFixed(1); 
            const instruction = isLast ? `최종 목적지인 ${AREA_NAMES[to]}에 도착했습니다. 경로 안내를 종료합니다.` : `${conn.instruction} 후 ${AREA_NAMES[to]} 방향으로 이동합니다.`;
            steps.push({ step_id: i+1, from_area: from, to_area: to, distance_m: conn.distance, travel_time_min: conn.time, travel_time_display: timeDisplay, turn_type: turnType, detailed_instruction: instruction });
        }
        return { steps, total_distance_m: totalDistance, total_time_min: totalTime };
    }

    /** 경로 검색 시작 및 내비게이션 준비 */
    function startRouteGuidance() {
        if (isNavigating) stopNavigation();
        const startId = startSelect.value; const endId = endSelect.value;
        if (startId === endId) { outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg text-yellow-700">출발지와 도착지가 동일합니다.</div>`; navBar.classList.remove('active'); return; }
        searchButton.disabled = true; searchButton.innerText = '경로 계산 중...';

        // **시작 시 가상 위치를 출발지 좌표로 설정**
        userGpsPosition = { lat: AREA_COORDINATES[startId].lat, lon: AREA_COORDINATES[startId].lon, accuracy: 10 };

        // --- iOS 13+ 권한 요청 로직 (오류 처리 강화) ---
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        // 권한이 부여되면 경로 검색 및 내비게이션 진행
                        performRouteSearchAndStartNav(startId, endId);
                    } else {
                        alert("휴대폰 방향 정보를 사용하려면 센서 접근 권한을 허용해야 합니다. 설정에서 권한을 확인해 주세요.");
                        searchButton.disabled = false; searchButton.innerText = '경로 검색 및 내비게이션 준비'; navBar.classList.remove('active');
                    }
                })
                .catch(error => {
                    // 권한 요청 API가 존재하지만 실행 중 오류가 발생한 경우 (민감한 부분)
                    console.error("권한 요청 중 오류 발생 (예외 처리):", error.name, error.message);
                    alert("센서 권한 요청 실패. Safari 설정을 확인하거나 페이지를 새로고침하여 재시도해주세요.");
                    searchButton.disabled = false; searchButton.innerText = '경로 검색 및 내비게이션 준비'; navBar.classList.remove('active');
                });
        } else {
            // 권한 요청 API를 지원하지 않는 브라우저 (구형 iOS 또는 Android 등)는 바로 진행
            console.log("DeviceOrientationEvent.requestPermission API를 지원하지 않으므로 바로 내비게이션 시작.");
            performRouteSearchAndStartNav(startId, endId);
        }
    }

    /** 실제 경로 검색 및 내비게이션 시작 로직 */
    function performRouteSearchAndStartNav(startId, endId) {
        const { total_time_min, optimal_path_areas } = findOptimalRoute(startId, endId);

        if (total_time_min === Infinity) { 
            outputDiv.innerHTML = `<div class="p-4 bg-red-100 rounded-lg text-red-700">경로를 찾을 수 없습니다!</div>`; 
            searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비'; navBar.classList.remove('active'); return;
        }
        
        const { steps, total_distance_m } = createRouteGuidance(optimal_path_areas, total_time_min);
        const totalTimeDisplay = Math.ceil(total_time_min); 
        lastRouteData = { start_area_id: startId, end_area_id: endId, optimal_path_areas: optimal_path_areas, total_time_min: totalTimeDisplay, total_distance_m: total_distance_m, steps: steps };
        currentStepIndex = 0;
        
        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();
        
        navBar.classList.add('active');
        navControlButton.innerText = '가상 내비 중지'; navControlButton.disabled = false; navControlButton.classList.remove('bg-green-500','bg-blue-600','bg-yellow-500'); navControlButton.classList.add('bg-yellow-500');
        searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비';
        
        startNavigation(); // 자동 시작
    }


    // -------------------------
    // 맵 드로잉 및 UI 업데이트
    // -------------------------

    function drawMap() { 
        resizeCanvas();
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const data = lastRouteData || {};
        const optimalPath = data.optimal_path_areas || [];

        // 배경 연결선
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 2;
        ALL_CONNECTIONS.forEach(conn => {
            const s = latLonToCanvas(AREA_COORDINATES[conn.u].lat, AREA_COORDINATES[conn.u].lon);
            const e = latLonToCanvas(AREA_COORDINATES[conn.v].lat, AREA_COORDINATES[conn.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        });

        // 최적 경로
        if (optimalPath.length > 1) {
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 5; ctx.lineCap = 'round';
            ctx.beginPath();
            let first = true;
            for (const id of optimalPath) {
                const c = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if (first) { ctx.moveTo(c.x,c.y); first = false; } else ctx.lineTo(c.x,c.y);
            }
            ctx.stroke();
        }

        // 사용자 위치 (노란색 원, 시야각 부채꼴)
        if (isNavigating && userGpsPosition) {
            const user = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);
            const accuracyRadius = 25; 
            const userRadius = 10;
            const fieldOfViewAngle = 60; 

            // 1. 진행 방향 시야각 (부채꼴) - 파란색 계열
            const headingRad = userGpsHeading * Math.PI / 180;
            const startAngle = headingRad - (fieldOfViewAngle * Math.PI / 180 / 2);
            const endAngle = headingRad + (fieldOfViewAngle * Math.PI / 180 / 2);

            ctx.beginPath();
            ctx.moveTo(user.x, user.y);
            ctx.arc(user.x, user.y, accuracyRadius * 1.5, startAngle, endAngle);
            ctx.closePath();
            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; 
            ctx.fill();

            // 2. 사용자 위치 원 (노란색, 확대된 크기)
            ctx.beginPath();
            ctx.arc(user.x, user.y, userRadius, 0, Math.PI * 2); 
            ctx.fillStyle = '#facc15'; 
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();

            // 목표까지 점선
            if (lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) {
                const targetId = lastRouteData.steps[currentStepIndex].to_area;
                const t = latLonToCanvas(AREA_COORDINATES[targetId].lat, AREA_COORDINATES[targetId].lon);
                ctx.strokeStyle = 'rgba(16,185,129,0.5)';
                ctx.setLineDash([6,6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(user.x, user.y);
                ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // 노드와 라벨
        AREA_IDS.forEach(id => {
            const coord = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isStart = lastRouteData && id === lastRouteData.start_area_id;
            const isEnd = lastRouteData && id === lastRouteData.end_area_id;
            ctx.beginPath();
            ctx.fillStyle = isStart ? '#3b82f6' : (isEnd ? '#ef4444' : '#9ca3af');
            ctx.arc(coord.x, coord.y, isStart||isEnd ? 9 : 6, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#1f2937';
            ctx.font = '12px Inter'; ctx.textAlign = 'center';
            ctx.fillText(id, coord.x, coord.y - 16);
        });
    }

    function resizeCanvas() { 
        const containerWidth = canvas.parentElement.clientWidth;
        canvas.width = Math.min(containerWidth, 900);
        canvas.height = canvas.width * (520/900);
        if (canvas.height < 300) canvas.height = 300;
    }
    function updateGpsStatus(type, message) { 
        gpsStatusMessage.textContent = `시뮬레이션 상태: ${message}`;
        gpsStatusMessage.classList.remove('gps-status-ok','gps-status-err');
        if (type === 'ok') gpsStatusMessage.classList.add('gps-status-ok'); else gpsStatusMessage.classList.add('gps-status-err');
    }
    function renderGuidanceSummary(data) { 
        const pathSummary = data.optimal_path_areas.map(id => AREA_NAMES[id]).join(' → ');
        outputDiv.innerHTML = `
            <div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg">
                <p class="text-md text-gray-700 font-semibold">
                    <span class="text-green-700">출발지: ${AREA_NAMES[data.start_area_id]}</span>
                    <span class="mx-3 text-gray-400">|</span>
                    <span class="text-red-700">최종 목적지: ${AREA_NAMES[data.end_area_id]}</span>
                </p>
                <p class="text-2xl font-extrabold text-gray-900 mt-2">
                    총 예상 소요 시간: <span class="text-blue-600">${data.total_time_min}분</span>
                    <span class="text-lg font-medium text-gray-500">(${Math.round(data.total_distance_m)}m)</span>
                </p>
                <p class="text-sm text-gray-500 mt-1 truncate">경로 요약: ${pathSummary}</p>
            </div>
        `;
        document.getElementById('nav-next-instruction').textContent = '가상 내비게이션이 시작되었습니다.';
        document.getElementById('nav-step-info').textContent = `총 거리: ${Math.round(data.total_distance_m)}m | 총 시간: ${data.total_time_min}분`;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }
    function highlightStep(index, isArrival = false) { 
        document.querySelectorAll('#steps-list > div').forEach((el, i) => {
            el.classList.remove('border-blue-600', 'bg-blue-50', 'shadow-lg');
            el.classList.add('border-gray-200', 'bg-white');
            if (i === index || (isArrival && i === index - 1)) {
                el.classList.add('border-blue-600', 'bg-blue-50', 'shadow-lg');
            }
        });
    }
    function renderStepsList(steps) { 
        let html = '';
        steps.forEach((step, idx) => {
            const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
            const iconColor = step.turn_type === '도착' ? 'text-green-600' : 'text-blue-600';
            html += `<div id="step-${idx}" class="flex items-start mb-4 p-3 bg-white rounded-lg border-l-4 border-gray-200 transition duration-100">
                    <div class="flex-shrink-0 text-2xl font-bold mr-4 p-2 rounded-full bg-gray-50 shadow ${iconColor}">
                        <i data-lucide="${iconName}" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-grow">
                        <p class="font-semibold text-md text-gray-800 leading-snug">${step.detailed_instruction}</p>
                        <p class="text-xs text-gray-500 mt-1">${AREA_NAMES[step.from_area]} → ${AREA_NAMES[step.to_area]} (${step.travel_time_display}분, ${Math.round(step.distance_m)}m)</p>
                    </div>
                </div>`;
        });
        stepsListDiv.innerHTML = html;
        stepsListDiv.classList.remove('hidden');
        lucide.createIcons();
    }

    function updateNavigationBar(step, distanceToTarget) { 
        navInstruction.textContent = step.detailed_instruction;
        const remainingTimeSeconds = distanceToTarget / SIMULATION_SPEED_MPS;
        const remainingTimeMinutes = Math.max(1, Math.ceil(remainingTimeSeconds/60)); 
        
        const accuracy = userGpsPosition && userGpsPosition.accuracy ? Math.round(userGpsPosition.accuracy) : '10';
        
        if (step.turn_type === '도착') {
            document.getElementById('nav-step-info').textContent = '목적지에 거의 도착했습니다.';
        } else {
            document.getElementById('nav-step-info').textContent = `다음 지점까지 ${Math.round(distanceToTarget)}m 남음 | 약 ${remainingTimeMinutes}분 예상 (정확도: ${accuracy}m)`;
        }
        const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${iconName}" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }

    function handleArrival() { 
        stopNavigation();
        navInstruction.textContent = `도착! ${AREA_NAMES[lastRouteData.end_area_id]}에 도착하셨습니다.`;
        document.getElementById('nav-step-info').textContent = '경로 안내가 종료되었습니다.';
        navControlButton.innerText = '경로 재설정';
        navControlButton.classList.remove('bg-yellow-500','bg-green-500'); navControlButton.classList.add('bg-blue-600');
        navControlButton.disabled = false;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="check-circle" class="w-8 h-8"></i>`;
        highlightStep(currentStepIndex, true);
        updateGpsStatus("ok","성공적으로 목적지에 도착했습니다.");
        lucide.createIcons();
    }
    
    function resetApp() { 
        stopMovementSimulation();
        lastRouteData = null; isNavigating = false; currentStepIndex = 0; userGpsPosition = null; userGpsHeading = 0;
        recalculateMapBounds();
        drawMap();
        navBar.classList.remove('active');
        loadRouteFromUrl(); 
        stepsListDiv.classList.add('hidden');
        navControlButton.innerText = 'GPS 내비 시작'; navControlButton.disabled = true;
        navControlButton.classList.remove('bg-yellow-500','bg-blue-600'); navControlButton.classList.add('bg-green-500');
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션이 초기화되었습니다. 경로를 다시 검색해 주세요.");
        lucide.createIcons();
    }
    
    function loadRouteFromUrl() { 
        const params = new URLSearchParams(window.location.search);
        const startId = params.get('start');
        
        if (startId && AREA_IDS.includes(startId.toUpperCase())) {
            const fixedStartId = startId.toUpperCase();
            startSelect.value = fixedStartId;
            outputDiv.innerHTML = `<div class="p-4 bg-blue-100 rounded-lg text-blue-700">
                <span class="font-bold">${AREA_NAMES[fixedStartId]}</span>에서 출발합니다. 최종 목적지를 선택하고 
                <span class="font-bold">'경로 검색 및 내비게이션 준비'</span> 버튼을 눌러주세요.
            </div>`;
            navBar.classList.remove('active');
        } else {
            outputDiv.innerHTML = `<p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>`;
        }
    }

    function populateAreaSelects() { 
        AREA_IDS.forEach(id => {
            const name = AREA_NAMES[id];
            startSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
            endSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
        });
        startSelect.value = 'A'; endSelect.value = 'I';
    }

    window.onload = function() {
        populateAreaSelects();
        resizeCanvas();
        loadRouteFromUrl(); 
        drawMap();
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션을 시작하려면 '경로 검색'을 누르세요.");
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        navControlButton.addEventListener('click', toggleNavigation);
    };

    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>