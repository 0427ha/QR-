<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>✈️ 공항 GPS 내비게이션 시뮬레이션 (50m 근접 기준)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; }
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        #route-map { width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:300px; }
        #navigation-bar { position: fixed; bottom:0; left:0; right:0; z-index: 50; background:#1e3a8a; color:white; box-shadow: 0 -4px 12px rgba(0,0,0,0.2); border-top-left-radius:1rem; border-top-right-radius:1rem; transform: translateY(100%); transition: transform .3s ease-in-out; padding:1rem;}
        #navigation-bar.active { transform: translateY(0); }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">✈️ 공항 터미널 GPS 내비게이션</h1>

        <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                GPS 상태: 내비게이션을 시작해야 위치 추적을 시작합니다.
            </div>

            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 설정</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">출발 구역</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">도착 구역</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                    경로 검색 및 내비게이션 준비
                </button>
            </div>
        </div>

        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 지도 시각화</h2>
            <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>

            <div id="route-guidance-output">
                <p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>
            </div>

            <div id="steps-list" class="mt-8 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-3">전체 경로 지침 미리보기:</h3>
            </div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3">
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="text-xl font-extrabold leading-snug truncate">경로를 검색해 주세요.</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5">총 거리: 0m | 총 시간: 0분</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>GPS 내비 시작</button>
    </div>

    <script>
    // -------------------------
    // 데이터 및 초기 설정
    // -------------------------
    const AREA_NAMES = {
        'A': 'A. 국제선 도착 게이트 (1층)',
        'B': 'B. 면세품 수령 데스크 (1층)',
        'C': 'C. 환전소/여행자 보험 (1층)',
        'D': 'D. 국내선 체크인 카운터 (2층)',
        'E': 'E. 출국 심사대 입구 (2층)',
        'F': 'F. 푸드코트 (2층)',
        'G': 'G. 라운지 입구 (3층 프리미엄)',
        'H': 'H. 면세점 중앙 구역 (3층)',
        'I': 'I. 탑승 게이트 (3층 장거리)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    // 3x3 가상 격자 좌표 (원본)
    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 },
        'B': { lat: 37.510000, lon: 127.051800 },
        'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 },
        'E': { lat: 37.508500, lon: 127.051800 },
        'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 },
        'H': { lat: 37.507000, lon: 127.051800 },
        'I': { lat: 37.507000, lon: 127.053600 }
    };
    let ORIGINAL_AREA_COORDINATES = JSON.parse(JSON.stringify(AREA_COORDINATES));

    const ALL_CONNECTIONS = [
        { u:'A', v:'B', distance:160, time:2, turn:"직진", instruction:"오른쪽 면세품 수령 데스크 방향으로 직진" },
        { u:'B', v:'C', distance:160, time:2, turn:"직진", instruction:"오른쪽 환전소/여행자 보험 방향으로 직진" },
        { u:'D', v:'E', distance:160, time:2, turn:"직진", instruction:"오른쪽 출국 심사대 입구 방향으로 직진" },
        { u:'E', v:'F', distance:160, time:2, turn:"직진", instruction:"오른쪽 푸드코트 방향으로 직진" },
        { u:'G', v:'H', distance:160, time:2, turn:"직진", instruction:"오른쪽 면세점 중앙 구역 방향으로 직진" },
        { u:'H', v:'I', distance:160, time:2, turn:"직진", instruction:"오른쪽 탑승 게이트 방향으로 직진" },

        { u:'A', v:'D', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'E', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 출국 심사대 입구 방향으로 이동" },
        { u:'C', v:'F', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 푸드코트 방향으로 이동" },
        { u:'D', v:'G', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 라운지 입구 방향으로 이동" },
        { u:'E', v:'H', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 면세점 중앙 구역 방향으로 이동" },
        { u:'F', v:'I', distance:170, time:2, turn:"직진", instruction:"에스컬레이터를 타고 위층 탑승 게이트 방향으로 이동" },

        { u:'A', v:'E', distance:210, time:3, turn:"우회전", instruction:"대각선으로 이동 후 출국 심사대 입구 방향으로 이동" },
        { u:'B', v:'D', distance:210, time:3, turn:"좌회전", instruction:"대각선으로 이동 후 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'F', distance:210, time:3, turn:"우회전", instruction:"대각선으로 이동 후 푸드코트 방향으로 이동" },
        { u:'E', v:'C', distance:210, time:3, turn:"좌회전", instruction:"대각선으로 이동 후 환전소 방향으로 이동" }
    ];

    // 자동으로 역방향 추가 (중복 방지)
    const reverseConnections = [];
    ALL_CONNECTIONS.forEach(conn => {
        const reverseTurn = (conn.turn === "우회전") ? "좌회전" : (conn.turn === "좌회전") ? "우회전" : "직진";
        let reverseInstruction = conn.instruction.replace('오른쪽', '왼쪽').replace('위층', '아래층');
        if (!ALL_CONNECTIONS.some(r => r.u === conn.v && r.v === conn.u)) {
            reverseConnections.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/방향으로 이동/g, '방향으로 돌아가기') });
        }
    });
    ALL_CONNECTIONS.push(...reverseConnections);

    const TURN_ICONS = { '직진':'arrow-up', '우회전':'corner-down-right', '좌회전':'corner-down-left', '도착':'map-pin' };

    // 전역 상태
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let gpsWatchId = null;
    let userGpsPosition = null;
    let userGpsHeading = 0;
    const DISTANCE_THRESHOLD = 50; // <-- 모두 50m 기준 (요청 반영)
    const AVERAGE_SPEED_MPS = 4000/3600; // 4 km/h

    // DOM
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction');

    // 맵 경계
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat);
            mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon);
            mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // 유틸리티: 거리 계산, 좌표->캔버스
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(Δφ/2)*Math.sin(Δφ/2) + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    function latLonToCanvas(lat, lon) {
        const latRange = (mapBounds.maxLat - mapBounds.minLat) || 0.0000001;
        const lonRange = (mapBounds.maxLon - mapBounds.minLon) || 0.0000001;
        const padding = 0.08;
        const drawWidth = canvas.width * (1 - 2*padding);
        const drawHeight = canvas.height * (1 - 2*padding);
        const offsetX = canvas.width * padding;
        const offsetY = canvas.height * padding;
        const x = ((lon - mapBounds.minLon) / lonRange) * drawWidth + offsetX;
        const y = drawHeight - (((lat - mapBounds.minLat) / latRange) * drawHeight) + offsetY;
        return { x, y };
    }

    // GPS 추적
    function startGpsTracking() {
        if (!navigator.geolocation) { updateGpsStatus("error","오류: 브라우저가 GPS를 지원하지 않습니다."); return; }
        if (gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = navigator.geolocation.watchPosition(handleGpsSuccess, handleGpsError, { enableHighAccuracy:true, timeout:5000, maximumAge:0 });
        updateGpsStatus("ok","GPS 추적 시작. 위치 권한을 승인하세요.");
    }
    function stopGpsTracking() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        updateGpsStatus("error","GPS 추적 중지됨.");
    }

    function handleGpsSuccess(position) {
        const { latitude, longitude, accuracy, heading } = position.coords;
        userGpsPosition = { lat: latitude, lon: longitude };
        if (heading !== null && !isNaN(heading)) userGpsHeading = heading;
        updateGpsStatus("ok", `현재 GPS 위치 수신됨. 정확도: ${Math.round(accuracy)}m`);
        if (isNavigating && lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) updateGpsPosition(userGpsPosition);
        drawMap();
    }
    function handleGpsError(error) {
        let message = "알 수 없는 GPS 오류.";
        switch (error.code) {
            case error.PERMISSION_DENIED: message = "오류: 위치 정보 접근이 거부되었습니다."; break;
            case error.POSITION_UNAVAILABLE: message = "오류: 위치 정보를 사용할 수 없습니다."; break;
            case error.TIMEOUT: message = "오류: 위치 정보 요청 시간이 초과되었습니다."; break;
        }
        updateGpsStatus("error", message);
        stopGpsTracking();
    }

    function updateGpsPosition(currentGps) {
        if (!lastRouteData || !lastRouteData.steps || currentStepIndex >= lastRouteData.steps.length) return;
        const currentStep = lastRouteData.steps[currentStepIndex];
        const targetAreaId = currentStep.to_area;
        const targetGps = AREA_COORDINATES[targetAreaId];
        if (!targetGps) return;

        // 1. 남은 거리 계산
        const distanceToTarget = calculateDistance(currentGps.lat, currentGps.lon, targetGps.lat, targetGps.lon);

        // 2. UI 업데이트
        updateNavigationBar(currentStep, distanceToTarget);
        highlightStep(currentStepIndex);

        // 3. 근접성 (50m 기준)
        if (distanceToTarget < DISTANCE_THRESHOLD) {
            currentStepIndex++;
            if (currentStepIndex >= lastRouteData.steps.length) { handleArrival(); return; }
            const nextStep = lastRouteData.steps[currentStepIndex];
            updateNavigationBar(nextStep, calculateDistance(currentGps.lat, currentGps.lon, AREA_COORDINATES[nextStep.to_area].lat, AREA_COORDINATES[nextStep.to_area].lon));
        }
    }

    // 맵 드로잉: 노선, 사용자, 방향 표시(개선)
    function resizeCanvas() {
        const containerWidth = canvas.parentElement.clientWidth;
        canvas.width = Math.min(containerWidth, 900);
        canvas.height = canvas.width * (520/900);
        if (canvas.height < 300) canvas.height = 300;
    }

    function drawMap() {
        resizeCanvas();
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const data = lastRouteData || {};
        const optimalPath = data.optimal_path_areas || [];

        // 배경 연결선
        ctx.strokeStyle = '#e5e7eb';
        ctx.lineWidth = 2;
        ALL_CONNECTIONS.forEach(conn => {
            const s = latLonToCanvas(AREA_COORDINATES[conn.u].lat, AREA_COORDINATES[conn.u].lon);
            const e = latLonToCanvas(AREA_COORDINATES[conn.v].lat, AREA_COORDINATES[conn.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        });

        // 최적 경로
        if (optimalPath.length > 1) {
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            let first = true;
            for (const id of optimalPath) {
                const c = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if (first) { ctx.moveTo(c.x,c.y); first = false; } else ctx.lineTo(c.x,c.y);
            }
            ctx.stroke();
        }

        // 사용자 위치 및 방향 (개선된 표시)
        if (isNavigating && userGpsPosition) {
            const user = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);

            // 1) 시야 콘 (부채꼴)
            ctx.save();
            ctx.translate(user.x, user.y);
            const rotation = (userGpsHeading || 0) * (Math.PI/180);
            ctx.rotate(rotation);
            ctx.beginPath();
            const coneRadius = 80; // 시야 길이 (픽셀)
            const coneAngle = 0.6; // +-0.3 rad ~ 약 34도
            ctx.moveTo(0,0);
            ctx.arc(0,0, coneRadius, -coneAngle/2, coneAngle/2);
            ctx.closePath();
            ctx.fillStyle = 'rgba(59,130,246,0.18)';
            ctx.fill();
            ctx.restore();

            // 2) 앞쪽 가이드 라인 (짙은 파란색)
            ctx.save();
            ctx.translate(user.x,user.y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(0,0);
            ctx.lineTo(0, -60); // 앞으로 60px
            ctx.strokeStyle = '#1e40af';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.stroke();
            ctx.restore();

            // 3) 큰 파란 화살표 (삼각형)
            ctx.save();
            ctx.translate(user.x, user.y);
            ctx.rotate(rotation);
            const arrowSize = 24; // 크게
            ctx.fillStyle = '#2563eb';
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -arrowSize);
            ctx.lineTo(-arrowSize*0.8, arrowSize*0.6);
            ctx.lineTo(arrowSize*0.8, arrowSize*0.6);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();

            // 목표까지 점선
            if (lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) {
                const targetId = lastRouteData.steps[currentStepIndex].to_area;
                const t = latLonToCanvas(AREA_COORDINATES[targetId].lat, AREA_COORDINATES[targetId].lon);
                ctx.strokeStyle = 'rgba(16,185,129,0.5)';
                ctx.setLineDash([6,6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(user.x, user.y);
                ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // 노드와 라벨
        AREA_IDS.forEach(id => {
            const coord = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isStart = lastRouteData && id === lastRouteData.start_area_id;
            const isEnd = lastRouteData && id === lastRouteData.end_area_id;
            ctx.beginPath();
            ctx.fillStyle = isStart ? '#3b82f6' : (isEnd ? '#ef4444' : '#9ca3af');
            ctx.arc(coord.x, coord.y, isStart||isEnd ? 9 : 6, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#1f2937';
            ctx.font = '12px Inter';
            ctx.textAlign = 'center';
            ctx.fillText(id, coord.x, coord.y - 16);
        });
    }

    // Dijkstra (경로탐색)
    function findOptimalRoute(startNode, endNode) {
        const distances = {}; const previousNodes = {}; const pq = new Set();
        AREA_IDS.forEach(id => { distances[id] = Infinity; previousNodes[id] = null; });
        distances[startNode] = 0; pq.add(startNode);

        const getMin = () => { let min=Infinity, node=null; pq.forEach(n=>{ if(distances[n]<min){min=distances[n]; node=n;} }); return node; };

        while (pq.size>0) {
            const node = getMin();
            if (!node) break;
            pq.delete(node);
            if (node === endNode) break;
            const neighbors = ALL_CONNECTIONS.filter(c=>c.u===node);
            for (const nb of neighbors) {
                const next = nb.v; const newT = distances[node] + nb.time;
                if (newT < distances[next]) { distances[next] = newT; previousNodes[next] = node; pq.add(next); }
            }
        }

        let path = []; let cur = endNode;
        while (cur) {
            path.unshift(cur);
            cur = previousNodes[cur];
            if (cur === startNode) { path.unshift(startNode); break; }
            if (!cur) break;
        }

        if (path.length===0 || path[0]!==startNode || path[path.length-1]!==endNode) return { total_time_min: Infinity, optimal_path_areas: [] };
        return { total_time_min: distances[endNode], optimal_path_areas: path };
    }

    function createRouteGuidance(optimalPath, totalTime) {
        if (!optimalPath || optimalPath.length < 2) return { steps: [], total_distance_m: 0, total_time_min: 0 };
        const steps = []; let totalDistance = 0;
        for (let i=0;i<optimalPath.length-1;i++) {
            const from = optimalPath[i], to = optimalPath[i+1];
            const conn = ALL_CONNECTIONS.find(c=>c.u===from && c.v===to);
            if (!conn) continue;
            totalDistance += conn.distance;
            const isLast = (i===optimalPath.length-2);
            const turnType = isLast ? "도착" : conn.turn;
            const instruction = isLast ? `최종 목적지인 ${AREA_NAMES[to]}에 도착했습니다. 경로 안내를 종료합니다.` : `${conn.instruction} 후 ${AREA_NAMES[to]} 방향으로 이동합니다.`;
            steps.push({ step_id: i+1, from_area: from, to_area: to, distance_m: conn.distance, travel_time_min: conn.time, turn_type: turnType, detailed_instruction: instruction });
        }
        return { steps, total_distance_m: totalDistance, total_time_min: totalTime };
    }

    // 맵 오프셋 (사용자 위치 기준으로 가상 맵 이동)
    function applyGpsOffsetToMap(currentLat, currentLon) {
        const startAreaId = lastRouteData ? lastRouteData.start_area_id : null;
        if (!startAreaId) return;
        const baseLat = ORIGINAL_AREA_COORDINATES[startAreaId].lat;
        const baseLon = ORIGINAL_AREA_COORDINATES[startAreaId].lon;
        const deltaLat = currentLat - baseLat;
        const deltaLon = currentLon - baseLon;
        AREA_IDS.forEach(id => {
            AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat + deltaLat;
            AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon + deltaLon;
        });
        recalculateMapBounds();
        drawMap();
    }

    // 경로 검색 및 내비게이션 시작
    function startRouteGuidance() {
        if (isNavigating) stopNavigation();
        const startId = startSelect.value; const endId = endSelect.value;
        if (startId === endId) { outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg text-yellow-700">출발지와 도착지가 동일합니다.</div>`; navBar.classList.remove('active'); return; }
        searchButton.disabled = true; searchButton.innerText = '경로 계산 중...';
        const { total_time_min, optimal_path_areas } = findOptimalRoute(startId, endId);
        if (total_time_min === Infinity) { outputDiv.innerHTML = `<div class="p-4 bg-red-100 rounded-lg text-red-700">경로를 찾을 수 없습니다!</div>`; searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비'; navBar.classList.remove('active'); return;}
        const { steps, total_distance_m } = createRouteGuidance(optimal_path_areas, total_time_min);
        lastRouteData = { start_area_id: startId, end_area_id: endId, optimal_path_areas: optimal_path_areas, total_time_min: Math.ceil(total_time_min), total_distance_m: total_distance_m, steps: steps };
        currentStepIndex = 0;
        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();
        navBar.classList.add('active');
        navControlButton.innerText = 'GPS 내비 중지'; navControlButton.disabled = false; navControlButton.classList.remove('bg-green-500','bg-blue-600','bg-yellow-500'); navControlButton.classList.add('bg-yellow-500');
        searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비';
        // 자동 시작
        startNavigation(true);
    }

    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === '경로 재설정') { resetApp(); return; }
        if (isNavigating) stopNavigation(); else startNavigation(false);
    }

    function startNavigation(isAutoStart=false) {
        if (!navigator.geolocation) { updateGpsStatus("error","오류: 브라우저가 GPS를 지원하지 않습니다."); return; }
        if (isNavigating) return;
        isNavigating = true;
        if (!isAutoStart) { navControlButton.innerText = 'GPS 내비 중지'; navControlButton.classList.remove('bg-green-500'); navControlButton.classList.add('bg-yellow-500'); }
        // 초기 위치 한 번 얻어서 맵 오프셋 적용
        navigator.geolocation.getCurrentPosition((pos) => {
            applyGpsOffsetToMap(pos.coords.latitude, pos.coords.longitude);
            startGpsTracking();
        }, (err) => {
            updateGpsStatus("error","GPS 초기 위치 획득 실패. 기존 좌표로 내비 시작.");
            startGpsTracking();
        }, { enableHighAccuracy:true, timeout:5000, maximumAge:0 });

        if (lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            updateNavigationBar(lastRouteData.steps[currentStepIndex], 0); highlightStep(currentStepIndex);
        }
    }

    function stopNavigation() {
        isNavigating = false;
        navControlButton.innerText = 'GPS 내비 재개';
        navControlButton.classList.remove('bg-yellow-500'); navControlButton.classList.add('bg-green-500');
        stopGpsTracking();
    }

    function handleArrival() {
        stopNavigation();
        navInstruction.textContent = `도착! ${AREA_NAMES[lastRouteData.end_area_id]}에 도착하셨습니다.`;
        document.getElementById('nav-step-info').textContent = '경로 안내가 종료되었습니다.';
        navControlButton.innerText = '경로 재설정';
        navControlButton.classList.remove('bg-yellow-500','bg-green-500'); navControlButton.classList.add('bg-blue-600');
        navControlButton.disabled = false;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="check-circle" class="w-8 h-8"></i>`;
        highlightStep(currentStepIndex-1, true);
        updateGpsStatus("ok","성공적으로 목적지에 도착했습니다.");
        lucide.createIcons();
    }

    // UI 업데이트 / 렌더
    function updateGpsStatus(type, message) {
        gpsStatusMessage.textContent = `GPS 상태: ${message}`;
        gpsStatusMessage.classList.remove('gps-status-ok','gps-status-err');
        if (type === 'ok') gpsStatusMessage.classList.add('gps-status-ok'); else gpsStatusMessage.classList.add('gps-status-err');
    }

    function renderGuidanceSummary(data) {
        const pathSummary = data.optimal_path_areas.map(id => AREA_NAMES[id]).join(' → ');
        outputDiv.innerHTML = `
            <div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg">
                <p class="text-md text-gray-700 font-semibold">
                    <span class="text-green-700">출발지: ${AREA_NAMES[data.start_area_id]}</span>
                    <span class="mx-3 text-gray-400">|</span>
                    <span class="text-red-700">최종 목적지: ${AREA_NAMES[data.end_area_id]}</span>
                </p>
                <p class="text-2xl font-extrabold text-gray-900 mt-2">
                    총 예상 소요 시간: <span class="text-blue-600">${data.total_time_min}분</span>
                    <span class="text-lg font-medium text-gray-500">(${Math.round(data.total_distance_m)}m)</span>
                </p>
                <p class="text-sm text-gray-500 mt-1 truncate">경로 요약: ${pathSummary}</p>
            </div>
        `;
        document.getElementById('nav-next-instruction').textContent = 'GPS 내비게이션이 시작되었습니다.';
        document.getElementById('nav-step-info').textContent = `총 거리: ${Math.round(data.total_distance_m)}m | 총 시간: ${data.total_time_min}분`;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }

    function renderStepsList(steps) {
        let html = '';
        steps.forEach((step, idx) => {
            const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
            const iconColor = step.turn_type === '도착' ? 'text-green-600' : 'text-blue-600';
            html += `
                <div id="step-${idx}" class="flex items-start mb-4 p-3 bg-white rounded-lg border-l-4 border-gray-200 transition duration-100">
                    <div class="flex-shrink-0 text-2xl font-bold mr-4 p-2 rounded-full bg-gray-50 shadow ${iconColor}">
                        <i data-lucide="${iconName}" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-grow">
                        <p class="font-semibold text-md text-gray-800 leading-snug">${step.detailed_instruction}</p>
                        <p class="text-xs text-gray-500 mt-1">${AREA_NAMES[step.from_area]} → ${AREA_NAMES[step.to_area]} (${step.travel_time_min}분, ${Math.round(step.distance_m)}m)</p>
                    </div>
                </div>
            `;
        });
        stepsListDiv.innerHTML = html;
        stepsListDiv.classList.remove('hidden');
        lucide.createIcons();
    }

    function updateNavigationBar(step, distanceToTarget) {
        navInstruction.textContent = step.detailed_instruction;
        const remainingTimeSeconds = distanceToTarget / AVERAGE_SPEED_MPS;
        const remainingTimeMinutes = Math.max(1, Math.ceil(remainingTimeSeconds/60));
        if (step.turn_type === '도착') {
            document.getElementById('nav-step-info').textContent = '목적지에 거의 도착했습니다.';
        } else {
            document.getElementById('nav-step-info').textContent = `다음 지점까지 ${Math.round(distanceToTarget)}m 남음 | 약 ${remainingTimeMinutes}분 예상 (현재 방향: ${Math.round(userGpsHeading)}°)`;
        }
        const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${iconName}" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }

    function highlightStep(index, isFinal=false) {
        document.querySelectorAll('#steps-list > div').forEach((el,i) => {
            el.classList.remove('bg-blue-100','border-blue-500','bg-green-100','border-green-500');
            if (i === index) {
                if (isFinal) el.classList.add('bg-green-100','border-green-500'); else el.classList.add('bg-blue-100','border-blue-500');
                el.scrollIntoView({ behavior:'smooth', block:'nearest' });
            }
        });
    }

    function resetApp() {
        stopGpsTracking();
        lastRouteData = null;
        isNavigating = false;
        currentStepIndex = 0;
        userGpsPosition = null;
        userGpsHeading = 0;
        AREA_IDS.forEach(id => { AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat; AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon; });
        recalculateMapBounds();
        drawMap();
        navBar.classList.remove('active');
        outputDiv.innerHTML = `<p class="text-gray-500">지도를 시각화하기 위해 출발지 및 도착지를 설정하고 버튼을 눌러주세요.</p>`;
        stepsListDiv.classList.add('hidden');
        navControlButton.innerText = 'GPS 내비 시작';
        navControlButton.disabled = true;
        navControlButton.classList.remove('bg-yellow-500','bg-blue-600');
        navControlButton.classList.add('bg-green-500');
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션이 초기화되었습니다. 경로를 다시 검색해 주세요.");
        lucide.createIcons();
    }

    // 초기화 및 이벤트
    function populateAreaSelects() {
        AREA_IDS.forEach(id => {
            const name = AREA_NAMES[id];
            startSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
            endSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
        });
        startSelect.value = 'A';
        endSelect.value = 'I';
    }

    window.onload = function() {
        populateAreaSelects();
        resizeCanvas();
        drawMap();
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션을 시작하려면 '경로 검색'을 누르세요.");
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        navControlButton.addEventListener('click', toggleNavigation);
    };

    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>
