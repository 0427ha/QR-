<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>âœˆï¸ ê³µí•­ GPS ë‚´ë¹„ê²Œì´ì…˜ ì‹œë®¬ë ˆì´ì…˜ (ìˆ˜ë™ ì‹œì‘, ì¤Œ/íŒ¬)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; }
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        /* í„°ì¹˜ ì´ë²¤íŠ¸ì˜ ê¸°ë³¸ ë™ì‘ì„ ë§‰ì•„ í•€ì¹˜ ì¤Œì´ ìº”ë²„ìŠ¤ì—ë§Œ ì ìš©ë˜ë„ë¡ ì„¤ì • */
        #route-map { 
            width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:300px; 
            touch-action: none; /* ì¤‘ìš”: ë¸Œë¼ìš°ì € ê¸°ë³¸ ì¤Œ/ìŠ¤í¬ë¡¤ ë°©ì§€ */
        }
        #navigation-bar { position: fixed; bottom:0; left:0; right:0; z-index: 50; background:#1e3a8a; color:white; box-shadow: 0 -4px 12px rgba(0,0,0,0.2); border-top-left-radius:1rem; border-top-right-radius:1rem; transform: translateY(100%); transition: transform .3s ease-in-out; padding:1rem;}
        #navigation-bar.active { transform: translateY(0); }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">âœˆï¸ ê³µí•­ í„°ë¯¸ë„ GPS ë‚´ë¹„ê²Œì´ì…˜ (ìˆ˜ë™ ì‹œì‘, ì¤Œ/íŒ¬)</h1>

        <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ: ë‚´ë¹„ê²Œì´ì…˜ì„ ì‹œì‘í•´ì•¼ ê°€ìƒ ìœ„ì¹˜ ì¶”ì ì„ ì‹œì‘í•©ë‹ˆë‹¤.
            </div>
            <h2 class="text-xl font-bold text-gray-700 mb-4">ê²½ë¡œ ì„¤ì •</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">ì¶œë°œ êµ¬ì—­</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">ë„ì°© êµ¬ì—­</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                    ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„
                </button>
            </div>
        </div>

        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-gray-700 mb-4">ê²½ë¡œ ì§€ë„ ì‹œê°í™” (ì¤Œ/íŒ¬ ê°€ëŠ¥)</h2>
            <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>
            <div id="route-guidance-output">
                <p class="text-gray-500">ì§€ë„ë¥¼ ì‹œê°í™”í•˜ë ¤ë©´ ì¶œë°œì§€/ë„ì°©ì§€ë¥¼ ì„¤ì •í•˜ê³  ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>
            </div>
            <div id="steps-list" class="mt-8 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-3">ì „ì²´ ê²½ë¡œ ì§€ì¹¨ ë¯¸ë¦¬ë³´ê¸°:</h3>
            </div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3">
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="text-xl font-extrabold leading-snug truncate">ê²½ë¡œë¥¼ ê²€ìƒ‰í•´ ì£¼ì„¸ìš”.</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5">ì´ ê±°ë¦¬: 0m | ì´ ì‹œê°„: 0ë¶„</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>ê°€ìƒ ë‚´ë¹„ ì‹œì‘</button>
    </div>

    <script>
    // -------------------------
    // ë°ì´í„° ë° ì´ˆê¸° ì„¤ì •
    // -------------------------
    const AREA_NAMES = {
        'A': 'A. êµ­ì œì„  ë„ì°© ê²Œì´íŠ¸ (1ì¸µ)', 'B': 'B. ë©´ì„¸í’ˆ ìˆ˜ë ¹ ë°ìŠ¤í¬ (1ì¸µ)', 'C': 'C. í™˜ì „ì†Œ/ì—¬í–‰ì ë³´í—˜ (1ì¸µ)',
        'D': 'D. êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° (2ì¸µ)', 'E': 'E. ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ (2ì¸µ)', 'F': 'F. í‘¸ë“œì½”íŠ¸ (2ì¸µ)',
        'G': 'G. ë¼ìš´ì§€ ì…êµ¬ (3ì¸µ í”„ë¦¬ë¯¸ì—„)', 'H': 'H. ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ (3ì¸µ)', 'I': 'I. íƒ‘ìŠ¹ ê²Œì´íŠ¸ (3ì¸µ ì¥ê±°ë¦¬)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 }, 'B': { lat: 37.510000, lon: 127.051800 }, 'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 }, 'E': { lat: 37.508500, lon: 127.051800 }, 'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 }, 'H': { lat: 37.507000, lon: 127.051800 }, 'I': { lat: 37.507000, lon: 127.053600 }
    };
    
    // ê²½ë¡œ ì—°ê²° ì •ë³´ (ì´ì „ê³¼ ë™ì¼)
    const ALL_CONNECTIONS = [
        { u:'A', v:'B', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ë©´ì„¸í’ˆ ìˆ˜ë ¹ ë°ìŠ¤í¬ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, { u:'B', v:'C', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ í™˜ì „ì†Œ/ì—¬í–‰ì ë³´í—˜ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'D', v:'E', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, { u:'E', v:'F', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'G', v:'H', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, { u:'H', v:'I', distance:15, time:0.2, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ íƒ‘ìŠ¹ ê²Œì´íŠ¸ ë°©í–¥ìœ¼ë¡œ ì§ì§„" },
        { u:'A', v:'D', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° ë°©í–¥ìœ¼ë¡œ ì´ë™" }, { u:'B', v:'E', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'C', v:'F', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, { u:'D', v:'G', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ë¼ìš´ì§€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'E', v:'H', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ ë©´ì„¸ì  ì¤‘ì•™ êµ¬ì—­ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, { u:'F', v:'I', distance:17, time:0.3, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„°ë¥¼ íƒ€ê³  ìœ„ì¸µ íƒ‘ìŠ¹ ê²Œì´íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'A', v:'E', distance:21, time:0.4, turn:"ìš°íšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ì…êµ¬ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, { u:'B', v:'D', distance:21, time:0.4, turn:"ì¢ŒíšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ êµ­ë‚´ì„  ì²´í¬ì¸ ì¹´ìš´í„° ë°©í–¥ìœ¼ë¡œ ì´ë™" },
        { u:'B', v:'F', distance:21, time:0.4, turn:"ìš°íšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ í‘¸ë“œì½”íŠ¸ ë°©í–¥ìœ¼ë¡œ ì´ë™" }, { u:'E', v:'C', distance:21, time:0.4, turn:"ì¢ŒíšŒì „", instruction:"ëŒ€ê°ì„ ìœ¼ë¡œ ì´ë™ í›„ í™˜ì „ì†Œ ë°©í–¥ìœ¼ë¡œ ì´ë™" }
    ];

    const reverseConnections = [];
    ALL_CONNECTIONS.forEach(conn => {
        const reverseTurn = (conn.turn === "ìš°íšŒì „") ? "ì¢ŒíšŒì „" : (conn.turn === "ì¢ŒíšŒì „") ? "ìš°íšŒì „" : "ì§ì§„";
        let reverseInstruction = conn.instruction.replace('ì˜¤ë¥¸ìª½', 'ì™¼ìª½').replace('ìœ„ì¸µ', 'ì•„ë˜ì¸µ');
        if (!ALL_CONNECTIONS.some(r => r.u === conn.v && r.v === conn.u)) {
            reverseConnections.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/ë°©í–¥ìœ¼ë¡œ ì´ë™/g, 'ë°©í–¥ìœ¼ë¡œ ëŒì•„ê°€ê¸°') });
        }
    });
    ALL_CONNECTIONS.push(...reverseConnections);
    const TURN_ICONS = { 'ì§ì§„':'arrow-up', 'ìš°íšŒì „':'corner-down-right', 'ì¢ŒíšŒì „':'corner-down-left', 'ë„ì°©':'map-pin' };

    // ì „ì—­ ìƒíƒœ ë³€ìˆ˜
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let movementTimer = null; // GPS ëŒ€ì‹  ì‚¬ìš©í•  íƒ€ì´ë¨¸
    let userGpsPosition = null; // GPS ëŒ€ì‹  ê°€ìƒ ìœ„ì¹˜ë¥¼ ì €ì¥
    let userGpsHeading = 0; 
    let deviceOrientationAlpha = 0;

    // ë§µ ìƒí˜¸ì‘ìš© ìƒíƒœ ë³€ìˆ˜
    let mapScale = 1.0;          // í˜„ì¬ í™•ëŒ€/ì¶•ì†Œ ë°°ìœ¨ (1.0 = ê¸°ë³¸)
    let mapTranslateX = 0;       // Xì¶• ì´ë™ ì˜¤í”„ì…‹ (í”½ì…€)
    let mapTranslateY = 0;       // Yì¶• ì´ë™ ì˜¤í”„ì…‹ (í”½ì…€)
    let isDragging = false;      // ë§ˆìš°ìŠ¤/í„°ì¹˜ ë“œë˜ê·¸ ìƒíƒœ
    let lastMouseX, lastMouseY;  // ë§ˆì§€ë§‰ ë§ˆìš°ìŠ¤/í„°ì¹˜ ìœ„ì¹˜
    let initialTouches = [];     // í•€ì¹˜ ì¤Œì„ ìœ„í•œ ì´ˆê¸° ë‘ ì†ê°€ë½ ì¢Œí‘œ

    // ì¤Œ ë ˆë²¨ ì œí•œ ìƒìˆ˜ (ì‚¬ìš©ì ìš”ì²­: ìµœì†Œ 0.6)
    const MIN_MAP_SCALE = 0.6; 
    const MAX_MAP_SCALE = 5.0; 

    const DISTANCE_THRESHOLD = 50; // ê·¼ì ‘ ê¸°ì¤€ (ë¯¸í„°)
    const SIMULATION_SPEED_MPS = 1.0; // ì‹œë®¬ë ˆì´ì…˜ ì´ë™ ì†ë„: 1.0 m/s (3.6 km/h)
    const SIMULATION_INTERVAL_MS = 200; // ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ê°„ê²© (0.2ì´ˆ)

    // ìƒìˆ˜ for ìœ„ê²½ë„ ì´ë™ ê³„ì‚° (Haversine ì—­ì‚°)
    const METERS_PER_DEGREE_LAT = 110574; // ìœ„ë„ 1ë„ë‹¹ ë¯¸í„°
    const METERS_PER_DEGREE_LON = 88760; // ê²½ë„ 1ë„ë‹¹ ë¯¸í„° (37ë„ ê¸°ì¤€)

    // DOM ìš”ì†Œ ìºì‹±
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction');

    // ë§µ ê²½ê³„
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat); mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon); mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // -------------------------
    // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ë° ë§µ ìƒí˜¸ì‘ìš©
    // -------------------------
    function calculateDistance(lat1, lon1, lat2, lon2) { /* Haversine ê³µì‹ */
        const R = 6371e3; const Ï†1 = lat1 * Math.PI/180; const Ï†2 = lat2 * Math.PI/180;
        const Î”Ï† = (lat2-lat1) * Math.PI/180; const Î”Î» = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(Î”Ï†/2)*Math.sin(Î”Ï†/2) + Math.cos(Ï†1)*Math.cos(Ï†2)*Math.sin(Î”Î»/2)*Math.sin(Î”Î»/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); return R * c;
    }

    /** ìœ„ê²½ë„ to ìº”ë²„ìŠ¤ í”½ì…€ ë³€í™˜ (ì¤Œ/íŒ¬ ì ìš©) */
    function latLonToCanvas(lat, lon) { 
        const latRange = (mapBounds.maxLat - mapBounds.minLat) || 0.0000001;
        const lonRange = (mapBounds.maxLon - mapBounds.minLon) || 0.0000001;
        const padding = 0.08;
        
        const baseDrawWidth = canvas.width * (1 - 2 * padding);
        const baseDrawHeight = canvas.height * (1 - 2 * padding);
        const offsetX = canvas.width * padding;
        const offsetY = canvas.height * padding;

        // 1. ê¸°ë³¸ ìº”ë²„ìŠ¤ ì¢Œí‘œ ê³„ì‚° (Scale 1.0 ê¸°ì¤€)
        let x = ((lon - mapBounds.minLon) / lonRange) * baseDrawWidth + offsetX;
        let y = baseDrawHeight - (((lat - mapBounds.minLat) / latRange) * baseDrawHeight) + offsetY;

        // 2. ìº”ë²„ìŠ¤ ì¤‘ì•™ì„ ê¸°ì¤€ìœ¼ë¡œ í™•ëŒ€/ì¶•ì†Œ ì ìš©
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;

        x = centerX + (x - centerX) * mapScale;
        y = centerY + (y - centerY) * mapScale;
        
        // 3. ì´ë™ ì˜¤í”„ì…‹(Pan) ì ìš©
        x += mapTranslateX;
        y += mapTranslateY;

        return { x, y };
    }

    function setupMapInteractions() {
        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('wheel', handleWheel, { passive: false }); 
        
        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
        canvas.addEventListener('touchend', handleTouchEnd);
        canvas.addEventListener('touchcancel', handleTouchEnd);
        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    }

    // ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ì´ì „ê³¼ ë™ì¼)
    function handleMouseDown(e) { isDragging = true; lastMouseX = e.clientX; lastMouseY = e.clientY; }
    function handleMouseUp(e) { isDragging = false; }
    function handleMouseMove(e) {
        if (!isDragging) return;
        const dx = e.clientX - lastMouseX;
        const dy = e.clientY - lastMouseY;
        
        mapTranslateX += dx;
        mapTranslateY += dy;

        lastMouseX = e.clientX;
        lastMouseY = e.clientY;
        
        drawMap();
    }
    // íœ  ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ìµœì†Œ ìŠ¤ì¼€ì¼ 0.6 ì ìš©)
    function handleWheel(e) {
        e.preventDefault(); 
        const scaleFactor = 1.1; 
        
        if (e.deltaY < 0) { mapScale *= scaleFactor; } else { mapScale /= scaleFactor; }
        
        mapScale = Math.max(MIN_MAP_SCALE, Math.min(MAX_MAP_SCALE, mapScale));
        drawMap();
    }

    // í„°ì¹˜ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ìµœì†Œ ìŠ¤ì¼€ì¼ 0.6 ì ìš©)
    function getDistance(t1, t2) { return Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY); }

    function handleTouchStart(e) {
        e.preventDefault(); 
        initialTouches = Array.from(e.touches);
        
        if (initialTouches.length === 1) { 
            isDragging = true;
            lastMouseX = initialTouches[0].clientX;
            lastMouseY = initialTouches[0].clientY;
        }
    }

    function handleTouchEnd(e) {
        isDragging = false;
        initialTouches = Array.from(e.touches); 
    }

    function handleTouchMove(e) {
        e.preventDefault();

        const currentTouches = Array.from(e.touches);

        if (currentTouches.length === 1 && isDragging) { // í•œ ì†ê°€ë½ ë“œë˜ê·¸ (íŒ¬)
            const dx = currentTouches[0].clientX - lastMouseX;
            const dy = currentTouches[0].clientY - lastMouseY;
            
            mapTranslateX += dx;
            mapTranslateY += dy;
            
            lastMouseX = currentTouches[0].clientX;
            lastMouseY = currentTouches[0].clientY;
            
            drawMap();
        } else if (currentTouches.length === 2 && initialTouches.length === 2) { // ë‘ ì†ê°€ë½ í•€ì¹˜ ì¤Œ
            const initialDistance = getDistance(initialTouches[0], initialTouches[1]);
            const currentDistance = getDistance(currentTouches[0], currentTouches[1]);

            if (initialDistance === 0) return;

            const scaleChange = currentDistance / initialDistance;
            mapScale *= scaleChange;
            
            mapScale = Math.max(MIN_MAP_SCALE, Math.min(MAX_MAP_SCALE, mapScale));
            
            initialTouches = currentTouches; 
            
            drawMap();
        }
    }


    // -------------------------
    // ì¥ì¹˜ ë°©í–¥ ë° ìˆ˜ë™ ì‹œë®¬ë ˆì´ì…˜ ì´ë™ ë¡œì§
    // -------------------------
    
    /** ì¥ì¹˜ ë°©í–¥(Device Orientation) ë³€ê²½ ì‹œ í˜¸ì¶œë˜ëŠ” í•¸ë“¤ëŸ¬ */
    function handleDeviceOrientation(event) {
        let alpha = event.alpha;
        if (alpha !== null) {
            deviceOrientationAlpha = alpha;
            if (isNavigating) {
                // ë‚´ë¹„ê²Œì´ì…˜ ì¤‘ì¼ ë•Œë§Œ ë””ë°”ì´ìŠ¤ ë°©í–¥ì„ ì§„í–‰ ë°©í–¥ìœ¼ë¡œ ì‚¬ìš©
                userGpsHeading = deviceOrientationAlpha; 
                drawMap(); 
            }
        }
    }

    // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
    } else {
        console.warn("DeviceOrientationEventê°€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    }

    /** ê°€ìƒ ì´ë™ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ (setInterval) */
    function startMovementSimulation() {
        if (movementTimer) clearInterval(movementTimer);
        // ì´ íƒ€ì´ë¨¸ê°€ 0.2ì´ˆë§ˆë‹¤ userGpsPositionì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
        movementTimer = setInterval(updateVirtualPosition, SIMULATION_INTERVAL_MS);
        updateGpsStatus("ok", "ê°€ìƒ ì´ë™ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ë¨.");
    }
    
    /** ê°€ìƒ ì´ë™ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì§€ */
    function stopMovementSimulation() {
        if (movementTimer) { clearInterval(movementTimer); movementTimer = null; }
        updateGpsStatus("error", "ê°€ìƒ ì´ë™ ì‹œë®¬ë ˆì´ì…˜ ì¤‘ì§€ë¨. 'ê°€ìƒ ë‚´ë¹„ ì‹œì‘'ì„ ëˆŒëŸ¬ ì¬ê°œí•˜ì„¸ìš”.");
    }

    /** ê°€ìƒ ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ë¡œì§ */
    function updateVirtualPosition() {
        if (!userGpsPosition || !isNavigating) return;

        const distanceMeters = SIMULATION_SPEED_MPS * (SIMULATION_INTERVAL_MS / 1000);
        const heading = userGpsHeading;
        const headingRad = heading * Math.PI / 180;
        
        const dLat = (distanceMeters * Math.cos(headingRad)) / METERS_PER_DEGREE_LAT;
        const dLon = (distanceMeters * Math.sin(headingRad)) / METERS_PER_DEGREE_LON;
        
        userGpsPosition.lat += dLat;
        userGpsPosition.lon += dLon;

        updateNavigationState(userGpsPosition);
        drawMap();
    }

    /** ë‚´ë¹„ê²Œì´ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ì´ì „ê³¼ ë™ì¼) */
    function updateNavigationState(currentVirtualPos) {
        if (!lastRouteData || !lastRouteData.steps || currentStepIndex >= lastRouteData.steps.length) return;
        const currentStep = lastRouteData.steps[currentStepIndex];
        const targetGps = AREA_COORDINATES[currentStep.to_area];

        const distanceToTarget = calculateDistance(currentVirtualPos.lat, currentVirtualPos.lon, targetGps.lat, targetGps.lon);

        updateNavigationBar(currentStep, distanceToTarget);
        highlightStep(currentStepIndex);

        if (distanceToTarget < DISTANCE_THRESHOLD) {
            currentStepIndex++;
            if (currentStepIndex >= lastRouteData.steps.length) { handleArrival(); return; }
            const nextStep = lastRouteData.steps[currentStepIndex];
            updateNavigationBar(nextStep, calculateDistance(currentVirtualPos.lat, currentVirtualPos.lon, AREA_COORDINATES[nextStep.to_area].lat, AREA_COORDINATES[nextStep.to_area].lon));
        }
    }
    

    /** ë‚´ë¹„ê²Œì´ì…˜ ì‹œì‘/ì¤‘ì§€/í† ê¸€ */
    function startNavigation() {
        if (isNavigating) return;
        isNavigating = true;
        navControlButton.innerText = 'ê°€ìƒ ë‚´ë¹„ ì¤‘ì§€'; 
        navControlButton.classList.remove('bg-green-500'); navControlButton.classList.add('bg-yellow-500');
        
        // ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œë§Œ ì´ë™ ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘!
        startMovementSimulation(); 

        if (lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            updateNavigationBar(lastRouteData.steps[currentStepIndex], 0); highlightStep(currentStepIndex);
        }
    }
    function stopNavigation() {
        isNavigating = false;
        navControlButton.innerText = 'ê°€ìƒ ë‚´ë¹„ ì¬ê°œ';
        navControlButton.classList.remove('bg-yellow-500'); navControlButton.classList.add('bg-green-500');
        stopMovementSimulation();
    }
    
    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === 'ê²½ë¡œ ì¬ì„¤ì •') { resetApp(); return; }
        if (isNavigating) stopNavigation(); else startNavigation();
    }
    
    // -------------------------
    // ê²½ë¡œ ê²€ìƒ‰ ë° UI ë Œë”ë§
    // -------------------------

    function findOptimalRoute(startNode, endNode) { /* ... (Dijkstra êµ¬í˜„) ... */
        const distances = {}; const previousNodes = {}; const pq = new Set();
        AREA_IDS.forEach(id => { distances[id] = Infinity; previousNodes[id] = null; });
        distances[startNode] = 0; pq.add(startNode);

        const getMin = () => { let min=Infinity, node=null; pq.forEach(n=>{ if(distances[n]<min){min=distances[n]; node=n;} }); return node; };

        while (pq.size>0) {
            const node = getMin();
            if (!node) break;
            pq.delete(node);
            if (node === endNode) break;
            const neighbors = ALL_CONNECTIONS.filter(c=>c.u===node);
            for (const nb of neighbors) {
                const next = nb.v; const newT = distances[node] + nb.time;
                if (newT < distances[next]) { distances[next] = newT; previousNodes[next] = node; pq.add(next); }
            }
        }
        
        let path = []; let cur = endNode;
        while (cur) {
            path.unshift(cur);
            cur = previousNodes[cur];
            if (cur === startNode) { path.unshift(startNode); break; }
            if (!cur) break;
        }

        if (path.length===0 || path[0]!==startNode || path[path.length-1]!==endNode) return { total_time_min: Infinity, optimal_path_areas: [] };
        return { total_time_min: distances[endNode], optimal_path_areas: path };
    }
    
    function createRouteGuidance(optimalPath, totalTime) { /* ... (ê²½ë¡œ ì§€ì¹¨ ìƒì„± êµ¬í˜„) ... */
        if (!optimalPath || optimalPath.length < 2) return { steps: [], total_distance_m: 0, total_time_min: 0 };
        const steps = []; let totalDistance = 0;
        for (let i=0;i<optimalPath.length-1;i++) {
            const from = optimalPath[i], to = optimalPath[i+1];
            const conn = ALL_CONNECTIONS.find(c=>c.u===from && c.v===to);
            if (!conn) continue;
            totalDistance += conn.distance;
            const isLast = (i===optimalPath.length-2);
            const turnType = isLast ? "ë„ì°©" : conn.turn;
            const timeDisplay = (conn.time).toFixed(1); 
            const instruction = isLast ? `ìµœì¢… ëª©ì ì§€ì¸ ${AREA_NAMES[to]}ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤. ê²½ë¡œ ì•ˆë‚´ë¥¼ ì¢…ë£Œí•©ë‹ˆë‹¤.` : `${conn.instruction} í›„ ${AREA_NAMES[to]} ë°©í–¥ìœ¼ë¡œ ì´ë™í•©ë‹ˆë‹¤.`;
            steps.push({ step_id: i+1, from_area: from, to_area: to, distance_m: conn.distance, travel_time_min: conn.time, travel_time_display: timeDisplay, turn_type: turnType, detailed_instruction: instruction });
        }
        return { steps, total_distance_m: totalDistance, total_time_min: totalTime };
    }

    /** ê²½ë¡œ ê²€ìƒ‰ ì‹œì‘ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„ */
    function startRouteGuidance() {
        if (isNavigating) stopNavigation();
        const startId = startSelect.value; const endId = endSelect.value;
        if (startId === endId) { outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg text-yellow-700">ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ë™ì¼í•©ë‹ˆë‹¤.</div>`; navBar.classList.remove('active'); return; }
        searchButton.disabled = true; searchButton.innerText = 'ê²½ë¡œ ê³„ì‚° ì¤‘...';

        // ì‚¬ìš©ì ê°€ìƒ ìœ„ì¹˜ë¥¼ ì¶œë°œ ì§€ì ì— ê³ ì •
        userGpsPosition = { lat: AREA_COORDINATES[startId].lat, lon: AREA_COORDINATES[startId].lon, accuracy: 10 };
        userGpsHeading = 0; // ì´ˆê¸° ë°©í–¥ ê³ ì • (ë¶ìª½)

        // --- iOS 13+ ê¶Œí•œ ìš”ì²­ ë¡œì§ (ì´ì „ê³¼ ë™ì¼) ---
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        performRouteSearchAndStartNav(startId, endId);
                    } else {
                        alert("íœ´ëŒ€í° ë°©í–¥ ì •ë³´ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ì„¼ì„œ ì ‘ê·¼ ê¶Œí•œì„ í—ˆìš©í•´ì•¼ í•©ë‹ˆë‹¤. ì„¤ì •ì—ì„œ ê¶Œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.");
                        searchButton.disabled = false; searchButton.innerText = 'ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„'; navBar.classList.remove('active');
                    }
                })
                .catch(error => {
                    console.error("ê¶Œí•œ ìš”ì²­ ì¤‘ ì˜¤ë¥˜ ë°œìƒ (ì˜ˆì™¸ ì²˜ë¦¬):", error.name, error.message);
                    alert("ì„¼ì„œ ê¶Œí•œ ìš”ì²­ ì‹¤íŒ¨. Safari ì„¤ì •ì„ í™•ì¸í•˜ê±°ë‚˜ í˜ì´ì§€ë¥¼ ìƒˆë¡œê³ ì¹¨í•˜ì—¬ ì¬ì‹œë„í•´ì£¼ì„¸ìš”.");
                    searchButton.disabled = false; searchButton.innerText = 'ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„'; navBar.classList.remove('active');
                });
        } else {
            console.log("DeviceOrientationEvent.requestPermission APIë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë°”ë¡œ ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„.");
            performRouteSearchAndStartNav(startId, endId);
        }
    }

    /** ì‹¤ì œ ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„ ë¡œì§ ğŸŒŸ ìˆ˜ì •ëœ ë¶€ë¶„ ğŸŒŸ */
    function performRouteSearchAndStartNav(startId, endId) {
        const { total_time_min, optimal_path_areas } = findOptimalRoute(startId, endId);

        if (total_time_min === Infinity) { 
            outputDiv.innerHTML = `<div class="p-4 bg-red-100 rounded-lg text-red-700">ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!</div>`; 
            searchButton.disabled=false; searchButton.innerText='ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„'; navBar.classList.remove('active'); return;
        }
        
        const { steps, total_distance_m } = createRouteGuidance(optimal_path_areas, total_time_min);
        const totalTimeDisplay = Math.ceil(total_time_min); 
        lastRouteData = { start_area_id: startId, end_area_id: endId, optimal_path_areas: optimal_path_areas, total_time_min: totalTimeDisplay, total_distance_m: total_distance_m, steps: steps };
        currentStepIndex = 0;
        
        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();
        
        // ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„ ìƒíƒœ (ë²„íŠ¼ì€ 'ì‹œì‘' ìƒíƒœë¡œ ëŒ€ê¸°)
        navBar.classList.add('active');
        navControlButton.innerText = 'ê°€ìƒ ë‚´ë¹„ ì‹œì‘'; 
        navControlButton.disabled = false; 
        navControlButton.classList.remove('bg-yellow-500','bg-blue-600'); 
        navControlButton.classList.add('bg-green-500');
        searchButton.disabled=false; searchButton.innerText='ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„';
        
        // ìë™ ì‹œì‘ì„ ì œê±°í–ˆìŠµë‹ˆë‹¤.
        updateGpsStatus("ok","ê²½ë¡œ ì¤€ë¹„ ì™„ë£Œ. 'ê°€ìƒ ë‚´ë¹„ ì‹œì‘' ë²„íŠ¼ì„ ëˆŒëŸ¬ ì´ë™ì„ ì‹œì‘í•˜ì„¸ìš”.");
    }


    // -------------------------
    // ë§µ ë“œë¡œì‰ ë° UI ì—…ë°ì´íŠ¸ (ì´ì „ê³¼ ë™ì¼)
    // -------------------------

    function drawMap() { 
        resizeCanvas();
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const data = lastRouteData || {};
        const optimalPath = data.optimal_path_areas || [];

        // ë°°ê²½ ì—°ê²°ì„ 
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 2;
        ALL_CONNECTIONS.forEach(conn => {
            const s = latLonToCanvas(AREA_COORDINATES[conn.u].lat, AREA_COORDINATES[conn.u].lon);
            const e = latLonToCanvas(AREA_COORDINATES[conn.v].lat, AREA_COORDINATES[conn.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        });

        // ìµœì  ê²½ë¡œ
        if (optimalPath.length > 1) {
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 5 * mapScale; ctx.lineCap = 'round';
            ctx.beginPath();
            let first = true;
            for (const id of optimalPath) {
                const c = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if (first) { ctx.moveTo(c.x,c.y); first = false; } else ctx.lineTo(c.x,c.y);
            }
            ctx.stroke();
        }

        // ì‚¬ìš©ì ìœ„ì¹˜ (ë…¸ë€ìƒ‰ ì›, ì‹œì•¼ê° ë¶€ì±„ê¼´)
        if (userGpsPosition) { // ë‚´ë¹„ê²Œì´ì…˜ ì¤‘ì´ ì•„ë‹ˆë”ë¼ë„ ìœ„ì¹˜ëŠ” í‘œì‹œ
            const user = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);
            const accuracyRadius = 25 * mapScale; 
            const userRadius = 10 * mapScale;
            const fieldOfViewAngle = 60; 

            // 1. ì§„í–‰ ë°©í–¥ ì‹œì•¼ê° (ë¶€ì±„ê¼´) - ë‚´ë¹„ ì¤‘ì¼ ë•Œë§Œ í‘œì‹œ
            if(isNavigating) {
                const headingRad = userGpsHeading * Math.PI / 180;
                const startAngle = headingRad - (fieldOfViewAngle * Math.PI / 180 / 2);
                const endAngle = headingRad + (fieldOfViewAngle * Math.PI / 180 / 2);

                ctx.beginPath();
                ctx.moveTo(user.x, user.y);
                ctx.arc(user.x, user.y, accuracyRadius * 1.5, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; 
                ctx.fill();
            }

            // 2. ì‚¬ìš©ì ìœ„ì¹˜ ì›
            ctx.beginPath();
            ctx.arc(user.x, user.y, userRadius, 0, Math.PI * 2); 
            ctx.fillStyle = '#facc15'; 
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();

            // ëª©í‘œê¹Œì§€ ì ì„  (ë‚´ë¹„ ì¤‘ì¼ ë•Œë§Œ í‘œì‹œ)
            if (isNavigating && lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) {
                const targetId = lastRouteData.steps[currentStepIndex].to_area;
                const t = latLonToCanvas(AREA_COORDINATES[targetId].lat, AREA_COORDINATES[targetId].lon);
                ctx.strokeStyle = 'rgba(16,185,129,0.5)';
                ctx.setLineDash([6*mapScale,6*mapScale]); 
                ctx.lineWidth = 2 * mapScale;
                ctx.beginPath();
                ctx.moveTo(user.x, user.y);
                ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // ë…¸ë“œì™€ ë¼ë²¨
        AREA_IDS.forEach(id => {
            const coord = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isStart = lastRouteData && id === lastRouteData.start_area_id;
            const isEnd = lastRouteData && id === lastRouteData.end_area_id;
            ctx.beginPath();
            ctx.fillStyle = isStart ? '#3b82f6' : (isEnd ? '#ef4444' : '#9ca3af');
            ctx.arc(coord.x, coord.y, (isStart||isEnd ? 9 : 6) * mapScale, 0, Math.PI*2); 
            ctx.fill();
            ctx.fillStyle = '#1f2937';
            ctx.font = `${12 * mapScale}px Inter`; ctx.textAlign = 'center';
            ctx.fillText(id, coord.x, coord.y - 16 * mapScale); 
        });
    }

    function resizeCanvas() { 
        const containerWidth = canvas.parentElement.clientWidth;
        canvas.width = Math.min(containerWidth, 900);
        canvas.height = canvas.width * (520/900);
        if (canvas.height < 300) canvas.height = 300;
    }
    function updateGpsStatus(type, message) { /* ... (ìƒëµ) ... */
        gpsStatusMessage.textContent = `ì‹œë®¬ë ˆì´ì…˜ ìƒíƒœ: ${message}`;
        gpsStatusMessage.classList.remove('gps-status-ok','gps-status-err');
        if (type === 'ok') gpsStatusMessage.classList.add('gps-status-ok'); else gpsStatusMessage.classList.add('gps-status-err');
    }
    function renderGuidanceSummary(data) { /* ... (ìƒëµ) ... */
        const pathSummary = data.optimal_path_areas.map(id => AREA_NAMES[id]).join(' â†’ ');
        outputDiv.innerHTML = `
            <div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg">
                <p class="text-md text-gray-700 font-semibold">
                    <span class="text-green-700">ì¶œë°œì§€: ${AREA_NAMES[data.start_area_id]}</span>
                    <span class="mx-3 text-gray-400">|</span>
                    <span class="text-red-700">ìµœì¢… ëª©ì ì§€: ${AREA_NAMES[data.end_area_id]}</span>
                </p>
                <p class="text-2xl font-extrabold text-gray-900 mt-2">
                    ì´ ì˜ˆìƒ ì†Œìš” ì‹œê°„: <span class="text-blue-600">${data.total_time_min}ë¶„</span>
                    <span class="text-lg font-medium text-gray-500">(${Math.round(data.total_distance_m)}m)</span>
                </p>
                <p class="text-sm text-gray-500 mt-1 truncate">ê²½ë¡œ ìš”ì•½: ${pathSummary}</p>
            </div>
        `;
        document.getElementById('nav-next-instruction').textContent = 'ë‚´ë¹„ê²Œì´ì…˜ì„ ì‹œì‘í•´ ì£¼ì„¸ìš”.';
        document.getElementById('nav-step-info').textContent = `ì´ ê±°ë¦¬: ${Math.round(data.total_distance_m)}m | ì´ ì‹œê°„: ${data.total_time_min}ë¶„`;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }
    function highlightStep(index, isArrival = false) { /* ... (ìƒëµ) ... */
        document.querySelectorAll('#steps-list > div').forEach((el, i) => {
            el.classList.remove('border-blue-600', 'bg-blue-50', 'shadow-lg');
            el.classList.add('border-gray-200', 'bg-white');
            if (i === index || (isArrival && i === index - 1)) {
                el.classList.add('border-blue-600', 'bg-blue-50', 'shadow-lg');
            }
        });
    }
    function renderStepsList(steps) { /* ... (ìƒëµ) ... */
        let html = '';
        steps.forEach((step, idx) => {
            const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['ì§ì§„'];
            const iconColor = step.turn_type === 'ë„ì°©' ? 'text-green-600' : 'text-blue-600';
            html += `<div id="step-${idx}" class="flex items-start mb-4 p-3 bg-white rounded-lg border-l-4 border-gray-200 transition duration-100">
                    <div class="flex-shrink-0 text-2xl font-bold mr-4 p-2 rounded-full bg-gray-50 shadow ${iconColor}">
                        <i data-lucide="${iconName}" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-grow">
                        <p class="font-semibold text-md text-gray-800 leading-snug">${step.detailed_instruction}</p>
                        <p class="text-xs text-gray-500 mt-1">${AREA_NAMES[step.from_area]} â†’ ${AREA_NAMES[step.to_area]} (${step.travel_time_display}ë¶„, ${Math.round(step.distance_m)}m)</p>
                    </div>
                </div>`;
        });
        stepsListDiv.innerHTML = html;
        stepsListDiv.classList.remove('hidden');
        lucide.createIcons();
    }

    function updateNavigationBar(step, distanceToTarget) { /* ... (ìƒëµ) ... */
        navInstruction.textContent = step.detailed_instruction;
        const remainingTimeSeconds = distanceToTarget / SIMULATION_SPEED_MPS;
        const remainingTimeMinutes = Math.max(1, Math.ceil(remainingTimeSeconds/60)); 
        
        const accuracy = userGpsPosition && userGpsPosition.accuracy ? Math.round(userGpsPosition.accuracy) : '10';
        
        if (step.turn_type === 'ë„ì°©') {
            document.getElementById('nav-step-info').textContent = 'ëª©ì ì§€ì— ê±°ì˜ ë„ì°©í–ˆìŠµë‹ˆë‹¤.';
        } else {
            document.getElementById('nav-step-info').textContent = `ë‹¤ìŒ ì§€ì ê¹Œì§€ ${Math.round(distanceToTarget)}m ë‚¨ìŒ | ì•½ ${remainingTimeMinutes}ë¶„ ì˜ˆìƒ (ì •í™•ë„: ${accuracy}m)`;
        }
        const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['ì§ì§„'];
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${iconName}" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }

    function handleArrival() { /* ... (ìƒëµ) ... */
        stopNavigation();
        navInstruction.textContent = `ë„ì°©! ${AREA_NAMES[lastRouteData.end_area_id]}ì— ë„ì°©í•˜ì…¨ìŠµë‹ˆë‹¤.`;
        document.getElementById('nav-step-info').textContent = 'ê²½ë¡œ ì•ˆë‚´ê°€ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
        navControlButton.innerText = 'ê²½ë¡œ ì¬ì„¤ì •';
        navControlButton.classList.remove('bg-yellow-500','bg-green-500'); navControlButton.classList.add('bg-blue-600');
        navControlButton.disabled = false;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="check-circle" class="w-8 h-8"></i>`;
        highlightStep(currentStepIndex, true);
        updateGpsStatus("ok","ì„±ê³µì ìœ¼ë¡œ ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.");
        lucide.createIcons();
    }
    
    /** ì•± ìƒíƒœ ì´ˆê¸°í™” */
    function resetApp() { 
        stopMovementSimulation();
        lastRouteData = null; isNavigating = false; currentStepIndex = 0; userGpsPosition = null; userGpsHeading = 0;
        
        // ë§µ ìƒí˜¸ì‘ìš© ì´ˆê¸°í™”
        mapScale = 1.0;
        mapTranslateX = 0;
        mapTranslateY = 0;

        recalculateMapBounds();
        drawMap();
        navBar.classList.remove('active');
        loadRouteFromUrl(); 
        stepsListDiv.classList.add('hidden');
        navControlButton.innerText = 'ê°€ìƒ ë‚´ë¹„ ì‹œì‘'; navControlButton.disabled = true;
        navControlButton.classList.remove('bg-yellow-500','bg-blue-600'); navControlButton.classList.add('bg-green-500');
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","ë‚´ë¹„ê²Œì´ì…˜ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ ë‹¤ì‹œ ê²€ìƒ‰í•´ ì£¼ì„¸ìš”.");
        lucide.createIcons();
    }
    
    function loadRouteFromUrl() { /* ... (ìƒëµ) ... */
        const params = new URLSearchParams(window.location.search);
        const startId = params.get('start');
        
        if (startId && AREA_IDS.includes(startId.toUpperCase())) {
            const fixedStartId = startId.toUpperCase();
            startSelect.value = fixedStartId;
            outputDiv.innerHTML = `<div class="p-4 bg-blue-100 rounded-lg text-blue-700">
                <span class="font-bold">${AREA_NAMES[fixedStartId]}</span>ì—ì„œ ì¶œë°œí•©ë‹ˆë‹¤. ìµœì¢… ëª©ì ì§€ë¥¼ ì„ íƒí•˜ê³  
                <span class="font-bold">'ê²½ë¡œ ê²€ìƒ‰ ë° ë‚´ë¹„ê²Œì´ì…˜ ì¤€ë¹„'</span> ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.
            </div>`;
            navBar.classList.remove('active');
        } else {
            outputDiv.innerHTML = `<p class="text-gray-500">ì§€ë„ë¥¼ ì‹œê°í™”í•˜ë ¤ë©´ ì¶œë°œì§€/ë„ì°©ì§€ë¥¼ ì„¤ì •í•˜ê³  ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.</p>`;
        }
    }

    function populateAreaSelects() { /* ... (ìƒëµ) ... */
        AREA_IDS.forEach(id => {
            const name = AREA_NAMES[id];
            startSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
            endSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
        });
        startSelect.value = 'A'; endSelect.value = 'I';
    }

    window.onload = function() {
        populateAreaSelects();
        resizeCanvas();
        loadRouteFromUrl(); 
        setupMapInteractions(); 
        drawMap();
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","ë‚´ë¹„ê²Œì´ì…˜ì„ ì‹œì‘í•˜ë ¤ë©´ 'ê²½ë¡œ ê²€ìƒ‰'ì„ ëˆ„ë¥´ì„¸ìš”.");
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        navControlButton.addEventListener('click', toggleNavigation);
    };

    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>