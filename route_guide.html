<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>공항 경로 최단 경로 시뮬레이터</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb;
            color: #1f2937;
        }
        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        .card {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            padding: 24px;
            margin-bottom: 20px;
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
        }
        .btn-primary:hover {
            background-color: #2563eb;
        }
        .btn-secondary {
            background-color: #f3f4f6;
            color: #1f2937;
            padding: 10px 20px;
            border-radius: 8px;
            font-weight: 600;
            transition: background-color 0.2s;
            border: 1px solid #d1d5db;
        }
        .btn-secondary:hover {
            background-color: #e5e7eb;
        }
        .node-map {
            position: relative;
            width: 100%;
            height: 400px;
            background-color: #e5e7eb;
            border-radius: 8px;
            margin-top: 20px;
            overflow: hidden;
        }
        .node {
            position: absolute;
            width: 50px;
            height: 50px;
            background-color: #10b981;
            color: white;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s, background-color 0.2s;
            z-index: 10;
            text-align: center;
            line-height: 1.2;
        }
        .node:hover {
            transform: scale(1.1);
        }
        .selected {
            background-color: #ef4444;
        }
        #result-display {
            border-left: 4px solid #3b82f6;
            padding-left: 16px;
        }

        /* 캔버스 스타일 */
        #airportCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 5;
        }
    </style>
</head>
<body>
    <div class="container">
        <header class="text-center mb-8">
            <h1 class="text-3xl font-bold text-gray-800">공항 최단 경로 시뮬레이터</h1>
            <p class="text-gray-500 mt-1">출발지와 도착지를 선택하고 가장 빠른 경로를 확인하세요.</p>
        </header>

        <div class="card grid grid-cols-1 md:grid-cols-4 gap-4 items-end">
            <div class="md:col-span-2">
                <label for="startNode" class="block text-sm font-medium text-gray-700 mb-1">출발 지점</label>
                <div class="flex space-x-2">
                    <select id="startNode" class="flex-grow p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                        <!-- Options will be populated by JS -->
                    </select>
                    <button id="getLocationBtn" class="btn-secondary whitespace-nowrap px-4 py-2 text-sm" title="브라우저 위치 API를 사용하여 현재 위치 가져오기">
                        내 위치
                    </button>
                </div>
            </div>
            <div>
                <label for="endNode" class="block text-sm font-medium text-gray-700 mb-1">도착 지점</label>
                <select id="endNode" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
                    <!-- Options will be populated by JS -->
                </select>
            </div>
            <div>
                <button id="findPathBtn" class="w-full btn-primary">경로 찾기</button>
            </div>
        </div>
        
        <div id="locationStatus" class="text-sm mt-3 p-2 bg-yellow-100 text-yellow-800 rounded-lg hidden"></div>

        <div class="card">
            <h2 class="text-xl font-semibold mb-3">공항 노드 지도 (클릭하여 선택 가능)</h2>
            <div class="node-map" id="nodeMap">
                <canvas id="airportCanvas"></canvas>
                <!-- Nodes will be inserted here by JS -->
            </div>
        </div>

        <div class="card">
            <h2 class="text-xl font-semibold mb-3">경로 결과</h2>
            <div id="result-display" class="min-h-[100px]">
                <p class="text-gray-500">출발지와 도착지를 선택한 후 '경로 찾기' 버튼을 눌러주세요.</p>
            </div>
        </div>
    </div>

    <script>
        // --- 1. 그래프 정의 (Graph Definition) ---
        // 공항 노드 및 노드 간의 거리(시간) 정의 (단위: 분)
        const nodes = {
            'A': { name: '출발/도착 홀', x: 100, y: 300 },
            'B': { name: '보안 검색대', x: 250, y: 300 },
            'C': { name: '면세 구역', x: 400, y: 150 },
            'D': { name: '환승 라운지', x: 550, y: 150 },
            'E': { name: '탑승 게이트', x: 700, y: 300 },
            'F': { name: '실외 주차장', x: 100, y: 100 },
            'G': { name: '버스 터미널', x: 250, y: 100 },
            'H': { name: '지하철 연결 통로', x: 700, y: 100 },
            'X': { name: '내 위치 (GPS)', x: 450, y: 300, isDynamic: true } // 동적 위치 노드 추가
        };

        // 인접 리스트: {노드: {인접 노드: 거리/시간}}
        // 예시 거리(시간) 값은 임의로 설정되었습니다. (단위: 분)
        const graph = {
            'A': { 'B': 5, 'F': 8, 'G': 10 },
            'B': { 'A': 5, 'C': 7 },
            'C': { 'B': 7, 'D': 6, 'E': 15 },
            'D': { 'C': 6, 'E': 8 },
            'E': { 'C': 15, 'D': 8, 'H': 5 },
            'F': { 'A': 8, 'G': 4 },
            'G': { 'A': 10, 'F': 4 },
            'H': { 'E': 5 },
            // 'X' 노드는 동적으로 가장 가까운 노드에 연결됩니다. 초기에는 비어 있습니다.
            'X': {} 
        };

        // --- 2. DOM 요소 및 변수 초기화 ---
        const startNodeSelect = document.getElementById('startNode');
        const endNodeSelect = document.getElementById('endNode');
        const findPathBtn = document.getElementById('findPathBtn');
        const getLocationBtn = document.getElementById('getLocationBtn');
        const resultDisplay = document.getElementById('result-display');
        const locationStatus = document.getElementById('locationStatus');
        const nodeMap = document.getElementById('nodeMap');
        const canvas = document.getElementById('airportCanvas');
        const ctx = canvas.getContext('2d');

        let selectedStart = null;
        let selectedEnd = null;
        let isLocationFetched = false;

        // 캔버스 크기 설정 (부모 요소에 맞춤)
        function resizeCanvas() {
            canvas.width = nodeMap.clientWidth;
            canvas.height = nodeMap.clientHeight;
            drawMap();
        }
        window.addEventListener('resize', resizeCanvas);

        // --- 3. 유틸리티 함수: 거리 계산 및 다익스트라 구현 ---
        
        /**
         * 유클리드 거리 계산 (두 지점의 픽셀 간 거리)
         * @param {object} pos1 - {x, y}
         * @param {object} pos2 - {x, y}
         * @returns {number} 픽셀 거리
         */
        function getPixelDistance(pos1, pos2) {
            return Math.sqrt(Math.pow(pos1.x - pos2.x, 2) + Math.pow(pos1.y - pos2.y, 2));
        }

        /**
         * 다익스트라 알고리즘을 사용하여 최단 경로를 찾습니다.
         * @param {string} startNode - 시작 노드 ID
         * @param {string} endNode - 도착 노드 ID
         * @returns {object} {distance: number, path: string[]} 최단 거리와 경로
         */
        function dijkstra(startNode, endNode) {
            const currentNodes = Object.keys(nodes).filter(id => !nodes[id].isDynamic || id === startNode);
            const distances = {};
            const previousNodes = {};
            const unvisited = new Set(currentNodes);

            for (let node of currentNodes) {
                distances[node] = Infinity;
                previousNodes[node] = null;
            }
            distances[startNode] = 0;

            while (unvisited.size > 0) {
                let minDistance = Infinity;
                let currentNode = null;

                for (let node of unvisited) {
                    if (distances[node] < minDistance) {
                        minDistance = distances[node];
                        currentNode = node;
                    }
                }

                if (currentNode === null || minDistance === Infinity) {
                    break;
                }

                unvisited.delete(currentNode);

                if (currentNode === endNode) {
                    break;
                }

                if (graph[currentNode]) {
                    for (let neighbor in graph[currentNode]) {
                        // 현재 그래프에 포함된 노드만 고려합니다.
                        if (currentNodes.includes(neighbor)) { 
                            const distance = graph[currentNode][neighbor];
                            const newDistance = distances[currentNode] + distance;

                            if (newDistance < distances[neighbor]) {
                                distances[neighbor] = newDistance;
                                previousNodes[neighbor] = currentNode;
                            }
                        }
                    }
                }
            }

            const path = [];
            let current = endNode;
            while (current) {
                path.unshift(current);
                if (current === startNode) break;
                current = previousNodes[current];
            }

            if (path[0] === startNode) {
                return {
                    distance: distances[endNode],
                    path: path
                };
            } else {
                return { distance: Infinity, path: [] };
            }
        }

        // --- 4. GPS 위치 기반 처리 (Geolocation API) ---

        /**
         * 브라우저의 Geolocation API를 사용하여 현재 위치를 가져오고 'X' 노드를 설정합니다.
         */
        getLocationBtn.addEventListener('click', () => {
            if (!navigator.geolocation) {
                updateLocationStatus('error', '죄송합니다. 브라우저가 위치 정보 기능을 지원하지 않습니다.', 5000);
                return;
            }

            updateLocationStatus('info', '위치 정보를 가져오는 중...', 0);
            getLocationBtn.disabled = true;

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    // 실제 GPS 위치를 지도상의 특정 노드(예: 'A')로 근사하여 시뮬레이션 목적의 좌표를 설정합니다.
                    // 실제 앱이라면 GPS 좌표를 내부 지도 좌표계로 변환해야 합니다.
                    const mockX = nodes.A.x + (Math.random() - 0.5) * 50;
                    const mockY = nodes.A.y + (Math.random() - 0.5) * 50;

                    // 'X' 노드 위치 업데이트 (시뮬레이션 위치)
                    nodes.X.x = mockX;
                    nodes.X.y = mockY;
                    
                    // 'X' 노드를 가장 가까운 노드에 연결하고 가중치(거리)를 계산합니다.
                    // 여기서는 픽셀 거리를 단순화하여 시간(분)으로 변환합니다.
                    let closestNodeId = null;
                    let minPixelDistance = Infinity;
                    
                    for(const id in nodes) {
                        if (id !== 'X' && !nodes[id].isDynamic) {
                            const dist = getPixelDistance(nodes.X, nodes[id]);
                            if (dist < minPixelDistance) {
                                minPixelDistance = dist;
                                closestNodeId = id;
                            }
                        }
                    }
                    
                    // 픽셀 거리를 시간(분)으로 변환 (예: 1픽셀당 0.1분)
                    const travelTime = Math.ceil(minPixelDistance * 0.1); 
                    
                    // 'X' 노드의 연결 상태 업데이트: 가장 가까운 노드에만 연결
                    graph.X = {};
                    if (closestNodeId) {
                        graph.X[closestNodeId] = travelTime;
                        // 양방향 경로를 위해 반대쪽도 연결합니다.
                        // graph[closestNodeId]['X'] = travelTime; // 그래프가 무방향이 아닐 수 있으므로 일단 X -> closest만
                    }

                    isLocationFetched = true;
                    getLocationBtn.disabled = false;
                    
                    // 'X' 노드를 출발지로 자동 설정
                    document.getElementById(`node-X`)?.remove(); // 기존 노드 제거
                    drawHTMLNodes(); // 새 'X' 노드 포함하여 다시 그리기
                    handleAutoSelect('X');

                    updateLocationStatus('success', 
                        `내 위치(GPS)를 성공적으로 가져왔습니다. 'X' 노드가 출발지로 설정되었습니다. (가까운 노드: ${nodes[closestNodeId].name}, 이동 시간: ${travelTime}분)`, 
                        8000
                    );
                },
                (error) => {
                    getLocationBtn.disabled = false;
                    let message;
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            message = "위치 정보 권한이 거부되었습니다. 브라우저 설정을 확인해주세요.";
                            break;
                        case error.POSITION_UNAVAILABLE:
                            message = "위치 정보를 사용할 수 없습니다. (실내이거나 신호 불량)";
                            break;
                        case error.TIMEOUT:
                            message = "위치 정보 요청 시간이 초과되었습니다.";
                            break;
                        default:
                            message = "위치 정보 가져오기 오류가 발생했습니다: " + error.message;
                            break;
                    }
                    updateLocationStatus('error', message, 5000);
                },
                { enableHighAccuracy: false, timeout: 5000, maximumAge: 0 }
            );
        });

        // 위치 상태 메시지 업데이트 함수
        let statusTimeout;
        function updateLocationStatus(type, message, duration) {
            clearTimeout(statusTimeout);
            locationStatus.innerHTML = message;
            locationStatus.classList.remove('hidden', 'bg-red-100', 'bg-yellow-100', 'bg-green-100', 'text-red-800', 'text-yellow-800', 'text-green-800');
            
            if (type === 'info') {
                locationStatus.classList.add('bg-yellow-100', 'text-yellow-800');
            } else if (type === 'success') {
                locationStatus.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                locationStatus.classList.add('bg-red-100', 'text-red-800');
            } else {
                 locationStatus.classList.add('bg-gray-100', 'text-gray-800');
            }

            if (duration > 0) {
                statusTimeout = setTimeout(() => {
                    locationStatus.classList.add('hidden');
                }, duration);
            }
        }


        // --- 5. 맵 그리기 및 이벤트 처리 ---

        // 맵의 노드와 엣지를 캔버스에 그립니다.
        function drawMap(path = []) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 캔버스 지우기

            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 400;

            // 1. 엣지(경로) 그리기
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#9ca3af'; // 기본 회색

            // 모든 엣지 그리기
            for (const source in graph) {
                for (const target in graph[source]) {
                    if (!nodes[source] || !nodes[target]) continue; // 동적 노드가 없을 경우 대비
                    const sourcePos = nodes[source];
                    const targetPos = nodes[target];

                    const startX = sourcePos.x * scaleX;
                    const startY = sourcePos.y * scaleY;
                    const endX = targetPos.x * scaleX;
                    const endY = targetPos.y * scaleY;
                    
                    // 엣지 선 그리기
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();

                    // 거리(시간) 표시
                    ctx.fillStyle = '#1f2937';
                    ctx.font = '12px Inter';
                    const midX = (startX + endX) / 2;
                    const midY = (startY + endY) / 2;
                    // 엣지 레이블을 엣지 옆에 표시
                    ctx.fillText(`${graph[source][target]}분`, midX + 5, midY - 5);
                }
            }

            // 2. 최단 경로 엣지 다시 그리기 (빨간색)
            if (path.length > 1) {
                ctx.strokeStyle = '#ef4444'; // 빨간색
                ctx.lineWidth = 5;
                for (let i = 0; i < path.length - 1; i++) {
                    const source = path[i];
                    const target = path[i+1];
                    if (!nodes[source] || !nodes[target]) continue;
                    
                    const sourcePos = nodes[source];
                    const targetPos = nodes[target];

                    const startX = sourcePos.x * scaleX;
                    const startY = sourcePos.y * scaleY;
                    const endX = targetPos.x * scaleX;
                    const endY = targetPos.y * scaleY;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }
            }
        }

        // 노드 HTML 요소를 생성하고 위치를 지정합니다.
        function drawHTMLNodes() {
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 400;
            
            // 기존 노드 요소 제거
            document.querySelectorAll('.node').forEach(n => n.remove());

            for (const id in nodes) {
                const nodeData = nodes[id];
                // 'X' 노드는 위치가 설정되었거나(GPS 호출) 드롭다운에 추가되지 않는 정적 노드만 표시합니다.
                if (nodeData.isDynamic && !isLocationFetched) continue; 

                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                if (nodeData.isDynamic) {
                    nodeEl.classList.add('bg-blue-500', 'ring-4', 'ring-blue-300', 'ring-offset-2');
                } else {
                    nodeEl.classList.add('bg-green-500');
                }
                
                nodeEl.id = `node-${id}`;
                nodeEl.dataset.id = id;
                nodeEl.innerHTML = `<div>${id}</div><div class="text-xs font-normal">${nodeData.name}</div>`;
                
                // 위치 설정
                nodeEl.style.left = `${nodeData.x * scaleX - 25}px`; // x - half width
                nodeEl.style.top = `${nodeData.y * scaleY - 25}px`;  // y - half height
                
                // 이벤트 리스너 추가
                if (!nodeData.isDynamic) { // 'X' 노드는 클릭으로 선택하지 않음
                    nodeEl.addEventListener('click', handleNodeClick);
                }
                
                nodeMap.appendChild(nodeEl);
                
                // 선택 상태 업데이트
                if (id === selectedStart) {
                    nodeEl.style.backgroundColor = '#3b82f6';
                } else if (id === selectedEnd) {
                    nodeEl.style.backgroundColor = '#ef4444';
                }
            }
        }

        // 노드 클릭 핸들러
        function handleNodeClick(event) {
            const nodeId = event.currentTarget.dataset.id;
            
            // 모든 선택 상태 초기화
            document.querySelectorAll('.node').forEach(n => {
                if (nodes[n.dataset.id].isDynamic) {
                     n.style.backgroundColor = '#3b82f6';
                } else {
                     n.style.backgroundColor = '#10b981';
                }
            });

            if (nodeId === selectedStart) {
                selectedStart = null;
                startNodeSelect.value = '';
            } else if (nodeId === selectedEnd) {
                selectedEnd = null;
                endNodeSelect.value = '';
            } else if (!selectedStart) {
                selectedStart = nodeId;
                event.currentTarget.style.backgroundColor = '#3b82f6'; 
                startNodeSelect.value = nodeId;
            } else if (!selectedEnd) {
                selectedEnd = nodeId;
                event.currentTarget.style.backgroundColor = '#ef4444'; 
                endNodeSelect.value = nodeId;
            } else {
                // 모두 선택된 상태에서 새로운 출발지 선택
                selectedStart = nodeId;
                selectedEnd = null;
                event.currentTarget.style.backgroundColor = '#3b82f6';
                startNodeSelect.value = nodeId;
                endNodeSelect.value = '';
            }
            drawMap(); 
        }

        // 자동 선택 핸들러 (GPS로 'X' 노드 선택 시)
        function handleAutoSelect(nodeId) {
            // 기존 선택 해제
            selectedStart = null;
            selectedEnd = null;
            document.querySelectorAll('.node').forEach(n => {
                if (nodes[n.dataset.id].isDynamic) {
                     n.style.backgroundColor = '#3b82f6'; // X 노드는 파란색 유지
                } else {
                     n.style.backgroundColor = '#10b981';
                }
            });

            // 'X' 노드를 출발지로 설정
            selectedStart = nodeId;
            startNodeSelect.innerHTML = populateDropdownOptions(nodeId); // 'X' 포함하여 업데이트
            startNodeSelect.value = nodeId;
            document.getElementById(`node-${nodeId}`).style.backgroundColor = '#3b82f6';

            endNodeSelect.value = '';
            drawMap();
        }

        // --- 6. UI 초기화 및 이벤트 리스너 설정 ---

        // 드롭다운 메뉴 옵션을 채웁니다.
        function populateDropdownOptions(selectedId = '') {
            let optionsHTML = '<option value="" disabled ' + (selectedId ? '' : 'selected') + '>선택하세요</option>';
            for (const id in nodes) {
                if (!nodes[id].isDynamic || id === 'X') { // 'X' 노드는 GPS 호출 시에만 표시
                    optionsHTML += `<option value="${id}" ${id === selectedId ? 'selected' : ''}>${id}: ${nodes[id].name}</option>`;
                }
            }
            return optionsHTML;
        }

        function populateDropdowns() {
            startNodeSelect.innerHTML = populateDropdownOptions(selectedStart);
            endNodeSelect.innerHTML = populateDropdownOptions(selectedEnd);
        }

        // 드롭다운 변경 시 노드 선택 상태 업데이트
        function handleDropdownChange(event) {
            
            // 모든 노드 선택 해제 및 기본 색상 복원
            document.querySelectorAll('.node').forEach(n => {
                if (nodes[n.dataset.id].isDynamic) {
                     n.style.backgroundColor = '#3b82f6';
                } else {
                     n.style.backgroundColor = '#10b981';
                }
            });
            
            selectedStart = startNodeSelect.value || null;
            selectedEnd = endNodeSelect.value || null;

            // 새로운 선택 상태에 따라 UI 업데이트
            if (selectedStart) {
                const startEl = document.getElementById(`node-${selectedStart}`);
                if (startEl) startEl.style.backgroundColor = '#3b82f6';
            }
            if (selectedEnd) {
                const endEl = document.getElementById(`node-${selectedEnd}`);
                if (endEl) endEl.style.backgroundColor = '#ef4444';
            }

            drawMap(); // 맵 다시 그리기
        }
        
        startNodeSelect.addEventListener('change', handleDropdownChange);
        endNodeSelect.addEventListener('change', handleDropdownChange);


        // 경로 찾기 버튼 클릭 핸들러
        findPathBtn.addEventListener('click', () => {
            const start = startNodeSelect.value;
            const end = endNodeSelect.value;

            if (!start || !end) {
                resultDisplay.innerHTML = '<p class="text-red-500 font-semibold">출발 지점과 도착 지점을 모두 선택해주세요.</p>';
                return;
            }

            if (start === end) {
                resultDisplay.innerHTML = '<p class="text-red-500 font-semibold">출발 지점과 도착 지점은 달라야 합니다.</p>';
                return;
            }

            const result = dijkstra(start, end);

            if (result.distance === Infinity) {
                resultDisplay.innerHTML = `
                    <p class="text-lg font-semibold text-red-600">경로를 찾을 수 없습니다.</p>
                    <p class="text-gray-600">선택하신 두 지점 사이에는 연결된 경로가 없습니다.</p>
                `;
                drawMap([]); // 경로 없는 맵 그리기
            } else {
                const pathText = result.path.map(id => `${id} (${nodes[id].name})`).join(' → ');
                
                resultDisplay.innerHTML = `
                    <h3 class="text-lg font-bold text-blue-600 mb-2">최단 경로 발견!</h3>
                    <p class="text-gray-700"><strong>총 소요 시간:</strong> <span class="text-2xl font-extrabold text-red-500">${result.distance}분</span></p>
                    <p class="mt-2"><strong>경로:</strong> ${pathText}</p>
                `;
                drawMap(result.path); // 최단 경로를 강조하여 맵 그리기
            }
        });

        // 초기 실행
        window.onload = function() {
            populateDropdowns();
            resizeCanvas(); // 캔버스 크기 조정 및 초기 맵 그리기
            drawHTMLNodes(); // 노드 HTML 요소 생성
        };

    </script>
</body>
</html>