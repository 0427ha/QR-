<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>✈️ 공항 GPS 내비게이션 시뮬레이션 (50m 근접 기준)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; }
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        /* 맵 스타일 */
        #route-map { width:100%; height:auto; border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); min-height:300px; }
        /* 내비게이션 바 스타일 */
        #navigation-bar { position: fixed; bottom:0; left:0; right:0; z-index: 50; background:#1e3a8a; color:white; box-shadow: 0 -4px 12px rgba(0,0,0,0.2); border-top-left-radius:1rem; border-top-right-radius:1rem; transform: translateY(100%); transition: transform .3s ease-in-out; padding:1rem;}
        #navigation-bar.active { transform: translateY(0); }
    </style>
</head>
<body class="p-4 sm:p-8">
    <div class="container mx-auto pb-40">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">✈️ 공항 터미널 GPS 내비게이션</h1>

        <div class="card p-6 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                GPS 상태: 내비게이션을 시작해야 위치 추적을 시작합니다.
            </div>

            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 설정</h2>
            <div class="flex flex-col sm:flex-row gap-4">
                <div class="flex-1">
                    <label for="start-area" class="block text-sm font-medium text-gray-700 mb-1">출발 구역</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50"></select>
                </div>
                <div class="flex-1">
                    <label for="end-area" class="block text-sm font-medium text-gray-700 mb-1">도착 구역</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg hover:bg-blue-700 transition duration-150 shadow-md">
                    경로 검색 및 내비게이션 준비
                </button>
            </div>
        </div>

        <div class="card p-6 rounded-xl">
            <h2 class="text-xl font-bold text-gray-700 mb-4">경로 지도 시각화</h2>
            
            <canvas id="route-map" width="900" height="520" class="mb-6"></canvas>

            <div id="route-guidance-output">
                <p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>
            </div>

            <div id="steps-list" class="mt-8 hidden">
                <h3 class="text-lg font-bold text-gray-700 mb-3">전체 경로 지침 미리보기:</h3>
            </div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3">
            <div id="current-turn-icon" class="text-4xl flex-shrink-0"></div>
            <div class="flex flex-col min-w-0">
                <p id="nav-next-instruction" class="text-xl font-extrabold leading-snug truncate">경로를 검색해 주세요.</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5">총 거리: 0m | 총 시간: 0분</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition duration-150 flex-shrink-0" disabled>GPS 내비 시작</button>
    </div>

    <script>
    // -------------------------
    // 데이터 및 초기 설정
    // -------------------------
    const AREA_NAMES = {
        'A': 'A. 국제선 도착 게이트 (1층)',
        'B': 'B. 면세품 수령 데스크 (1층)',
        'C': 'C. 환전소/여행자 보험 (1층)',
        'D': 'D. 국내선 체크인 카운터 (2층)',
        'E': 'E. 출국 심사대 입구 (2층)',
        'F': 'F. 푸드코트 (2층)',
        'G': 'G. 라운지 입구 (3층 프리미엄)',
        'H': 'H. 면세점 중앙 구역 (3층)',
        'I': 'I. 탑승 게이트 (3층 장거리)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    // 3x3 가상 격자 좌표 (원본)
    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 },
        'B': { lat: 37.510000, lon: 127.051800 },
        'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 },
        'E': { lat: 37.508500, lon: 127.051800 },
        'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 },
        'H': { lat: 37.507000, lon: 127.051800 },
        'I': { lat: 37.507000, lon: 127.053600 }
    };
    let ORIGINAL_AREA_COORDINATES = JSON.parse(JSON.stringify(AREA_COORDINATES));

    // 경로 연결 정보 (거리 단축: 약 1/10)
    const ALL_CONNECTIONS = [
        // u, v, distance(m), time(min), turn, instruction (경로 가이드)
        { u:'A', v:'B', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세품 수령 데스크 방향으로 직진" },
        { u:'B', v:'C', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 환전소/여행자 보험 방향으로 직진" },
        { u:'D', v:'E', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 출국 심사대 입구 방향으로 직진" },
        { u:'E', v:'F', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 푸드코트 방향으로 직진" },
        { u:'G', v:'H', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 면세점 중앙 구역 방향으로 직진" },
        { u:'H', v:'I', distance:15, time:0.2, turn:"직진", instruction:"오른쪽 탑승 게이트 방향으로 직진" },

        { u:'A', v:'D', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'E', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 출국 심사대 입구 방향으로 이동" },
        { u:'C', v:'F', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 푸드코트 방향으로 이동" },
        { u:'D', v:'G', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 라운지 입구 방향으로 이동" },
        { u:'E', v:'H', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 면세점 중앙 구역 방향으로 이동" },
        { u:'F', v:'I', distance:17, time:0.3, turn:"직진", instruction:"에스컬레이터를 타고 위층 탑승 게이트 방향으로 이동" },

        { u:'A', v:'E', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 출국 심사대 입구 방향으로 이동" },
        { u:'B', v:'D', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 국내선 체크인 카운터 방향으로 이동" },
        { u:'B', v:'F', distance:21, time:0.4, turn:"우회전", instruction:"대각선으로 이동 후 푸드코트 방향으로 이동" },
        { u:'E', v:'C', distance:21, time:0.4, turn:"좌회전", instruction:"대각선으로 이동 후 환전소 방향으로 이동" }
    ];

    // 자동으로 역방향 추가 (중복 방지 로직 포함)
    const reverseConnections = [];
    ALL_CONNECTIONS.forEach(conn => {
        const reverseTurn = (conn.turn === "우회전") ? "좌회전" : (conn.turn === "좌회전") ? "우회전" : "직진";
        let reverseInstruction = conn.instruction.replace('오른쪽', '왼쪽').replace('위층', '아래층');
        if (!ALL_CONNECTIONS.some(r => r.u === conn.v && r.v === conn.u)) {
            reverseConnections.push({ u: conn.v, v: conn.u, distance: conn.distance, time: conn.time, turn: reverseTurn, instruction: reverseInstruction.replace(/방향으로 이동/g, '방향으로 돌아가기') });
        }
    });
    ALL_CONNECTIONS.push(...reverseConnections);

    const TURN_ICONS = { '직진':'arrow-up', '우회전':'corner-down-right', '좌회전':'corner-down-left', '도착':'map-pin' };

    // 전역 상태 변수
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let gpsWatchId = null;
    let userGpsPosition = null;
    let userGpsHeading = 0; // GPS 이동 방향 대신 장치 방향으로 사용될 예정
    let deviceOrientationAlpha = 0; // 장치 방향(Alpha) 값

    const DISTANCE_THRESHOLD = 50; // 근접 기준 (미터)
    const AVERAGE_SPEED_MPS = 4000/3600; // 4 km/h

    // DOM 요소 캐싱
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const stepsListDiv = document.getElementById('steps-list');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const navInstruction = document.getElementById('nav-next-instruction');

    // 맵 경계
    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat);
            mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon);
            mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
    }
    recalculateMapBounds();

    // -------------------------
    // 유틸리티 함수
    // -------------------------
    
    /** Haversine 공식으로 거리(m) 계산 */
    function calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2-lat1) * Math.PI/180;
        const Δλ = (lon2-lon1) * Math.PI/180;
        const a = Math.sin(Δφ/2)*Math.sin(Δφ/2) + Math.cos(φ1)*Math.cos(φ2)*Math.sin(Δλ/2)*Math.sin(Δλ/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        return R * c;
    }

    /** 위경도 좌표를 Canvas 픽셀 좌표로 변환 */
    function latLonToCanvas(lat, lon) {
        const latRange = (mapBounds.maxLat - mapBounds.minLat) || 0.0000001;
        const lonRange = (mapBounds.maxLon - mapBounds.minLon) || 0.0000001;
        const padding = 0.08;
        const drawWidth = canvas.width * (1 - 2*padding);
        const drawHeight = canvas.height * (1 - 2*padding);
        const offsetX = canvas.width * padding;
        const offsetY = canvas.height * padding;
        const x = ((lon - mapBounds.minLon) / lonRange) * drawWidth + offsetX;
        // Y축 반전
        const y = drawHeight - (((lat - mapBounds.minLat) / latRange) * drawHeight) + offsetY;
        return { x, y };
    }

    // -------------------------
    // GPS, 장치 방향 및 내비게이션 로직
    // -------------------------
    
    // **휴대폰 방향에 따른 부채꼴 회전을 위한 장치 방향 이벤트 핸들러**
    
    /** 장치 방향(Device Orientation) 변경 시 호출되는 핸들러 */
    function handleDeviceOrientation(event) {
        let alpha = event.alpha;
        
        if (alpha !== null) {
            deviceOrientationAlpha = alpha;
            
            // 내비게이션 중이라면 사용자 진행 방향(Heading)을 업데이트
            if (isNavigating) {
                // 부채꼴을 휴대폰이 향하는 방향(방위각)으로 설정합니다.
                userGpsHeading = deviceOrientationAlpha; 
                drawMap(); // 부채꼴을 즉시 다시 그립니다.
            }
        }
    }

    // 이벤트 리스너를 추가합니다.
    if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', handleDeviceOrientation, true);
    } else {
        console.warn("DeviceOrientationEvent가 지원되지 않습니다. 부채꼴 회전이 작동하지 않을 수 있습니다.");
    }


    /** GPS 위치 추적 시작 */
    function startGpsTracking() {
        if (!navigator.geolocation) { updateGpsStatus("error","오류: 브라우저가 GPS를 지원하지 않습니다."); return; }
        if (gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        gpsWatchId = navigator.geolocation.watchPosition(handleGpsSuccess, handleGpsError, { enableHighAccuracy:true, timeout:5000, maximumAge:0 });
        updateGpsStatus("ok","GPS 추적 시작. 위치 권한을 승인하세요.");
    }
    /** GPS 위치 추적 중지 */
    function stopGpsTracking() {
        if (gpsWatchId) { navigator.geolocation.clearWatch(gpsWatchId); gpsWatchId = null; }
        updateGpsStatus("error","GPS 추적 중지됨.");
    }

    /** GPS 위치 성공 시 콜백 */
    function handleGpsSuccess(position) {
        const { latitude, longitude, accuracy } = position.coords;
        userGpsPosition = { lat: latitude, lon: longitude, accuracy: accuracy };
        // GPS 이동 방향(heading) 값은 deviceorientation 이벤트가 덮어쓰므로 사용하지 않습니다.

        updateGpsStatus("ok", `현재 GPS 위치 수신됨. 정확도: ${Math.round(accuracy)}m`);
        if (isNavigating && lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) updateGpsPosition(userGpsPosition);
        drawMap();
    }
    /** GPS 위치 실패 시 콜백 */
    function handleGpsError(error) {
        let message = "알 수 없는 GPS 오류.";
        switch (error.code) {
            case error.PERMISSION_DENIED: message = "오류: 위치 정보 접근이 거부되었습니다."; break;
            case error.POSITION_UNAVAILABLE: message = "오류: 위치 정보를 사용할 수 없습니다."; break;
            case error.TIMEOUT: message = "오류: 위치 정보 요청 시간이 초과되었습니다."; break;
        }
        updateGpsStatus("error", message);
        stopGpsTracking();
    }

    /** 현재 GPS 위치를 기반으로 내비게이션 상태 업데이트 */
    function updateGpsPosition(currentGps) {
        if (!lastRouteData || !lastRouteData.steps || currentStepIndex >= lastRouteData.steps.length) return;
        const currentStep = lastRouteData.steps[currentStepIndex];
        const targetAreaId = currentStep.to_area;
        const targetGps = AREA_COORDINATES[targetAreaId];
        if (!targetGps) return;

        // 1. 남은 거리 계산
        const distanceToTarget = calculateDistance(currentGps.lat, currentGps.lon, targetGps.lat, targetGps.lon);

        // 2. UI 업데이트
        updateNavigationBar(currentStep, distanceToTarget);
        highlightStep(currentStepIndex);

        // 3. 근접성 (50m) 확인
        if (distanceToTarget < DISTANCE_THRESHOLD) {
            currentStepIndex++;
            if (currentStepIndex >= lastRouteData.steps.length) { handleArrival(); return; }
            const nextStep = lastRouteData.steps[currentStepIndex];
            updateNavigationBar(nextStep, calculateDistance(currentGps.lat, currentGps.lon, AREA_COORDINATES[nextStep.to_area].lat, AREA_COORDINATES[nextStep.to_area].lon));
        }
    }
    
    /** 맵 전체의 좌표를 사용자의 위치 기반으로 이동시키는 함수 (오프셋 적용) */
    function applyGpsOffsetToMap(currentLat, currentLon) {
        const startAreaId = lastRouteData ? lastRouteData.start_area_id : null;
        if (!startAreaId) return;
        const baseLat = ORIGINAL_AREA_COORDINATES[startAreaId].lat;
        const baseLon = ORIGINAL_AREA_COORDINATES[startAreaId].lon;
        const deltaLat = currentLat - baseLat;
        const deltaLon = currentLon - baseLon;
        AREA_IDS.forEach(id => {
            AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat + deltaLat;
            AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon + deltaLon;
        });
        recalculateMapBounds();
        drawMap();
    }

    /** 내비게이션 시작/중지/재설정 */
    function startNavigation(isAutoStart=false) {
        if (!navigator.geolocation || isNavigating) return;
        isNavigating = true;
        if (!isAutoStart) { navControlButton.innerText = 'GPS 내비 중지'; navControlButton.classList.remove('bg-green-500'); navControlButton.classList.add('bg-yellow-500'); }
        
        // 초기 위치 획득 후 맵 오프셋 적용
        navigator.geolocation.getCurrentPosition((pos) => {
            applyGpsOffsetToMap(pos.coords.latitude, pos.coords.longitude);
            startGpsTracking(); // 오프셋 적용 후 실시간 추적 시작
        }, (err) => {
            updateGpsStatus("error","GPS 초기 위치 획득 실패. 기존 좌표로 내비 시작.");
            startGpsTracking(); // 실패 시 오프셋 없이 추적 시작
        }, { enableHighAccuracy:true, timeout:5000, maximumAge:0 });

        if (lastRouteData && currentStepIndex < lastRouteData.steps.length) {
            updateNavigationBar(lastRouteData.steps[currentStepIndex], 0); highlightStep(currentStepIndex);
        }
    }
    function stopNavigation() {
        isNavigating = false;
        navControlButton.innerText = 'GPS 내비 재개';
        navControlButton.classList.remove('bg-yellow-500'); navControlButton.classList.add('bg-green-500');
        stopGpsTracking();
    }

    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === '경로 재설정') { resetApp(); return; }
        if (isNavigating) stopNavigation(); else startNavigation(false);
    }
    
    // -------------------------
    // 경로 검색 및 UI 렌더링
    // -------------------------
    
    /** Dijkstra 알고리즘으로 최적 경로 검색 (시간 기준) */
    function findOptimalRoute(startNode, endNode) {
        const distances = {}; const previousNodes = {}; const pq = new Set();
        AREA_IDS.forEach(id => { distances[id] = Infinity; previousNodes[id] = null; });
        distances[startNode] = 0; pq.add(startNode);

        const getMin = () => { let min=Infinity, node=null; pq.forEach(n=>{ if(distances[n]<min){min=distances[n]; node=n;} }); return node; };

        while (pq.size>0) {
            const node = getMin();
            if (!node) break;
            pq.delete(node);
            if (node === endNode) break;
            const neighbors = ALL_CONNECTIONS.filter(c=>c.u===node);
            for (const nb of neighbors) {
                const next = nb.v; const newT = distances[node] + nb.time;
                if (newT < distances[next]) { distances[next] = newT; previousNodes[next] = node; pq.add(next); }
            }
        }
        
        let path = []; let cur = endNode;
        while (cur) {
            path.unshift(cur);
            cur = previousNodes[cur];
            if (cur === startNode) { path.unshift(startNode); break; }
            if (!cur) break;
        }

        if (path.length===0 || path[0]!==startNode || path[path.length-1]!==endNode) return { total_time_min: Infinity, optimal_path_areas: [] };
        return { total_time_min: distances[endNode], optimal_path_areas: path };
    }
    
    /** 경로 상세 지침 생성 */
    function createRouteGuidance(optimalPath, totalTime) {
        if (!optimalPath || optimalPath.length < 2) return { steps: [], total_distance_m: 0, total_time_min: 0 };
        const steps = []; let totalDistance = 0;
        for (let i=0;i<optimalPath.length-1;i++) {
            const from = optimalPath[i], to = optimalPath[i+1];
            const conn = ALL_CONNECTIONS.find(c=>c.u===from && c.v===to);
            if (!conn) continue;
            totalDistance += conn.distance;
            const isLast = (i===optimalPath.length-2);
            const turnType = isLast ? "도착" : conn.turn;
            // 시간은 반올림하거나 올림 처리하지 않고 소수점 1자리까지 표시
            const timeDisplay = (conn.time).toFixed(1); 
            const instruction = isLast ? `최종 목적지인 ${AREA_NAMES[to]}에 도착했습니다. 경로 안내를 종료합니다.` : `${conn.instruction} 후 ${AREA_NAMES[to]} 방향으로 이동합니다.`;
            steps.push({ step_id: i+1, from_area: from, to_area: to, distance_m: conn.distance, travel_time_min: conn.time, travel_time_display: timeDisplay, turn_type: turnType, detailed_instruction: instruction });
        }
        return { steps, total_distance_m: totalDistance, total_time_min: totalTime };
    }

    /** 경로 검색 시작 및 내비게이션 준비 */
    function startRouteGuidance() {
        if (isNavigating) stopNavigation();
        const startId = startSelect.value; const endId = endSelect.value;
        if (startId === endId) { outputDiv.innerHTML = `<div class="p-4 bg-yellow-100 rounded-lg text-yellow-700">출발지와 도착지가 동일합니다.</div>`; navBar.classList.remove('active'); return; }
        searchButton.disabled = true; searchButton.innerText = '경로 계산 중...';

        // **추가된 권한 요청 로직 (iOS 13+ 대응)**
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        // 권한이 부여되면 경로 검색 및 내비게이션 진행
                        performRouteSearchAndStartNav(startId, endId);
                    } else {
                        alert("휴대폰 방향 정보를 사용하려면 센서 접근 권한을 허용해야 합니다.");
                        // 권한 거부 시 버튼 상태 복구
                        searchButton.disabled = false;
                        searchButton.innerText = '경로 검색 및 내비게이션 준비';
                        navBar.classList.remove('active');
                    }
                })
                .catch(error => {
                    console.error("권한 요청 중 오류 발생:", error);
                    alert("센서 권한 요청 중 오류가 발생했습니다. 브라우저 설정을 확인해주세요.");
                    searchButton.disabled = false;
                    searchButton.innerText = '경로 검색 및 내비게이션 준비';
                    navBar.classList.remove('active');
                });
        } else {
            // 권한 요청 API를 지원하지 않는 브라우저 (대부분 Android나 구형 iOS)는 바로 진행
            performRouteSearchAndStartNav(startId, endId);
        }
    }

    /** 실제 경로 검색 및 내비게이션 시작 로직 */
    function performRouteSearchAndStartNav(startId, endId) {
        const { total_time_min, optimal_path_areas } = findOptimalRoute(startId, endId);

        if (total_time_min === Infinity) { 
            outputDiv.innerHTML = `<div class="p-4 bg-red-100 rounded-lg text-red-700">경로를 찾을 수 없습니다!</div>`; 
            searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비'; navBar.classList.remove('active'); return;
        }
        
        const { steps, total_distance_m } = createRouteGuidance(optimal_path_areas, total_time_min);
        const totalTimeDisplay = Math.ceil(total_time_min); 
        lastRouteData = { start_area_id: startId, end_area_id: endId, optimal_path_areas: optimal_path_areas, total_time_min: totalTimeDisplay, total_distance_m: total_distance_m, steps: steps };
        currentStepIndex = 0;
        
        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData.steps);
        drawMap();
        
        navBar.classList.add('active');
        navControlButton.innerText = 'GPS 내비 중지'; navControlButton.disabled = false; navControlButton.classList.remove('bg-green-500','bg-blue-600','bg-yellow-500'); navControlButton.classList.add('bg-yellow-500');
        searchButton.disabled=false; searchButton.innerText='경로 검색 및 내비게이션 준비';
        
        startNavigation(true); // 자동 시작
    }


    // -------------------------
    // 맵 드로잉 및 UI 업데이트
    // -------------------------

    /** 맵에 구역, 경로, 사용자 위치 시각화 */
    function drawMap() {
        resizeCanvas();
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const data = lastRouteData || {};
        const optimalPath = data.optimal_path_areas || [];

        // 배경 연결선
        ctx.strokeStyle = '#e5e7eb'; ctx.lineWidth = 2;
        ALL_CONNECTIONS.forEach(conn => {
            const s = latLonToCanvas(AREA_COORDINATES[conn.u].lat, AREA_COORDINATES[conn.u].lon);
            const e = latLonToCanvas(AREA_COORDINATES[conn.v].lat, AREA_COORDINATES[conn.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(e.x, e.y); ctx.stroke();
        });

        // 최적 경로
        if (optimalPath.length > 1) {
            ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 5; ctx.lineCap = 'round';
            ctx.beginPath();
            let first = true;
            for (const id of optimalPath) {
                const c = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if (first) { ctx.moveTo(c.x,c.y); first = false; } else ctx.lineTo(c.x,c.y);
            }
            ctx.stroke();
        }

        // 사용자 위치 (노란색 원, 시야각 부채꼴 - 최종 수정 반영)
        if (isNavigating && userGpsPosition) {
            const user = latLonToCanvas(userGpsPosition.lat, userGpsPosition.lon);
            const accuracyRadius = 25; // 위치 정확도 원의 기준 반지름 (시야각 크기 결정에 사용)
            const userRadius = 10;      // 사용자 마커 반지름 (10px로 확대)
            const fieldOfViewAngle = 60; // 시야각 60도

            // 1. 진행 방향 시야각 (부채꼴) - 파란색 계열
            const headingRad = userGpsHeading * Math.PI / 180;
            const startAngle = headingRad - (fieldOfViewAngle * Math.PI / 180 / 2);
            const endAngle = headingRad + (fieldOfViewAngle * Math.PI / 180 / 2);

            ctx.beginPath();
            ctx.moveTo(user.x, user.y);
            // 부채꼴 반지름을 정확도 원 기준 크기(25px * 1.5)로 설정 (크게 유지)
            ctx.arc(user.x, user.y, accuracyRadius * 1.5, startAngle, endAngle);
            ctx.closePath();
            // 파란색 (blue-500 계열)에 투명도 20% 적용
            ctx.fillStyle = 'rgba(59, 130, 246, 0.2)'; // 파란색으로 수정
            ctx.fill();

            // 2. 사용자 위치 원 (노란색, 확대된 크기)
            ctx.beginPath();
            // 사용자 마커 반지름을 10px로 키웠습니다.
            ctx.arc(user.x, user.y, userRadius, 0, Math.PI * 2); 
            ctx.fillStyle = '#facc15'; // Tailwind yellow-400 (진한 노란색 유지)
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fill();
            ctx.stroke();

            // 목표까지 점선
            if (lastRouteData && lastRouteData.steps && currentStepIndex < lastRouteData.steps.length) {
                const targetId = lastRouteData.steps[currentStepIndex].to_area;
                const t = latLonToCanvas(AREA_COORDINATES[targetId].lat, AREA_COORDINATES[targetId].lon);
                ctx.strokeStyle = 'rgba(16,185,129,0.5)';
                ctx.setLineDash([6,6]);
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(user.x, user.y);
                ctx.lineTo(t.x, t.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // 노드와 라벨
        AREA_IDS.forEach(id => {
            const coord = latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isStart = lastRouteData && id === lastRouteData.start_area_id;
            const isEnd = lastRouteData && id === lastRouteData.end_area_id;
            ctx.beginPath();
            ctx.fillStyle = isStart ? '#3b82f6' : (isEnd ? '#ef4444' : '#9ca3af');
            ctx.arc(coord.x, coord.y, isStart||isEnd ? 9 : 6, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = '#1f2937';
            ctx.font = '12px Inter'; ctx.textAlign = 'center';
            ctx.fillText(id, coord.x, coord.y - 16);
        });
    }
    
    /** Canvas 크기 조정 */
    function resizeCanvas() {
        const containerWidth = canvas.parentElement.clientWidth;
        canvas.width = Math.min(containerWidth, 900);
        canvas.height = canvas.width * (520/900);
        if (canvas.height < 300) canvas.height = 300;
    }

    /** GPS 상태 메시지 업데이트 */
    function updateGpsStatus(type, message) {
        gpsStatusMessage.textContent = `GPS 상태: ${message}`;
        gpsStatusMessage.classList.remove('gps-status-ok','gps-status-err');
        if (type === 'ok') gpsStatusMessage.classList.add('gps-status-ok'); else gpsStatusMessage.classList.add('gps-status-err');
    }

    /** 경로 요약 정보 렌더링 */
    function renderGuidanceSummary(data) {
        const pathSummary = data.optimal_path_areas.map(id => AREA_NAMES[id]).join(' → ');
        outputDiv.innerHTML = `
            <div class="mb-4 p-4 bg-blue-50 border-b border-blue-200 rounded-lg">
                <p class="text-md text-gray-700 font-semibold">
                    <span class="text-green-700">출발지: ${AREA_NAMES[data.start_area_id]}</span>
                    <span class="mx-3 text-gray-400">|</span>
                    <span class="text-red-700">최종 목적지: ${AREA_NAMES[data.end_area_id]}</span>
                </p>
                <p class="text-2xl font-extrabold text-gray-900 mt-2">
                    총 예상 소요 시간: <span class="text-blue-600">${data.total_time_min}분</span>
                    <span class="text-lg font-medium text-gray-500">(${Math.round(data.total_distance_m)}m)</span>
                </p>
                <p class="text-sm text-gray-500 mt-1 truncate">경로 요약: ${pathSummary}</p>
            </div>
        `;
        document.getElementById('nav-next-instruction').textContent = 'GPS 내비게이션이 시작되었습니다.';
        document.getElementById('nav-step-info').textContent = `총 거리: ${Math.round(data.total_distance_m)}m | 총 시간: ${data.total_time_min}분`;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }
    
    /** 단계 하이라이트 */
    function highlightStep(index, isArrival = false) {
        document.querySelectorAll('#steps-list > div').forEach((el, i) => {
            el.classList.remove('border-blue-600', 'bg-blue-50', 'shadow-lg');
            el.classList.add('border-gray-200', 'bg-white');
            if (i === index || (isArrival && i === index - 1)) {
                el.classList.add('border-blue-600', 'bg-blue-50', 'shadow-lg');
            }
        });
    }

    /** 상세 지침 목록 렌더링 */
    function renderStepsList(steps) {
        let html = '';
        steps.forEach((step, idx) => {
            const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
            const iconColor = step.turn_type === '도착' ? 'text-green-600' : 'text-blue-600';
            html += `
                <div id="step-${idx}" class="flex items-start mb-4 p-3 bg-white rounded-lg border-l-4 border-gray-200 transition duration-100">
                    <div class="flex-shrink-0 text-2xl font-bold mr-4 p-2 rounded-full bg-gray-50 shadow ${iconColor}">
                        <i data-lucide="${iconName}" class="w-5 h-5"></i>
                    </div>
                    <div class="flex-grow">
                        <p class="font-semibold text-md text-gray-800 leading-snug">${step.detailed_instruction}</p>
                        <p class="text-xs text-gray-500 mt-1">${AREA_NAMES[step.from_area]} → ${AREA_NAMES[step.to_area]} (${step.travel_time_display}분, ${Math.round(step.distance_m)}m)</p>
                    </div>
                </div>
            `;
        });
        stepsListDiv.innerHTML = html;
        stepsListDiv.classList.remove('hidden');
        lucide.createIcons();
    }

    /** 내비게이션 바 업데이트 */
    function updateNavigationBar(step, distanceToTarget) {
        navInstruction.textContent = step.detailed_instruction;
        const remainingTimeSeconds = distanceToTarget / AVERAGE_SPEED_MPS;
        const remainingTimeMinutes = Math.max(1, Math.ceil(remainingTimeSeconds/60)); // 최소 1분으로 표시
        
        // 정확도 정보 사용
        const accuracy = userGpsPosition && userGpsPosition.accuracy ? Math.round(userGpsPosition.accuracy) : 'N/A';
        
        if (step.turn_type === '도착') {
            document.getElementById('nav-step-info').textContent = '목적지에 거의 도착했습니다.';
        } else {
            document.getElementById('nav-step-info').textContent = `다음 지점까지 ${Math.round(distanceToTarget)}m 남음 | 약 ${remainingTimeMinutes}분 예상 (정확도: ${accuracy}m)`;
        }
        const iconName = TURN_ICONS[step.turn_type] || TURN_ICONS['직진'];
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${iconName}" class="w-8 h-8"></i>`;
        lucide.createIcons();
    }

    /** 최종 도착 처리 */
    function handleArrival() {
        stopNavigation();
        navInstruction.textContent = `도착! ${AREA_NAMES[lastRouteData.end_area_id]}에 도착하셨습니다.`;
        document.getElementById('nav-step-info').textContent = '경로 안내가 종료되었습니다.';
        navControlButton.innerText = '경로 재설정';
        navControlButton.classList.remove('bg-yellow-500','bg-green-500'); navControlButton.classList.add('bg-blue-600');
        navControlButton.disabled = false;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="check-circle" class="w-8 h-8"></i>`;
        highlightStep(currentStepIndex, true);
        updateGpsStatus("ok","성공적으로 목적지에 도착했습니다.");
        lucide.createIcons();
    }
    
    /** 앱 초기화 */
    function resetApp() {
        stopGpsTracking();
        lastRouteData = null; isNavigating = false; currentStepIndex = 0; userGpsPosition = null; userGpsHeading = 0;
        // 좌표 원본으로 복원
        AREA_IDS.forEach(id => { AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat; AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon; });
        recalculateMapBounds();
        drawMap();
        navBar.classList.remove('active');
        // QR 코드로 진입했을 때의 상태로 복원하기 위해 loadRouteFromUrl()을 호출
        loadRouteFromUrl(); 
        stepsListDiv.classList.add('hidden');
        navControlButton.innerText = 'GPS 내비 시작'; navControlButton.disabled = true;
        navControlButton.classList.remove('bg-yellow-500','bg-blue-600'); navControlButton.classList.add('bg-green-500');
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션이 초기화되었습니다. 경로를 다시 검색해 주세요.");
        lucide.createIcons();
    }
    
    // ----------------------------------------------------
    // ✨ QR 코드 인식 기능 (URL 파라미터 로드)
    // ----------------------------------------------------

    /** URL 쿼리 파라미터에서 출발지 값을 읽어와 적용하는 함수 */
    function loadRouteFromUrl() {
        const params = new URLSearchParams(window.location.search);
        const startId = params.get('start');
        
        // 1. URL에 유효한 출발지 ID가 있는 경우
        if (startId && AREA_IDS.includes(startId.toUpperCase())) {
            const fixedStartId = startId.toUpperCase();
            
            // 출발지 드롭다운 값 설정
            startSelect.value = fixedStartId;
            
            // 도착지는 사용자가 선택할 수 있도록 별도로 설정하지 않고 안내만 합니다.
            outputDiv.innerHTML = `<div class="p-4 bg-blue-100 rounded-lg text-blue-700">
                <span class="font-bold">${AREA_NAMES[fixedStartId]}</span>에서 출발합니다. 최종 목적지를 선택하고 
                <span class="font-bold">'경로 검색 및 내비게이션 준비'</span> 버튼을 눌러주세요.
            </div>`;
            
            // 내비게이션 바 숨김 처리
            navBar.classList.remove('active');

        } else {
            // URL 파라미터가 없거나 유효하지 않을 경우, 초기 상태를 유지합니다.
            outputDiv.innerHTML = `<p class="text-gray-500">지도를 시각화하려면 출발지/도착지를 설정하고 버튼을 눌러주세요.</p>`;
        }
    }

    // -------------------------
    // 초기 로드
    // -------------------------

    /** 드롭다운 메뉴 초기화 */
    function populateAreaSelects() {
        AREA_IDS.forEach(id => {
            const name = AREA_NAMES[id];
            startSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
            endSelect.insertAdjacentHTML('beforeend', `<option value="${id}">${id}: ${name}</option>`);
        });
        startSelect.value = 'A'; endSelect.value = 'I';
    }

    window.onload = function() {
        populateAreaSelects();
        resizeCanvas();
        
        // URL 파라미터를 먼저 로드하여 출발지를 설정합니다.
        loadRouteFromUrl(); 

        drawMap();
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-8 h-8"></i>`;
        updateGpsStatus("error","내비게이션을 시작하려면 '경로 검색'을 누르세요.");
        lucide.createIcons();
        searchButton.addEventListener('click', startRouteGuidance);
        navControlButton.addEventListener('click', toggleNavigation);
    };

    window.addEventListener('resize', drawMap);
    </script>
</body>
</html>