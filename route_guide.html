<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
    <title>âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS (ìµœì¢… ì•ˆì •í™”)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #f4f7f9; }
        .container { max-width: 900px; padding-bottom: 150px; } 
        .card { background-color: white; box-shadow: 0 4px 12px rgba(0,0,0,0.08); }
        .gps-status-ok { background-color: #d1fae5; color: #065f46; border:1px solid #34d399; }
        .gps-status-err { background-color: #fee2e2; color: #991b1b; border:1px solid #f87171; }
        
        #route-map { 
            width:100%; 
            /* ìº”ë²„ìŠ¤ ìì²´ì˜ ìŠ¤íƒ€ì¼ ë†’ì´ë¥¼ ê³ ì •í•˜ì—¬ ëŠ˜ì–´ì§ ë°©ì§€ (JSì—ì„œ ìµœì¢… height ì¡°ì •) */
            height: 350px; 
            border:1px solid #e5e7eb; background:#fff; border-radius:.75rem; 
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.05); 
            min-height:350px; 
            touch-action: none; 
            display: block; 
        }

        /* ìƒì„¸ ê²½ë¡œ ëª©ë¡ ìŠ¤íƒ€ì¼ */
        #route-steps-list {
            margin-top: 1rem;
            border-radius: 0.5rem;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }
        .step-item {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid #f3f4f6;
            background-color: white;
            transition: background-color 0.2s;
        }
        .step-item:last-child { border-bottom: none; }
        .step-item.current {
            background-color: #fffbe9; /* ë…¸ë€ìƒ‰ ê°•ì¡° */
            border-left: 4px solid #facc15;
            font-weight: 600;
        }

        #navigation-bar { 
            position: fixed; bottom:0; left:0; right:0; z-index: 50; 
            background:#1e3a8a; color:white; 
            box-shadow: 0 -4px 12px rgba(0,0,0,0.2); 
            border-top-left-radius:1rem; border-top-right-radius:1rem; 
            transform: translateY(100%); transition: transform .3s ease-in-out; 
            padding: 0.75rem 1rem;
        }
        #navigation-bar.active { transform: translateY(0); }
        #nav-next-instruction { 
             font-size: 1.125rem;
             font-weight: 800;
             line-height: 1.3;
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
             max-width: 100%;
        }
    </style>
</head>
<body class="p-4 sm:p-6">
    <div class="container mx-auto">
        <h1 class="text-2xl sm:text-3xl font-extrabold text-gray-800 mb-6 border-b-4 border-blue-500 pb-2">âœˆï¸ ê³µí•­ ì‹¤ë‚´ GPS</h1>

        <div class="card p-5 rounded-xl mb-6">
            <div id="gps-status-message" class="p-3 mb-4 rounded-lg text-sm font-medium gps-status-err">
                ì¤€ë¹„: ê²½ë¡œë¥¼ ì„¤ì •í•˜ê³  'ì¤€ë¹„' ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.
            </div>
            <h2 class="text-lg font-bold text-gray-700 mb-3">ê²½ë¡œ ì„¤ì •</h2>
            <div class="flex flex-col sm:flex-row gap-3">
                <div class="flex-1">
                    <label class="block text-xs font-medium text-gray-500 mb-1">ì¶œë°œ</label>
                    <select id="start-area" class="w-full p-2 border border-gray-300 rounded-lg bg-gray-50 text-sm"></select>
                </div>
                <div class="flex-1">
                    <label class="block text-xs font-medium text-gray-500 mb-1">ë„ì°©</label>
                    <select id="end-area" class="w-full p-2 border border-gray-300 rounded-lg text-sm"></select>
                </div>
                <button id="search-button" onclick="startRouteGuidance()" class="sm:self-end mt-2 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 transition shadow-md whitespace-nowrap">
                    ì¤€ë¹„
                </button>
            </div>
        </div>

        <div class="card p-5 rounded-xl">
            <h2 class="text-lg font-bold text-gray-700 mb-3">ì‹¤ì‹œê°„ ì§€ë„</h2>
            <canvas id="route-map"></canvas>
            
            <div id="route-guidance-output" class="mt-4">
                <p class="text-gray-500 text-sm">ê²½ë¡œë¥¼ ì„¤ì •í•˜ë©´ ì•ˆë‚´ê°€ ì‹œì‘ë©ë‹ˆë‹¤.</p>
            </div>

            <div id="route-steps-list">
                </div>
        </div>
    </div>

    <div id="navigation-bar" class="p-4 flex items-center justify-between">
        <div class="flex items-center space-x-3 min-w-0"> 
            <div id="current-turn-icon" class="text-white flex-shrink-0"><i data-lucide="compass" class="w-7 h-7"></i></div>
            <div class="flex flex-col min-w-0 flex-grow">
                <p id="nav-next-instruction" class="truncate">ëŒ€ê¸° ì¤‘</p>
                <p id="nav-step-info" class="text-sm text-blue-200 mt-0.5 truncate">ë‚¨ì€ ê±°ë¦¬: -</p>
            </div>
        </div>
        <button id="nav-control-button" onclick="toggleNavigation()" class="px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition flex-shrink-0" disabled>
            ì‹œì‘
        </button>
    </div>

    <script>
    // --- 1. ë°ì´í„° ì •ì˜ ---
    const AREA_NAMES = {
        'A': 'A. êµ­ì œì„  ë„ì°© (1F)', 'B': 'B. ë©´ì„¸í’ˆ ìˆ˜ë ¹ (1F)', 'C': 'C. í™˜ì „ì†Œ (1F)',
        'D': 'D. ì²´í¬ì¸ ì¹´ìš´í„° (2F)', 'E': 'E. ì¶œêµ­ ì‹¬ì‚¬ëŒ€ (2F)', 'F': 'F. í‘¸ë“œì½”íŠ¸ (2F)',
        'G': 'G. ë¼ìš´ì§€ (3F)', 'H': 'H. ë©´ì„¸ì  (3F)', 'I': 'I. íƒ‘ìŠ¹êµ¬ (3F)'
    };
    const AREA_IDS = Object.keys(AREA_NAMES);

    const AREA_COORDINATES = {
        'A': { lat: 37.510000, lon: 127.050000 }, 'B': { lat: 37.510000, lon: 127.051800 }, 'C': { lat: 37.510000, lon: 127.053600 },
        'D': { lat: 37.508500, lon: 127.050000 }, 'E': { lat: 37.508500, lon: 127.051800 }, 'F': { lat: 37.508500, lon: 127.053600 },
        'G': { lat: 37.507000, lon: 127.050000 }, 'H': { lat: 37.507000, lon: 127.051800 }, 'I': { lat: 37.507000, lon: 127.053600 }
    };
    let ORIGINAL_AREA_COORDINATES = JSON.parse(JSON.stringify(AREA_COORDINATES));

    // instructionì—ì„œ ìˆœì„œ ë²ˆí˜¸(ì˜ˆ: "1. ") ì œê±°
    const CONNECTIONS_DATA = [
        { u:'A', v:'B', distance:15, turn:"ì§ì§„", instruction:"ì˜¤ë¥¸ìª½ ë©´ì„¸í’ˆ ìˆ˜ë ¹ ë°ìŠ¤í¬ ë°©í–¥ìœ¼ë¡œ ì§ì§„" }, 
        { u:'B', v:'C', distance:15, turn:"ì§ì§„", instruction:"í™˜ì „ì†Œ ë°©í–¥ ì§ì§„" },
        { u:'D', v:'E', distance:15, turn:"ì§ì§„", instruction:"ì¶œêµ­ ì‹¬ì‚¬ëŒ€ ë°©í–¥ ì§ì§„" }, 
        { u:'E', v:'F', distance:15, turn:"ì§ì§„", instruction:"í‘¸ë“œì½”íŠ¸ ë°©í–¥ ì§ì§„" },
        { u:'G', v:'H', distance:15, turn:"ì§ì§„", instruction:"ë©´ì„¸ì  ë°©í–¥ ì§ì§„" }, 
        { u:'H', v:'I', distance:15, turn:"ì§ì§„", instruction:"íƒ‘ìŠ¹êµ¬ ë°©í–¥ ì§ì§„" },
        { u:'A', v:'D', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (2ì¸µí–‰) íƒ‘ìŠ¹" }, 
        { u:'B', v:'E', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (2ì¸µí–‰) íƒ‘ìŠ¹" },
        { u:'C', v:'F', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (2ì¸µí–‰) íƒ‘ìŠ¹" },
        { u:'D', v:'G', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (3ì¸µí–‰) íƒ‘ìŠ¹" },
        { u:'E', v:'H', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (3ì¸µí–‰) íƒ‘ìŠ¹" },
        { u:'F', v:'I', distance:17, turn:"ì§ì§„", instruction:"ì—ìŠ¤ì»¬ë ˆì´í„° (3ì¸µí–‰) íƒ‘ìŠ¹" },
        { u:'A', v:'E', distance:21, turn:"ìš°íšŒì „", instruction:"ëŒ€ê°ì„  ê¸¸ì„ ë”°ë¼ ìš°íšŒì „" }, 
        { u:'E', v:'C', distance:21, turn:"ì¢ŒíšŒì „", instruction:"ëŒ€ê°ì„  ê¸¸ì„ ë”°ë¼ ì¢ŒíšŒì „" }
    ];

    const ALL_CONNECTIONS = [];
    CONNECTIONS_DATA.forEach(conn => {
        ALL_CONNECTIONS.push(conn);
        if (!CONNECTIONS_DATA.some(r => r.u === conn.v && r.v === conn.u)) {
            ALL_CONNECTIONS.push({ 
                u: conn.v, v: conn.u, 
                distance: conn.distance, 
                turn: (conn.turn === "ìš°íšŒì „") ? "ì¢ŒíšŒì „" : (conn.turn === "ì¢ŒíšŒì „") ? "ìš°íšŒì „" : "ì§ì§„", 
                instruction: conn.instruction.includes('íƒ‘ìŠ¹') ? `ë°˜ëŒ€ë°©í–¥ ${conn.instruction}` : `ë°˜ëŒ€ë°©í–¥ìœ¼ë¡œ ${conn.turn}` 
            });
        }
    });

    const TURN_ICONS = { 'ì§ì§„':'arrow-up', 'ìš°íšŒì „':'corner-down-right', 'ì¢ŒíšŒì „':'corner-down-left', 'ë„ì°©':'map-pin', 'ë°˜ëŒ€ë°©í–¥':'arrow-down' };

    // --- 2. ë³€ìˆ˜ ë° ìƒíƒœ ---
    let lastRouteData = null;
    let currentStepIndex = 0;
    let isNavigating = false;
    let gpsWatchId = null;
    
    let userPos = null; 
    let targetMapRotation = 0; 
    let currentMapRotation = 0; 
    let targetDeviceHeading = 0; 
    let currentDeviceHeading = 0; 

    // ì§€ë„ ì¡°ì‘ ë³€ìˆ˜ (í™•ëŒ€/ì¶•ì†Œ/ì´ë™(Pan))
    let mapScale = 1.0;
    let mapTranslateX = 0; let mapTranslateY = 0;
    
    // --- 3. DOM ---
    const startSelect = document.getElementById('start-area');
    const endSelect = document.getElementById('end-area');
    const outputDiv = document.getElementById('route-guidance-output');
    const searchButton = document.getElementById('search-button');
    const navBar = document.getElementById('navigation-bar');
    const navControlButton = document.getElementById('nav-control-button');
    const gpsStatusMessage = document.getElementById('gps-status-message');
    const canvas = document.getElementById('route-map');
    const ctx = canvas.getContext('2d');
    const routeStepsList = document.getElementById('route-steps-list');

    const mapBounds = { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity };

    // --- 4. í•¨ìˆ˜ ì •ì˜ ---

    // ğŸŒŸ ì§€ë„ ë¹„ìœ¨ ê³„ì‚°ì„ ìœ„í•´ ìœ„ë„/ê²½ë„ ë²”ìœ„ ê³„ì‚°
    function recalculateMapBounds() {
        mapBounds.minLat = Infinity; mapBounds.maxLat = -Infinity; mapBounds.minLon = Infinity; mapBounds.maxLon = -Infinity;
        AREA_IDS.forEach(id => {
            const c = AREA_COORDINATES[id];
            mapBounds.minLat = Math.min(mapBounds.minLat, c.lat); mapBounds.maxLat = Math.max(mapBounds.maxLat, c.lat);
            mapBounds.minLon = Math.min(mapBounds.minLon, c.lon); mapBounds.maxLon = Math.max(mapBounds.maxLon, c.lon);
        });
        
        // ì§€ë„ ë¹„ìœ¨ ì¡°ì •ì„ ìœ„í•´ resizeCanvas í˜¸ì¶œ
        resizeCanvas();
    }

    function updateGpsStatus(type, message) {
        gpsStatusMessage.textContent = message;
        gpsStatusMessage.className = `p-3 mb-4 rounded-lg text-sm font-medium ${type === 'ok' ? 'gps-status-ok' : 'gps-status-err'}`;
    }

    function startRouteGuidance() {
        const startId = startSelect.value;
        const endId = endSelect.value;
        if (startId === endId) { alert("ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ê°™ìŠµë‹ˆë‹¤."); return; }

        searchButton.disabled = true; searchButton.innerText = "ê³„ì‚° ì¤‘...";
        
        const result = calculatePath(startId, endId);
        
        if (!result.steps) {
            alert("ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            searchButton.disabled = false; searchButton.innerText = "ì¤€ë¹„";
            return;
        }

        lastRouteData = { ...result, start: startId, end: endId };
        currentStepIndex = 0;

        renderGuidanceSummary(lastRouteData);
        renderStepsList(lastRouteData);
        
        navBar.classList.add('active');
        navControlButton.innerText = "ì‹œì‘";
        navControlButton.disabled = false;
        navControlButton.className = "px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition flex-shrink-0";

        searchButton.disabled = false; searchButton.innerText = "ì¤€ë¹„";
        updateGpsStatus("ok", "ê²½ë¡œ ì„¤ì • ì™„ë£Œ. 'ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.");
        
        userPos = null; 
        drawMap();
    }

    function toggleNavigation() {
        if (!lastRouteData) return;
        if (navControlButton.innerText === 'ì¬ì„¤ì •') { location.reload(); return; }

        if (isNavigating) stopNavigation();
        else startNavigation();
    }

    // ğŸŒŸ ì‹¤ì œ GPS ê¸°ë°˜ ë‚´ë¹„ê²Œì´ì…˜ ì‹œì‘
    function startNavigation() {
        if (!navigator.geolocation) { alert("GPS ê¶Œí•œì´ í•„ìš”í•©ë‹ˆë‹¤."); return; }

        // ì§€ë„ ìƒíƒœ ì´ˆê¸°í™”
        mapScale = 1.0;
        mapTranslateX = 0;
        mapTranslateY = 0;

        isNavigating = true;
        navControlButton.innerText = "ì¤‘ì§€";
        navControlButton.className = "px-5 py-2 bg-yellow-500 text-white font-bold rounded-full shadow-lg hover:bg-yellow-600 transition flex-shrink-0";
        updateGpsStatus("ok", "GPS ë° ë‚˜ì¹¨ë°˜ íƒìƒ‰ ì¤‘...");

        // 1. ë‚˜ì¹¨ë°˜
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(state => { if(state==='granted') window.addEventListener('deviceorientation', handleCompass); })
                .catch(console.error);
        } else {
            window.addEventListener('deviceorientation', handleCompass);
        }

        // 2. GPS
        gpsWatchId = navigator.geolocation.watchPosition(handleGps, handleError, {
            enableHighAccuracy: true, timeout: 5000, maximumAge: 1000
        });

        // ì´ˆê¸° ìœ„ì¹˜ ë³´ì •
        navigator.geolocation.getCurrentPosition(pos => {
            applyGpsOffset(pos.coords.latitude, pos.coords.longitude);
            handleGps(pos);
        });

        requestAnimationFrame(animateLoop);
    }

    function stopNavigation() {
        isNavigating = false;
        navControlButton.innerText = "ì¬ê°œ";
        navControlButton.className = "px-5 py-2 bg-green-500 text-white font-bold rounded-full shadow-lg hover:bg-green-600 transition flex-shrink-0";
        updateGpsStatus("err", "ì¼ì‹œ ì¤‘ì§€ë¨");
    }

    // --- ì„¼ì„œ ë° GPS ë¡œì§ ---
    function handleCompass(e) {
        if (e.alpha !== null) {
            let diff = e.alpha - currentDeviceHeading;
            while (diff < -180) diff += 360;
            while (diff > 180) diff -= 360;
            targetDeviceHeading = currentDeviceHeading + diff;
        }
    }

    function handleGps(pos) {
        const { latitude, longitude, accuracy, heading } = pos.coords;
        userPos = { lat: latitude, lon: longitude };

        // Heading Up (ì§€ë„ íšŒì „)
        if (heading !== null && !isNaN(heading)) {
            let targetRot = -heading; 
            let diff = targetRot - currentMapRotation;
            while (diff < -180) diff += 360;
            while (diff > 180) diff -= 360;
            targetMapRotation = currentMapRotation + diff;
        }

        if (isNavigating && lastRouteData) {
            const totalRemainingDist = calculateRemainingDistance(currentStepIndex, lastRouteData.steps);
            const step = lastRouteData.steps[currentStepIndex];
            const target = AREA_COORDINATES[step.to_area];
            const distToNext = calculateDistance(latitude, longitude, target.lat, target.lon);

            // UI ì—…ë°ì´íŠ¸
            updateNavigationBar(step, totalRemainingDist);
            renderStepsList(lastRouteData); 

            updateGpsStatus("ok", `GPS ìˆ˜ì‹ ì¤‘ (ì •í™•ë„ ${Math.round(accuracy)}m)`);

            // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì „í™˜
            if (distToNext < 8) { 
                currentStepIndex++;
                if (currentStepIndex >= lastRouteData.steps.length) {
                    finishNavigation();
                }
            }
        }
    }

    function handleError(err) { console.warn(err); }

    function applyGpsOffset(lat, lon) {
        if (!lastRouteData) return;
        const startCoord = ORIGINAL_AREA_COORDINATES[lastRouteData.start];
        const dLat = lat - startCoord.lat;
        const dLon = lon - startCoord.lon;
        AREA_IDS.forEach(id => {
            AREA_COORDINATES[id].lat = ORIGINAL_AREA_COORDINATES[id].lat + dLat;
            AREA_COORDINATES[id].lon = ORIGINAL_AREA_COORDINATES[id].lon + dLon;
        });
        recalculateMapBounds();
    }

    function finishNavigation() {
        if(gpsWatchId) navigator.geolocation.clearWatch(gpsWatchId);
        isNavigating = false;
        document.getElementById('nav-next-instruction').innerText = "ë„ì°© ì™„ë£Œ!";
        document.getElementById('nav-step-info').innerText = "ì•ˆë‚´ ì¢…ë£Œ";
        navControlButton.innerText = "ì¬ì„¤ì •";
        navControlButton.className = "px-5 py-2 bg-blue-600 text-white font-bold rounded-full shadow-lg";
        updateGpsStatus("ok", "ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤.");
        renderStepsList(lastRouteData);
        alert("ë„ì°©í–ˆìŠµë‹ˆë‹¤!");
    }

    // --- ì• ë‹ˆë©”ì´ì…˜ & ë Œë”ë§ ---
    function animateLoop() {
        if (!isNavigating) return;
        currentMapRotation += (targetMapRotation - currentMapRotation) * 0.05;
        currentDeviceHeading += (targetDeviceHeading - currentDeviceHeading) * 0.05;
        
        drawMap();
        requestAnimationFrame(animateLoop);
    }

    function latLonToCanvas(lat, lon) {
        const rLat = mapBounds.maxLat - mapBounds.minLat || 0.000001;
        const rLon = mapBounds.maxLon - mapBounds.minLon || 0.000001;
        const pad = 0.1;
        
        const mapWidth = canvas.width * (1-2*pad); 
        const mapHeight = canvas.height * (1-2*pad);
        const ox = canvas.width*pad; 
        const oy = canvas.height*pad;
        
        let x = ((lon - mapBounds.minLon)/rLon)*mapWidth + ox;
        let y = mapHeight - ((lat - mapBounds.minLat)/rLat)*mapHeight + oy;

        const cx = canvas.width/2; const cy = canvas.height/2;
        // ì¤Œ/íŒ¬ ì ìš©
        x = cx + (x-cx)*mapScale + mapTranslateX;
        y = cy + (y-cy)*mapScale + mapTranslateY;
        return {x,y};
    }

    function drawMap() {
        const cx = canvas.width/2; const cy = canvas.height/2;

        ctx.clearRect(0,0,canvas.width,canvas.height);
        ctx.save();

        // ì§€ë„ íšŒì „ (Heading Up)
        if(isNavigating) {
            ctx.translate(cx, cy);
            ctx.rotate(currentMapRotation * Math.PI / 180);
            ctx.translate(-cx, -cy);
        }

        // ê²½ë¡œ ë§í¬ ê·¸ë¦¬ê¸° (ë°°ê²½)
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=3;
        ALL_CONNECTIONS.forEach(c=>{
            const s=latLonToCanvas(AREA_COORDINATES[c.u].lat, AREA_COORDINATES[c.u].lon);
            const e=latLonToCanvas(AREA_COORDINATES[c.v].lat, AREA_COORDINATES[c.v].lon);
            ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(e.x,e.y); ctx.stroke();
        });

        // ì•ˆë‚´ ê²½ë¡œ ê·¸ë¦¬ê¸° (íŒŒë€ìƒ‰ ì„ )
        if(lastRouteData && lastRouteData.path) {
            ctx.strokeStyle='#3b82f6'; 
            ctx.lineWidth=6*mapScale; 
            ctx.lineCap='round'; 
            ctx.lineJoin='round';
            ctx.beginPath();
            let first=true;
            lastRouteData.path.forEach(id=>{
                const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
                if(first){ctx.moveTo(p.x,p.y); first=false;}else ctx.lineTo(p.x,p.y);
            });
            ctx.stroke();
        }

        // ì‚¬ìš©ì ìœ„ì¹˜ (ë¶€ì±„ê¼´ + ë§ˆì»¤)
        if(userPos) {
            const p = latLonToCanvas(userPos.lat, userPos.lon);
            
            // ì‹œì•¼ê° (ë¶€ì±„ê¼´)
            const angleRad = (currentDeviceHeading + currentMapRotation - 90) * Math.PI / 180;
            const fov = 60 * Math.PI / 180;

            ctx.beginPath(); ctx.moveTo(p.x,p.y);
            ctx.arc(p.x, p.y, 80 * mapScale, angleRad - fov/2, angleRad + fov/2);
            ctx.fillStyle = 'rgba(37, 99, 235, 0.2)'; 
            ctx.fill();

            // ìœ„ì¹˜ ë§ˆì»¤
            ctx.beginPath(); ctx.arc(p.x, p.y, 12 * mapScale, 0, Math.PI*2);
            ctx.fillStyle='#facc15'; ctx.strokeStyle='#fff'; ctx.lineWidth=3;
            ctx.fill(); ctx.stroke();
        }

        // ë…¸ë“œ (AREA ID)
        AREA_IDS.forEach(id=>{
            const p=latLonToCanvas(AREA_COORDINATES[id].lat, AREA_COORDINATES[id].lon);
            const isTarget = lastRouteData && id === lastRouteData.end;
            
            ctx.fillStyle = isTarget ? '#ef4444' : '#6b7280';
            ctx.beginPath(); ctx.arc(p.x, p.y, 5*mapScale, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle='#1f2937'; ctx.font=`bold ${12*mapScale}px sans-serif`; ctx.textAlign='center';
            ctx.fillText(id, p.x, p.y - 10*mapScale);
        });

        ctx.restore();
    }

    // --- ìœ í‹¸ë¦¬í‹° (ê²½ë¡œ ê³„ì‚°, ê±°ë¦¬ ê³„ì‚°) ---
    function calculatePath(start, end) {
        const dists={}, prev={}, q=new Set(AREA_IDS);
        AREA_IDS.forEach(i=>dists[i]=Infinity); dists[start]=0;
        while(q.size){
            let u=null; q.forEach(i=>{if(!u||dists[i]<dists[u])u=i;});
            if(u===end||dists[u]===Infinity) break; q.delete(u);
            ALL_CONNECTIONS.filter(c=>c.u===u).forEach(c=>{
                const alt=dists[u]+c.distance;
                if(alt<dists[c.v]){ dists[c.v]=alt; prev[c.v]=u; }
            });
        }
        if(dists[end]===Infinity) return {};
        const path=[]; let u=end; while(u){path.unshift(u); u=prev[u];}
        
        const steps=[];
        for(let i=0; i<path.length-1; i++){
            const c=ALL_CONNECTIONS.find(x=>x.u===path[i] && x.v===path[i+1]);
            steps.push({ to_area:path[i+1], distance:c.distance, turn:c.turn, instruction:c.instruction });
        }
        return { steps, totalDist:dists[end], totalTime:Math.ceil(dists[end]/1.0/60), path }; 
    }

    function calculateDistance(lat1,lon1,lat2,lon2){ 
        const R=6371e3, p1=lat1*Math.PI/180, p2=lat2*Math.PI/180, dp=(lat2-lat1)*Math.PI/180, dl=(lon2-lon1)*Math.PI/180;
        const a=Math.sin(dp/2)*Math.sin(dp/2)+Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)*Math.sin(dl/2);
        return R*2*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
    }
    
    function calculateRemainingDistance(startIndex, steps) {
        let remaining = 0;
        for (let i = startIndex; i < steps.length; i++) {
            remaining += steps[i].distance;
        }
        return remaining;
    }

    // ğŸŒŸğŸŒŸğŸŒŸ ì „ì²´ ê²½ë¡œ ëª©ë¡ ë Œë”ë§ í•¨ìˆ˜ ìˆ˜ì • (ë³¼ë“œì²´ ì œê±°) ğŸŒŸğŸŒŸğŸŒŸ
    function renderStepsList(data) {
        if (!data || data.steps.length === 0) {
            routeStepsList.innerHTML = '';
            return;
        }

        let html = '';
        data.steps.forEach((step, index) => {
            const isCurrent = isNavigating && index === currentStepIndex;
            const iconKey = step.turn === 'ì§ì§„' ? 'arrow-up' : step.turn === 'ìš°íšŒì „' ? 'corner-down-right' : step.turn === 'ì¢ŒíšŒì „' ? 'corner-down-left' : 'map-pin';
            
            const stepNumber = index + 1;

            html += `
                <div class="step-item ${isCurrent ? 'current' : ''}">
                    <i data-lucide="${iconKey}" class="w-4 h-4 text-gray-500 mr-3"></i>
                    <span class="text-sm text-gray-700">${stepNumber}. ${step.instruction} (${step.distance}m)</span>
                </div>
            `;
        });
        routeStepsList.innerHTML = html;
        lucide.createIcons();
        
        if (isNavigating) {
            const currentElement = routeStepsList.querySelector('.current');
            if (currentElement) {
                currentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }
    }
    // -----------------------------------------------------

    // í•˜ë‹¨ ë‚´ë¹„ê²Œì´ì…˜ ë°” ì—…ë°ì´íŠ¸ (ì´ê±°ë¦¬ í†µì¼ì„± í™•ë³´)
    function updateNavigationBar(step, totalRemainingDist) {
        document.getElementById('nav-next-instruction').innerText = step.instruction;
        document.getElementById('nav-step-info').innerText = `ë‚¨ì€ ì´ ê±°ë¦¬: ${Math.round(totalRemainingDist)}m`;
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="${TURN_ICONS[step.turn]||'arrow-up'}" class="w-7 h-7"></i>`;
        lucide.createIcons();
    }
    
    function renderGuidanceSummary(data) {
        outputDiv.innerHTML = `
            <div class="p-3 bg-blue-50 border border-blue-200 rounded-lg text-blue-800 font-bold">
                ì´ ${Math.round(data.totalDist)}m, ì•½ ${data.totalTime}ë¶„
            </div>
            <p class="text-gray-500 text-sm mt-3 font-semibold">ì „ì²´ ê²½ë¡œ</p>
        `;
    }

    function populate() {
        AREA_IDS.forEach(id => {
            const opt = `<option value="${id}">${AREA_NAMES[id]}</option>`;
            startSelect.insertAdjacentHTML('beforeend', opt); endSelect.insertAdjacentHTML('beforeend', opt);
        });
        endSelect.value = 'I';
    }

    // ì¤Œ/íŒ¬ í•¸ë“¤ëŸ¬ (ì§€ë„ ì¡°ì‘ ê¸°ëŠ¥)
    function setupInteractions() {
        // ì¤Œ (Zoom)
        canvas.addEventListener('wheel', e=>{ 
            e.preventDefault(); 
            mapScale=Math.max(0.6,Math.min(5, mapScale*(e.deltaY<0?1.1:0.9))); 
            drawMap(); 
        }, {passive:false});
        
        // íŒ¬ (Pan)
        let isD=false, lx, ly;
        canvas.addEventListener('touchstart', e=>{ 
            if(e.touches.length===1){isD=true; lx=e.touches[0].clientX; ly=e.touches[0].clientY;} 
        });
        canvas.addEventListener('touchmove', e=>{
            if(!isNavigating && isD && e.touches.length===1){
                e.preventDefault();
                mapTranslateX += e.touches[0].clientX - lx;
                mapTranslateY += e.touches[0].clientY - ly;
                lx=e.touches[0].clientX; ly=e.touches[0].clientY;
                drawMap();
            }
        });
        canvas.addEventListener('touchend', ()=>isD=false);
    }

    // ğŸŒŸğŸŒŸğŸŒŸ ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì • í•¨ìˆ˜ ìˆ˜ì • (ì§€ë„ ë¹„ìœ¨ ê³ ì •) ğŸŒŸğŸŒŸğŸŒŸ
    const resizeCanvas = () => {
        const rect = canvas.parentElement.getBoundingClientRect();
        
        const lonRange = mapBounds.maxLon - mapBounds.minLon;
        const latRange = mapBounds.maxLat - mapBounds.minLat;

        // ìœ„ë„ì™€ ê²½ë„ ì°¨ì´ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš© (ë‚˜ëˆ„ê¸° 0 ë°©ì§€)
        if (lonRange === 0 || latRange === 0) {
             canvas.width = rect.width;
             canvas.height = canvas.offsetHeight;
        } else {
             // 1ë„ëŠ” ìœ„ë„ì— ë”°ë¼ ë¯¸í„° ê¸¸ì´ê°€ ë‹¤ë¥´ì§€ë§Œ, ê°„í¸í™”ë¥¼ ìœ„í•´ ì´ ë²”ìœ„ì˜ ë¹„ìœ¨ë§Œ ì‚¬ìš©
             const aspectRatio = latRange / lonRange; 
             
             // ìº”ë²„ìŠ¤ widthëŠ” ë¶€ëª¨ ìš”ì†Œì˜ widthì— ë§ì¶¥ë‹ˆë‹¤.
             canvas.width = rect.width; 
             
             // ìº”ë²„ìŠ¤ heightë¥¼ widthì™€ ìœ„ë„/ê²½ë„ ë²”ìœ„ì˜ ë¹„ìœ¨ì— ë§ì¶° ì¡°ì •í•˜ì—¬ ë¹„ìœ¨ì„ ìœ ì§€
             // 1:1ì— ê°€ê¹Œìš´ ë¹„ìœ¨ì„ ì›í•œë‹¤ë©´, ì‹¤ì œ ê²½ë„/ìœ„ë„ ë¹„ìœ¨ (1:1.6~2.0)ì„ ì ìš©í•´ì•¼ í•©ë‹ˆë‹¤.
             // ì„ì‹œë¡œ ê°€ë¡œ(lon) ë²”ìœ„ì™€ ì„¸ë¡œ(lat) ë²”ìœ„ì˜ í”½ì…€ ë¹„ìœ¨ì„ ë§ì¶° ì •ì‚¬ê°í˜•ì²˜ëŸ¼ ë³´ì´ê²Œ í•©ë‹ˆë‹¤.
             // ì‹¤ì œ ì •ì‚¬ê°í˜• ëª¨ì–‘ì„ ìœ„í•´ ìº”ë²„ìŠ¤ ë†’ì´ë¥¼ ê³„ì‚°
             const calculatedHeight = rect.width * aspectRatio; 
             
             // ìµœì†Œ ë†’ì´ (min-height: 350px)ë¥¼ ë³´ì¥í•˜ë©´ì„œ ê³„ì‚°ëœ ë†’ì´ë¥¼ ì ìš©
             canvas.height = Math.max(350, calculatedHeight); 
             
             // CSS height ìŠ¤íƒ€ì¼ë„ ë™ê¸°í™”í•˜ì—¬ ì‹œê°ì ìœ¼ë¡œë„ ëŠ˜ì–´ì§€ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.
             canvas.style.height = `${canvas.height}px`;
        }
        
        drawMap();
    };
    // -------------------------------------------------------------------

    window.onload = function() {
        populate(); 
        recalculateMapBounds(); // ì—¬ê¸°ì„œ resizeCanvasê°€ ì²˜ìŒ í˜¸ì¶œë˜ì–´ ë¹„ìœ¨ì„ ë§ì¶¥ë‹ˆë‹¤.
        setupInteractions(); 
        document.getElementById('current-turn-icon').innerHTML = `<i data-lucide="compass" class="w-7 h-7"></i>`;
        lucide.createIcons();
        
        const p = new URLSearchParams(window.location.search);
        if(p.get('start') && AREA_IDS.includes(p.get('start'))) startSelect.value = p.get('start');
        
        // ì°½ í¬ê¸°ê°€ ë³€ê²½ë  ë•Œ, ìº”ë²„ìŠ¤ í¬ê¸°ë¥¼ ë‹¤ì‹œ ê³„ì‚°í•˜ê³  ì§€ë„ë¥¼ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
        window.addEventListener('resize', resizeCanvas); 
        
        // í°íŠ¸ ë° DOM ë¡œë”©ì„ ìœ„í•œ ìµœì¢… ë³´ì •
        setTimeout(resizeCanvas, 100);
    };
    </script>
</body>
</html>